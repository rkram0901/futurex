{"ast":null,"code":"import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\nvar mountCounters = new WeakMap();\nfunction setMountCounters(key, delta) {\n  var newValue;\n  var currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef) {\n  React.useEffect(function () {\n    var _a, _b;\n    var win = getWindow((_a = rootRef) === null || _a === void 0 ? void 0 : _a.current);\n    if (!win || ((_b = win.FabricConfig) === null || _b === void 0 ? void 0 : _b.disableFocusRects) === true) {\n      return undefined;\n    }\n    var count = setMountCounters(win, 1);\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n    return function () {\n      var _a;\n      if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n        return;\n      }\n      count = setMountCounters(win, -1);\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport var FocusRects = function FocusRects(props) {\n  useFocusRects(props.rootRef);\n  return null;\n};\nfunction _onMouseDown(ev) {\n  setFocusVisibility(false, ev.target);\n}\nfunction _onPointerDown(ev) {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target);\n  }\n}\nfunction _onKeyDown(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target);\n  }\n}","map":{"version":3,"names":["React","getWindow","isDirectionalKeyCode","setFocusVisibility","mountCounters","WeakMap","setMountCounters","key","delta","newValue","currValue","get","set","useFocusRects","rootRef","useEffect","win","_a","current","_b","FabricConfig","disableFocusRects","undefined","count","addEventListener","_onMouseDown","_onPointerDown","_onKeyDown","removeEventListener","FocusRects","props","ev","target","pointerType","which"],"sources":["C:\\Users\\Administrator\\frontendapp\\communicationapp\\node_modules\\@azure\\communication-react\\node_modules\\@fluentui\\react-northstar\\node_modules\\@uifabric\\utilities\\src\\useFocusRects.ts"],"sourcesContent":["import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\nlet mountCounters = new WeakMap<Window, number>();\n\nfunction setMountCounters(key: Window, delta: number): number {\n  let newValue;\n  const currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { disableFocusRects?: boolean } }) | undefined;\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef?: React.RefObject<HTMLElement>): void {\n  React.useEffect(() => {\n    const win = getWindow(rootRef?.current) as AppWindow;\n\n    if (!win || win.FabricConfig?.disableFocusRects === true) {\n      return undefined;\n    }\n\n    let count = setMountCounters(win, 1);\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n\n    return () => {\n      if (!win || win.FabricConfig?.disableFocusRects === true) {\n        return;\n      }\n\n      count = setMountCounters(win, -1);\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport const FocusRects: React.FunctionComponent<{ rootRef?: React.RefObject<HTMLElement> }> = props => {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev: MouseEvent): void {\n  setFocusVisibility(false, ev.target as Element);\n}\n\nfunction _onPointerDown(ev: PointerEvent): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element);\n  }\n}\n\nfunction _onKeyDown(ev: KeyboardEvent): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element);\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,SAAS,QAAQ,iBAAiB;AAC3C,SAASC,oBAAoB,QAAQ,YAAY;AACjD,SAASC,kBAAkB,QAAQ,sBAAsB;AAEzD;;;;AAIA,IAAIC,aAAa,GAAG,IAAIC,OAAO,EAAkB;AAEjD,SAASC,gBAAgBA,CAACC,GAAW,EAAEC,KAAa;EAClD,IAAIC,QAAQ;EACZ,IAAMC,SAAS,GAAGN,aAAa,CAACO,GAAG,CAACJ,GAAG,CAAC;EACxC,IAAIG,SAAS,EAAE;IACbD,QAAQ,GAAGC,SAAS,GAAGF,KAAK;GAC7B,MAAM;IACLC,QAAQ,GAAG,CAAC;;EAGdL,aAAa,CAACQ,GAAG,CAACL,GAAG,EAAEE,QAAQ,CAAC;EAChC,OAAOA,QAAQ;AACjB;AAIA;;;;;;;;;;;;;;;AAeA,OAAM,SAAUI,aAAaA,CAACC,OAAsC;EAClEd,KAAK,CAACe,SAAS,CAAC;;IACd,IAAMC,GAAG,GAAGf,SAAS,EAAAgB,EAAA,GAACH,OAAO,cAAAG,EAAA,uBAAAA,EAAA,CAAEC,OAAO,CAAc;IAEpD,IAAI,CAACF,GAAG,IAAI,EAAAG,EAAA,GAAAH,GAAG,CAACI,YAAY,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,iBAAiB,MAAK,IAAI,EAAE;MACxD,OAAOC,SAAS;;IAGlB,IAAIC,KAAK,GAAGjB,gBAAgB,CAACU,GAAG,EAAE,CAAC,CAAC;IACpC,IAAIO,KAAK,IAAI,CAAC,EAAE;MACdP,GAAG,CAACQ,gBAAgB,CAAC,WAAW,EAAEC,YAAY,EAAE,IAAI,CAAC;MACrDT,GAAG,CAACQ,gBAAgB,CAAC,aAAa,EAAEE,cAAc,EAAE,IAAI,CAAC;MACzDV,GAAG,CAACQ,gBAAgB,CAAC,SAAS,EAAEG,UAAU,EAAE,IAAI,CAAC;;IAGnD,OAAO;;MACL,IAAI,CAACX,GAAG,IAAI,EAAAC,EAAA,GAAAD,GAAG,CAACI,YAAY,cAAAH,EAAA,uBAAAA,EAAA,CAAEI,iBAAiB,MAAK,IAAI,EAAE;QACxD;;MAGFE,KAAK,GAAGjB,gBAAgB,CAACU,GAAG,EAAE,CAAC,CAAC,CAAC;MACjC,IAAIO,KAAK,KAAK,CAAC,EAAE;QACfP,GAAG,CAACY,mBAAmB,CAAC,WAAW,EAAEH,YAAY,EAAE,IAAI,CAAC;QACxDT,GAAG,CAACY,mBAAmB,CAAC,aAAa,EAAEF,cAAc,EAAE,IAAI,CAAC;QAC5DV,GAAG,CAACY,mBAAmB,CAAC,SAAS,EAAED,UAAU,EAAE,IAAI,CAAC;;IAExD,CAAC;EACH,CAAC,EAAE,CAACb,OAAO,CAAC,CAAC;AACf;AAEA;;;;AAIA,OAAO,IAAMe,UAAU,GAAwE,SAAlFA,UAAUA,CAAwEC,KAAK;EAClGjB,aAAa,CAACiB,KAAK,CAAChB,OAAO,CAAC;EAC5B,OAAO,IAAI;AACb,CAAC;AAED,SAASW,YAAYA,CAACM,EAAc;EAClC5B,kBAAkB,CAAC,KAAK,EAAE4B,EAAE,CAACC,MAAiB,CAAC;AACjD;AAEA,SAASN,cAAcA,CAACK,EAAgB;EACtC,IAAIA,EAAE,CAACE,WAAW,KAAK,OAAO,EAAE;IAC9B9B,kBAAkB,CAAC,KAAK,EAAE4B,EAAE,CAACC,MAAiB,CAAC;;AAEnD;AAEA,SAASL,UAAUA,CAACI,EAAiB;EACnC;EACA,IAAI7B,oBAAoB,CAAC6B,EAAE,CAACG,KAAK,CAAC,EAAE;IAClC/B,kBAAkB,CAAC,IAAI,EAAE4B,EAAE,CAACC,MAAiB,CAAC;;AAElD"},"metadata":{},"sourceType":"module","externalDependencies":[]}