"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.styles = void 0;
var tslib_1 = require("tslib");
var StackUtils_1 = require("./StackUtils");
var Styling_1 = require("../../Styling");
var nameMap = {
    start: 'flex-start',
    end: 'flex-end',
};
var GlobalClassNames = {
    root: 'ms-Stack',
    inner: 'ms-Stack-inner',
};
var styles = function (props, theme, tokens) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var verticalFill = props.verticalFill, horizontal = props.horizontal, reversed = props.reversed, grow = props.grow, wrap = props.wrap, horizontalAlign = props.horizontalAlign, verticalAlign = props.verticalAlign, disableShrink = props.disableShrink, className = props.className;
    var classNames = Styling_1.getGlobalClassNames(GlobalClassNames, theme);
    /* eslint-disable deprecation/deprecation */
    var childrenGap = tokens && tokens.childrenGap ? tokens.childrenGap : props.gap;
    var maxHeight = tokens && tokens.maxHeight ? tokens.maxHeight : props.maxHeight;
    var maxWidth = tokens && tokens.maxWidth ? tokens.maxWidth : props.maxWidth;
    var padding = tokens && tokens.padding ? tokens.padding : props.padding;
    /* eslint-enable deprecation/deprecation */
    var _j = StackUtils_1.parseGap(childrenGap, theme), rowGap = _j.rowGap, columnGap = _j.columnGap;
    var horizontalMargin = "" + -0.5 * columnGap.value + columnGap.unit;
    var verticalMargin = "" + -0.5 * rowGap.value + rowGap.unit;
    // styles to be applied to all direct children regardless of wrap or direction
    var childStyles = {
        textOverflow: 'ellipsis',
    };
    // selectors to be applied regardless of wrap or direction
    var disableShrinkStyles = {
        // flexShrink styles are applied by the StackItem
        '> *:not(.ms-StackItem)': {
            flexShrink: 0,
        },
    };
    if (wrap) {
        return {
            root: [
                classNames.root,
                {
                    flexWrap: 'wrap',
                    maxWidth: maxWidth,
                    maxHeight: maxHeight,
                    width: 'auto',
                    overflow: 'visible',
                    height: '100%',
                },
                horizontalAlign && (_a = {},
                    _a[horizontal ? 'justifyContent' : 'alignItems'] = nameMap[horizontalAlign] || horizontalAlign,
                    _a),
                verticalAlign && (_b = {},
                    _b[horizontal ? 'alignItems' : 'justifyContent'] = nameMap[verticalAlign] || verticalAlign,
                    _b),
                className,
                {
                    // not allowed to be overridden by className
                    // since this is necessary in order to prevent collapsing margins
                    display: 'flex',
                },
                horizontal && {
                    height: verticalFill ? '100%' : 'auto',
                },
            ],
            inner: [
                classNames.inner,
                {
                    display: 'flex',
                    flexWrap: 'wrap',
                    marginLeft: horizontalMargin,
                    marginRight: horizontalMargin,
                    marginTop: verticalMargin,
                    marginBottom: verticalMargin,
                    overflow: 'visible',
                    boxSizing: 'border-box',
                    padding: StackUtils_1.parsePadding(padding, theme),
                    // avoid unnecessary calc() calls if horizontal gap is 0
                    width: columnGap.value === 0 ? '100%' : "calc(100% + " + columnGap.value + columnGap.unit + ")",
                    maxWidth: '100vw',
                    '> *': tslib_1.__assign({ margin: "" + 0.5 * rowGap.value + rowGap.unit + " " + 0.5 * columnGap.value + columnGap.unit }, childStyles),
                },
                disableShrink && disableShrinkStyles,
                horizontalAlign && (_c = {},
                    _c[horizontal ? 'justifyContent' : 'alignItems'] = nameMap[horizontalAlign] || horizontalAlign,
                    _c),
                verticalAlign && (_d = {},
                    _d[horizontal ? 'alignItems' : 'justifyContent'] = nameMap[verticalAlign] || verticalAlign,
                    _d),
                horizontal && {
                    flexDirection: reversed ? 'row-reverse' : 'row',
                    // avoid unnecessary calc() calls if vertical gap is 0
                    height: rowGap.value === 0 ? '100%' : "calc(100% + " + rowGap.value + rowGap.unit + ")",
                    '> *': {
                        maxWidth: columnGap.value === 0 ? '100%' : "calc(100% - " + columnGap.value + columnGap.unit + ")",
                    },
                },
                !horizontal && {
                    flexDirection: reversed ? 'column-reverse' : 'column',
                    height: "calc(100% + " + rowGap.value + rowGap.unit + ")",
                    '> *': {
                        maxHeight: rowGap.value === 0 ? '100%' : "calc(100% - " + rowGap.value + rowGap.unit + ")",
                    },
                },
            ],
        };
    }
    return {
        root: [
            classNames.root,
            {
                display: 'flex',
                flexDirection: horizontal ? (reversed ? 'row-reverse' : 'row') : reversed ? 'column-reverse' : 'column',
                flexWrap: 'nowrap',
                width: 'auto',
                height: verticalFill ? '100%' : 'auto',
                maxWidth: maxWidth,
                maxHeight: maxHeight,
                padding: StackUtils_1.parsePadding(padding, theme),
                boxSizing: 'border-box',
                '> *': childStyles,
            },
            disableShrink && disableShrinkStyles,
            grow && {
                flexGrow: grow === true ? 1 : grow,
            },
            horizontal &&
                columnGap.value > 0 && (_e = {},
                // apply gap margin to every direct child except the first direct child if the direction is not reversed,
                // and the last direct one if it is
                _e[reversed ? '> *:not(:last-child)' : '> *:not(:first-child)'] = {
                    marginLeft: "" + columnGap.value + columnGap.unit,
                },
                _e),
            !horizontal &&
                rowGap.value > 0 && (_f = {},
                // apply gap margin to every direct child except the first direct child if the direction is not reversed,
                // and the last direct one if it is
                _f[reversed ? '> *:not(:last-child)' : '> *:not(:first-child)'] = {
                    marginTop: "" + rowGap.value + rowGap.unit,
                },
                _f),
            horizontalAlign && (_g = {},
                _g[horizontal ? 'justifyContent' : 'alignItems'] = nameMap[horizontalAlign] || horizontalAlign,
                _g),
            verticalAlign && (_h = {},
                _h[horizontal ? 'alignItems' : 'justifyContent'] = nameMap[verticalAlign] || verticalAlign,
                _h),
            className,
        ],
        // TODO: this cast may be hiding some potential issues with styling and name
        //        lookups and should be removed
    };
};
exports.styles = styles;
//# sourceMappingURL=Stack.styles.js.map