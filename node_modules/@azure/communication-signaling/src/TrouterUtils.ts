// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

import {
  TrouterMessage,
  MessageHandler,
  HandleMessageResult,
  LogProvider,
  ITelemetrySender,
  TelemetryEvent
} from "@skype/tstrouter";
import { AzureLogger } from "@azure/logger";
import {
  MessageReceivedPayload,
  MessageEditedPayload,
  MessageDeletedPayload,
  TypingIndicatorReceivedPayload,
  ReadReceiptReceivedPayload,
  ReadReceiptMessageBody,
  ChatThreadCreatedPayload,
  ChatThreadDeletedPayload,
  ChatThreadPropertiesUpdatedPayload,
  ParticipantsAddedPayload,
  ParticipantsRemovedPayload,
  ChatParticipantPayload
} from "./TrouterNotificationPayload";
import {
  ChatEventId,
  ChatMessageReceivedEvent,
  ChatMessageEditedEvent,
  ChatMessageDeletedEvent,
  ReadReceiptReceivedEvent,
  TypingIndicatorReceivedEvent,
  ChatThreadCreatedEvent,
  ChatThreadDeletedEvent,
  ChatThreadPropertiesUpdatedEvent,
  ParticipantsAddedEvent,
  ParticipantsRemovedEvent,
  ChatParticipant,
  ChatThreadProperties
} from "./events/chat";
import {
  CommunicationUserKind,
  PhoneNumberKind,
  MicrosoftTeamsUserKind,
  UnknownIdentifierKind
} from "./events/identifierModels";
import { CommunicationTokenCredential } from "./SignalingClient";
import { isNode } from "@azure/core-http";
import { CloudPrefix, CloudType } from "./constants";

const eventIds = new Map<ChatEventId, number>([
  ["chatMessageReceived", 200],
  ["typingIndicatorReceived", 245],
  ["readReceiptReceived", 246],
  ["chatMessageEdited", 247],
  ["chatMessageDeleted", 248],
  ["chatThreadCreated", 257],
  ["chatThreadPropertiesUpdated", 258],
  ["chatThreadDeleted", 259],
  ["participantsAdded", 260],
  ["participantsRemoved", 261]
]);

const publicTeamsUserPrefix = "8:orgid:";
const dodTeamsUserPrefix = "8:dod:";
const gcchTeamsUserPrefix = "8:gcch:";
const teamsVisitorUserPrefix = "8:teamsvisitor:";
const phoneNumberPrefix = "4:";
const acsUserPrefix = "8:acs:";
const acsGcchUserPrefix = "8:gcch-acs:";
const acsDodUserPrefix = "8:dod-acs:";
const spoolUserPrefix = "8:spool:";

export const toMessageHandler = (
  event: ChatEventId,
  listener: (payload: any) => any
): MessageHandler => {
  const eventId = eventIds.get(event);
  return {
    handleMessage(message: TrouterMessage): HandleMessageResult | undefined {
      let genericPayload = null;
      if (message?.rawBody) {
        genericPayload = JSON.parse(message.rawBody);
      }
      if (genericPayload === null || genericPayload.eventId !== eventId) {
        return undefined;
      }
      const eventPayload = toEventPayload(event, genericPayload);
      if (eventPayload === null) {
        return undefined;
      }
      listener(eventPayload);
      return { isHandled: true, resultCode: 200 };
    }
  };
};

const toEventPayload = (event: ChatEventId, genericPayload: any): any => {
  if (event === "chatMessageReceived") {
    const payload = genericPayload as MessageReceivedPayload;
    const eventPayload: ChatMessageReceivedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: payload.senderDisplayName,
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      id: payload.messageId,
      createdOn: new Date(payload.originalArrivalTime),
      version: payload.version,
      type: payload.messageType,
      message: payload.messageBody,
      metadata: parseMetadata(payload.acsChatMessageMetadata)
    };
    return eventPayload;
  }

  if (event === "chatMessageEdited") {
    const payload = genericPayload as MessageEditedPayload;
    const eventPayload: ChatMessageEditedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: payload.senderDisplayName,
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      id: payload.messageId,
      createdOn: new Date(payload.originalArrivalTime),
      version: payload.version,
      message: payload.messageBody,
      editedOn: new Date(payload.edittime),
      type: payload.messageType,
      metadata: parseMetadata(payload.acsChatMessageMetadata)
    };
    return eventPayload;
  }

  if (event === "chatMessageDeleted") {
    const payload = genericPayload as MessageDeletedPayload;
    const eventPayload: ChatMessageDeletedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: payload.senderDisplayName,
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      id: payload.messageId,
      createdOn: new Date(payload.originalArrivalTime),
      version: payload.version,
      deletedOn: new Date(payload.deletetime),
      type: payload.messageType
    };
    return eventPayload;
  }

  if (event === "typingIndicatorReceived") {
    const payload = genericPayload as TypingIndicatorReceivedPayload;
    const eventPayload: TypingIndicatorReceivedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: payload.senderDisplayName,
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      version: payload.version,
      receivedOn: new Date(payload.originalArrivalTime)
    };
    return eventPayload;
  }

  if (event === "readReceiptReceived") {
    const payload = genericPayload as ReadReceiptReceivedPayload;
    const readReceiptMessageBody = JSON.parse(payload.messageBody) as ReadReceiptMessageBody;
    const consumptionHorizon = readReceiptMessageBody.consumptionhorizon.split(";");
    const eventPayload: ReadReceiptReceivedEvent = {
      threadId: payload.groupId,
      sender: constructIdentifierKindFromMri(payload.senderId),
      senderDisplayName: "",
      recipient: constructIdentifierKindFromMri(payload.recipientMri),
      chatMessageId: payload.messageId,
      readOn: new Date(+consumptionHorizon[1])
    };
    return eventPayload;
  }

  if (event === "chatThreadCreated") {
    const payload = genericPayload as ChatThreadCreatedPayload;
    const createdByPayload = JSON.parse(unescape(payload.createdBy)) as ChatParticipantPayload;
    const membersPayload = JSON.parse(unescape(payload.members)) as ChatParticipantPayload[];
    const propertiesPayload = JSON.parse(unescape(payload.properties)) as ChatThreadProperties;
    const createdBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(createdByPayload.participantId),
      displayName: createdByPayload.displayName
    };
    const chatParticipants: ChatParticipant[] = membersPayload.map((m) => {
      return {
        id: constructIdentifierKindFromMri(m.participantId),
        displayName: m.displayName
      };
    });
    const eventPayload: ChatThreadCreatedEvent = {
      threadId: payload.threadId,
      createdOn: new Date(payload.createTime),
      createdBy: createdBy,
      version: payload.version,
      participants: chatParticipants,
      properties: propertiesPayload
    };
    return eventPayload;
  }

  if (event === "chatThreadPropertiesUpdated") {
    const payload = genericPayload as ChatThreadPropertiesUpdatedPayload;
    const updatedByPayload = JSON.parse(unescape(payload.editedBy)) as ChatParticipantPayload;
    const propertiesPayload = JSON.parse(unescape(payload.properties)) as ChatThreadProperties;
    const updatedBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(updatedByPayload.participantId),
      displayName: updatedByPayload.displayName
    };
    const eventPayload: ChatThreadPropertiesUpdatedEvent = {
      threadId: payload.threadId,
      updatedOn: new Date(payload.editTime),
      updatedBy: updatedBy,
      version: payload.version,
      properties: propertiesPayload
    };
    return eventPayload;
  }

  if (event === "chatThreadDeleted") {
    const payload = genericPayload as ChatThreadDeletedPayload;
    const deletedByPayload = JSON.parse(unescape(payload.deletedBy)) as ChatParticipantPayload;
    const deletedBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(deletedByPayload.participantId),
      displayName: deletedByPayload.displayName
    };
    const eventPayload: ChatThreadDeletedEvent = {
      threadId: payload.threadId,
      deletedOn: new Date(payload.deleteTime),
      deletedBy: deletedBy,
      version: payload.version
    };
    return eventPayload;
  }

  if (event === "participantsAdded") {
    const payload = genericPayload as ParticipantsAddedPayload;
    const addedByPayload = JSON.parse(unescape(payload.addedBy)) as ChatParticipantPayload;
    const participantsAddedPayload = JSON.parse(
      unescape(payload.participantsAdded)
    ) as ChatParticipantPayload[];
    const addedBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(addedByPayload.participantId),
      displayName: addedByPayload.displayName
    };
    const chatParticipants: ChatParticipant[] = participantsAddedPayload.map((m) => {
      return {
        id: constructIdentifierKindFromMri(m.participantId),
        displayName: m.displayName,
        shareHistoryTime: new Date(m.shareHistoryTime)
      };
    });
    const eventPayload: ParticipantsAddedEvent = {
      threadId: payload.threadId,
      addedOn: new Date(payload.time),
      addedBy: addedBy,
      version: payload.version,
      participantsAdded: chatParticipants
    };
    return eventPayload;
  }

  if (event === "participantsRemoved") {
    const payload = genericPayload as ParticipantsRemovedPayload;
    const removedByPayload = JSON.parse(unescape(payload.removedBy)) as ChatParticipantPayload;
    const participantsRemovedPayload = JSON.parse(
      unescape(payload.participantsRemoved)
    ) as ChatParticipantPayload[];
    const removedBy: ChatParticipant = {
      id: constructIdentifierKindFromMri(removedByPayload.participantId),
      displayName: removedByPayload.displayName
    };
    const chatParticipants: ChatParticipant[] = participantsRemovedPayload.map((m) => {
      return {
        id: constructIdentifierKindFromMri(m.participantId),
        displayName: m.displayName,
        shareHistoryTime: new Date(m.shareHistoryTime)
      };
    });
    const eventPayload: ParticipantsRemovedEvent = {
      threadId: payload.threadId,
      removedOn: new Date(payload.time),
      removedBy: removedBy,
      version: payload.version,
      participantsRemoved: chatParticipants
    };
    return eventPayload;
  }

  return null;
};

export const toLogProvider = (logger: AzureLogger): LogProvider => {
  return {
    log: (...message: any) => logger.info(message),
    warn: (...message: any[]) => logger.warning(message),
    error: (...message: any[]) => logger.error(message),
    debug: (...message: any[]) => logger.verbose(message),
    info: (...message: any[]) => logger.verbose(message)
  };
};

export const toTelemetrySender = (logger: AzureLogger): ITelemetrySender => {
  return {
    logEvent: (clientEvent: TelemetryEvent) => logger.info(clientEvent)
  };
};

const constructIdentifierKindFromMri = (
  mri: string
): CommunicationUserKind | PhoneNumberKind | MicrosoftTeamsUserKind | UnknownIdentifierKind => {
  if (mri.startsWith(publicTeamsUserPrefix)) {
    return {
      kind: "microsoftTeamsUser",
      rawId: mri,
      microsoftTeamsUserId: mri.substring(publicTeamsUserPrefix.length),
      isAnonymous: false,
      cloud: "public"
    };
  } else if (mri.startsWith(dodTeamsUserPrefix)) {
    return {
      kind: "microsoftTeamsUser",
      rawId: mri,
      microsoftTeamsUserId: mri.substring(dodTeamsUserPrefix.length),
      isAnonymous: false,
      cloud: "dod"
    };
  } else if (mri.startsWith(gcchTeamsUserPrefix)) {
    return {
      kind: "microsoftTeamsUser",
      rawId: mri,
      microsoftTeamsUserId: mri.substring(gcchTeamsUserPrefix.length),
      isAnonymous: false,
      cloud: "gcch"
    };
  } else if (mri.startsWith(teamsVisitorUserPrefix)) {
    return {
      kind: "microsoftTeamsUser",
      rawId: mri,
      microsoftTeamsUserId: mri.substring(teamsVisitorUserPrefix.length),
      isAnonymous: true
    };
  } else if (mri.startsWith(phoneNumberPrefix)) {
    return {
      kind: "phoneNumber",
      rawId: mri,
      phoneNumber: mri.substring(phoneNumberPrefix.length)
    };
  } else if (mri.startsWith(acsUserPrefix)
    || mri.startsWith(acsGcchUserPrefix)
    || mri.startsWith(acsDodUserPrefix)
    || mri.startsWith(spoolUserPrefix)) {
    return { kind: "communicationUser", communicationUserId: mri };
  } else {
    return { kind: "unknown", id: mri };
  }
};

const parseMetadata = (metadata: string): Record<string, string> => {
  if (metadata === undefined || metadata === null || metadata === "" || metadata === "null") {
    return {} as Record<string, string>;
  }

  return JSON.parse(metadata) as Record<string, string>;
};

export function base64decode(encodedString: string): string {
  return !isNode ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
}

const parseJWT = (token: string): any => {
  let [, payload] = token?.split(".");
  if (payload === undefined) {
    throw new Error("Invalid token");
  }
  payload = payload.replace(/-/g, "+").replace(/_/g, "/");
  return JSON.parse(decodeURIComponent(escape(base64decode(payload))));
};

export const getCloudTypeFromCredential = async (
  credential: CommunicationTokenCredential
): Promise<CloudType> => {
  const accessToken = await credential.getToken();
  let jwtToken = accessToken?.token;
  let parsedJwtToken = parseJWT(jwtToken);
  let identityMri = parsedJwtToken.skypeid;

  return getCloudTypeFromSkypeId(identityMri);
};

function getCloudTypeFromSkypeId(skypeId: string): CloudType {
  const cloudPrefix = skypeId.substring(0, skypeId.indexOf(":"));

  switch (cloudPrefix) {
    case CloudPrefix.OrgId:
    case CloudPrefix.Acs:
    case CloudPrefix.Spool: {
      return CloudType.Public;
    }

    case CloudPrefix.GccHigh:
    case CloudPrefix.GccHighAcs: {
      return CloudType.GccHigh;
    }

    case CloudPrefix.Dod:
    case CloudPrefix.DodAcs: {
      return CloudType.Dod;
    }

    default: {
      return CloudType.Public;
    }
  }
}
