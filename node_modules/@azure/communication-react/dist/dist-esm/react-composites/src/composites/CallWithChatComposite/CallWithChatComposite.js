// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import React, { useCallback, useState, useMemo, useEffect, useRef } from 'react';
import { LayerHost, mergeStyles, Stack } from '@fluentui/react';
import { CallComposite } from '../CallComposite';
import { CallAdapterProvider } from '../CallComposite/adapter/CallAdapterProvider';
import { CallWithChatControlBar } from './CallWithChatControlBar';
import { callCompositeContainerStyles, compositeOuterContainerStyles, controlBarContainerStyles } from './styles/CallWithChatCompositeStyles';
import { CallWithChatBackedCallAdapter } from './adapter/CallWithChatBackedCallAdapter';
import { CallWithChatBackedChatAdapter } from './adapter/CallWithChatBackedChatAdapter';
import { BaseProvider } from '../common/BaseComposite';
import { ChatAdapterProvider } from '../ChatComposite/adapter/ChatAdapterProvider';
import { PreparedMoreDrawer } from './PreparedMoreDrawer';
import { _useContainerHeight, _useContainerWidth } from "../../../../react-components/src";
import { useId } from '@fluentui/react-hooks';
import { CallWithChatPane } from './CallWithChatPane';
import { containerDivStyles } from '../common/ContainerRectProps';
import { modalLayerHostStyle } from '../common/styles/ModalLocalAndRemotePIP.styles';
import { drawerContainerStyles } from '../CallComposite/styles/CallComposite.styles';
const CallWithChatScreen = (props) => {
    const { callWithChatAdapter, fluentTheme, formFactor = 'desktop' } = props;
    const mobileView = formFactor === 'mobile';
    if (!callWithChatAdapter) {
        throw new Error('CallWithChatAdapter is undefined');
    }
    const callAdapter = useMemo(() => new CallWithChatBackedCallAdapter(callWithChatAdapter), [callWithChatAdapter]);
    const [currentCallState, setCurrentCallState] = useState();
    const [currentPage, setCurrentPage] = useState();
    const [activePane, setActivePane] = useState('none');
    const containerRef = useRef(null);
    const containerWidth = _useContainerWidth(containerRef);
    const containerHeight = _useContainerHeight(containerRef);
    useEffect(() => {
        const updateCallWithChatPage = (newState) => {
            var _a;
            setCurrentPage(newState.page);
            setCurrentCallState((_a = newState.call) === null || _a === void 0 ? void 0 : _a.state);
        };
        updateCallWithChatPage(callWithChatAdapter.getState());
        callWithChatAdapter.onStateChange(updateCallWithChatPage);
        return () => {
            callWithChatAdapter.offStateChange(updateCallWithChatPage);
        };
    }, [callWithChatAdapter]);
    const closePane = useCallback(() => {
        setActivePane('none');
    }, [setActivePane]);
    const chatProps = useMemo(() => {
        return {
            adapter: new CallWithChatBackedChatAdapter(callWithChatAdapter)
        };
    }, [callWithChatAdapter]);
    const modalLayerHostId = useId('modalLayerhost');
    const isInLobbyOrConnecting = currentPage === 'lobby';
    const hasJoinedCall = !!(currentPage && hasJoinedCallFn(currentPage, currentCallState !== null && currentCallState !== void 0 ? currentCallState : 'None'));
    const showControlBar = isInLobbyOrConnecting || hasJoinedCall;
    const isMobileWithActivePane = mobileView && hasJoinedCall && activePane !== 'none';
    /** Constant setting of id for the parent stack of the composite */
    const compositeParentDivId = useId('callWithChatCompositeParentDiv-internal');
    const toggleChat = useCallback(() => {
        if (activePane === 'chat' || !hasJoinedCall) {
            setActivePane('none');
        }
        else {
            setActivePane('chat');
            // timeout is required to give the window time to render the sendbox so we have something to send focus to.
            // TODO: Selecting elements in the DOM via attributes is not stable. We should expose an API from ChatComposite to be able to focus on the sendbox.
            const chatFocusTimeout = setInterval(() => {
                const callWithChatCompositeRootDiv = document.querySelector(`[id="${compositeParentDivId}"]`);
                const sendbox = callWithChatCompositeRootDiv === null || callWithChatCompositeRootDiv === void 0 ? void 0 : callWithChatCompositeRootDiv.querySelector(`[id="sendbox"]`);
                if (sendbox !== null) {
                    sendbox.focus();
                    clearInterval(chatFocusTimeout);
                }
            }, 3);
            setTimeout(() => {
                clearInterval(chatFocusTimeout);
            }, 300);
        }
    }, [activePane, setActivePane, compositeParentDivId, hasJoinedCall]);
    const togglePeople = useCallback(() => {
        if (activePane === 'people' || !hasJoinedCall) {
            setActivePane('none');
        }
        else {
            setActivePane('people');
        }
    }, [activePane, setActivePane, hasJoinedCall]);
    const selectChat = useCallback(() => {
        if (hasJoinedCall) {
            setActivePane('chat');
        }
    }, [setActivePane, hasJoinedCall]);
    const selectPeople = useCallback(() => {
        if (hasJoinedCall) {
            setActivePane('people');
        }
    }, [setActivePane, hasJoinedCall]);
    const [showDrawer, setShowDrawer] = useState(false);
    const onMoreButtonClicked = useCallback(() => {
        closePane();
        setShowDrawer(true);
    }, [closePane]);
    const closeDrawer = useCallback(() => {
        setShowDrawer(false);
    }, []);
    const onMoreDrawerPeopleClicked = useCallback(() => {
        setShowDrawer(false);
        togglePeople();
    }, [togglePeople]);
    // On mobile, when there is an active call and some side pane is active,
    // we hide the call composite via CSS to show only the pane.
    // We only set `display` to `none` instead of unmounting the call composite component tree
    // to avoid the performance cost of rerendering video streams when we later show the composite again.
    const callCompositeContainerCSS = useMemo(() => {
        return {
            display: isMobileWithActivePane ? 'none' : 'flex'
        };
    }, [isMobileWithActivePane]);
    const callCompositeOptions = useMemo(() => ({
        callControls: false
    }), []);
    return React.createElement("div", { ref: containerRef, className: mergeStyles(containerDivStyles) },
        React.createElement(Stack, { verticalFill: true, grow: true, styles: compositeOuterContainerStyles, id: compositeParentDivId },
            React.createElement(Stack, { horizontal: true, grow: true },
                React.createElement(Stack.Item, { grow: true, styles: callCompositeContainerStyles, 
                    // Perf: Instead of removing the video gallery from DOM, we hide it to prevent re-renders.
                    style: callCompositeContainerCSS },
                    React.createElement(CallComposite, Object.assign({}, props, { formFactor: formFactor, options: callCompositeOptions, adapter: callAdapter, fluentTheme: fluentTheme }))),
                chatProps.adapter && callAdapter && hasJoinedCall && React.createElement(CallWithChatPane, { chatCompositeProps: chatProps, inviteLink: props.joinInvitationURL, onClose: closePane, chatAdapter: chatProps.adapter, callAdapter: callAdapter, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData, onFetchParticipantMenuItems: props.onFetchParticipantMenuItems, onChatButtonClicked: showShowChatTabHeaderButton(props.callControls) ? selectChat : undefined, onPeopleButtonClicked: showShowPeopleTabHeaderButton(props.callControls) ? selectPeople : undefined, modalLayerHostId: modalLayerHostId, mobileView: mobileView, activePane: activePane, rtl: props.rtl, callControls: typeof props.callControls !== 'boolean' ? props.callControls : undefined })),
            showControlBar && !isMobileWithActivePane && React.createElement(ChatAdapterProvider, { adapter: chatProps.adapter },
                React.createElement(Stack.Item, { styles: controlBarContainerStyles },
                    React.createElement(CallWithChatControlBar, { callAdapter: callAdapter, chatAdapter: chatProps.adapter, chatButtonChecked: activePane === 'chat', onChatButtonClicked: toggleChat, peopleButtonChecked: activePane === 'people', onPeopleButtonClicked: togglePeople, onMoreButtonClicked: onMoreButtonClicked, mobileView: mobileView, disableButtonsForLobbyPage: isInLobbyOrConnecting, callControls: props.callControls, containerHeight: containerHeight, containerWidth: containerWidth }))),
            showControlBar && showDrawer && React.createElement(ChatAdapterProvider, { adapter: chatProps.adapter },
                React.createElement(CallAdapterProvider, { adapter: callAdapter },
                    React.createElement(Stack, { styles: drawerContainerStyles() },
                        React.createElement(PreparedMoreDrawer, { callControls: props.callControls, onLightDismiss: closeDrawer, onPeopleButtonClicked: onMoreDrawerPeopleClicked })))),
            // This layer host is for ModalLocalAndRemotePIP in CallWithChatPane. This LayerHost cannot be inside the CallWithChatPane
            // because when the CallWithChatPane is hidden, ie. style property display is 'none', it takes up no space. This causes problems when dragging
            // the Modal because the draggable bounds thinks it has no space and will always return to its initial position after dragging.
            mobileView && React.createElement(LayerHost, { id: modalLayerHostId, className: mergeStyles(modalLayerHostStyle) })));
};
/**
 * CallWithChatComposite brings together key components to provide a full call with chat experience out of the box.
 *
 * @public
 */
export const CallWithChatComposite = (props) => {
    const { adapter, fluentTheme, rtl, formFactor, joinInvitationURL, options } = props;
    return React.createElement(BaseProvider, { fluentTheme: fluentTheme, rtl: rtl, locale: props.locale, icons: props.icons },
        React.createElement(CallWithChatScreen, Object.assign({}, props, { callWithChatAdapter: adapter, formFactor: formFactor, callControls: options === null || options === void 0 ? void 0 : options.callControls, joinInvitationURL: joinInvitationURL, fluentTheme: fluentTheme })));
};
const hasJoinedCallFn = (page, callStatus) => {
    return page === 'call' && (callStatus === 'Connected' || callStatus === 'Disconnecting');
};
const showShowChatTabHeaderButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.chatButton !== false;
};
const showShowPeopleTabHeaderButton = (callControls) => {
    if (callControls === undefined || callControls === true) {
        return true;
    }
    if (callControls === false) {
        return false;
    }
    return callControls.peopleButton !== false;
};
//# sourceMappingURL=CallWithChatComposite.js.map