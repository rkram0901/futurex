// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import React, { useMemo } from 'react';
import { CallAdapterProvider } from '../CallComposite/adapter/CallAdapterProvider';
import { PeopleButton } from './PeopleButton';
import { concatStyleSets, mergeStyles, mergeStyleSets, Stack, useTheme } from '@fluentui/react';
import { controlBarContainerStyles } from '../CallComposite/styles/CallControls.styles';
import { callControlsContainerStyles } from '../CallComposite/styles/CallPage.styles';
import { useCallWithChatCompositeStrings } from './hooks/useCallWithChatCompositeStrings';
import { ChatButtonWithUnreadMessagesBadge } from './ChatButtonWithUnreadMessagesBadge';
import { ControlBar } from "../../../../react-components/src";
import { Microphone } from '../CallComposite/components/buttons/Microphone';
import { Camera } from '../CallComposite/components/buttons/Camera';
import { ScreenShare } from '../CallComposite/components/buttons/ScreenShare';
import { EndCall } from '../CallComposite/components/buttons/EndCall';
import { MoreButton } from '../common/MoreButton';
import { isDisabled } from '../CallComposite/utils';
import { HiddenFocusStartPoint } from '../common/HiddenFocusStartPoint';
const inferCallWithChatControlOptions = (mobileView, callWithChatControls) => {
    if (callWithChatControls === false) {
        return false;
    }
    const options = callWithChatControls === true || callWithChatControls === undefined ? {} : callWithChatControls;
    if (mobileView) {
        // Set to compressed mode when composite is optimized for mobile
        options.displayType = 'compact';
        // Do not show screen share button when composite is optimized for mobile unless the developer
        // has explicitly opted in.
        if (options.screenShareButton !== true) {
            options.screenShareButton = false;
        }
    }
    return options;
};
/**
 * @private
 */
export const CallWithChatControlBar = (props) => {
    const theme = useTheme();
    const callWithChatStrings = useCallWithChatCompositeStrings();
    const options = inferCallWithChatControlOptions(props.mobileView, props.callControls);
    const chatButtonStrings = useMemo(() => ({
        label: callWithChatStrings.chatButtonLabel,
        tooltipOffContent: callWithChatStrings.chatButtonTooltipOpen,
        tooltipOnContent: callWithChatStrings.chatButtonTooltipClose
    }), [callWithChatStrings]);
    const peopleButtonStrings = useMemo(() => ({
        label: callWithChatStrings.peopleButtonLabel,
        tooltipOffContent: callWithChatStrings.peopleButtonTooltipOpen,
        tooltipOnContent: callWithChatStrings.peopleButtonTooltipClose
    }), [callWithChatStrings]);
    const moreButtonStrings = useMemo(() => ({
        label: callWithChatStrings.moreDrawerButtonLabel,
        tooltipContent: callWithChatStrings.moreDrawerButtonTooltip
    }), [callWithChatStrings]);
    const centerContainerStyles = useMemo(() => {
        const styles = !props.mobileView ? desktopControlBarStyles : {};
        return mergeStyleSets(styles, {
            root: {
                // Enforce a background color on control bar to ensure it matches the composite background color.
                background: theme.semanticColors.bodyBackground
            }
        });
    }, [props.mobileView, theme.semanticColors.bodyBackground]);
    const screenShareButtonStyles = useMemo(() => !props.mobileView ? getDesktopScreenShareButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const commonButtonStyles = useMemo(() => !props.mobileView ? getDesktopCommonButtonStyles(theme) : undefined, [props.mobileView, theme]);
    const endCallButtonStyles = useMemo(() => !props.mobileView ? getDesktopEndCallButtonStyles(theme) : undefined, [props.mobileView, theme]);
    // when options is false then we want to hide the whole control bar.
    if (options === false) {
        return React.createElement(React.Fragment, null);
    }
    const chatButton = React.createElement(ChatButtonWithUnreadMessagesBadge, { chatAdapter: props.chatAdapter, checked: props.chatButtonChecked, showLabel: options.displayType !== 'compact', isChatPaneVisible: props.chatButtonChecked, onClick: props.onChatButtonClicked, disabled: props.disableButtonsForLobbyPage || isDisabled(options.chatButton), strings: chatButtonStrings, styles: commonButtonStyles, newMessageLabel: callWithChatStrings.chatButtonNewMessageNotificationLabel });
    return React.createElement(Stack, { horizontal: true, className: mergeStyles(callControlsContainerStyles, controlBarContainerStyles) },
        React.createElement(Stack.Item, { grow: true },
            React.createElement(CallAdapterProvider, { adapter: props.callAdapter },
                React.createElement(Stack, { horizontalAlign: "center" },
                    React.createElement(HiddenFocusStartPoint, null),
                    React.createElement(Stack.Item, null,
                        React.createElement(ControlBar, { layout: "horizontal", styles: centerContainerStyles },
                            isEnabled(options.microphoneButton) && React.createElement(Microphone, { displayType: options.displayType, styles: commonButtonStyles, splitButtonsForDeviceSelection: !props.mobileView }),
                            isEnabled(options.cameraButton) && React.createElement(Camera, { displayType: options.displayType, styles: commonButtonStyles, splitButtonsForDeviceSelection: !props.mobileView }),
                            props.mobileView && isEnabled(options === null || options === void 0 ? void 0 : options.chatButton) && chatButton,
                            isEnabled(options.screenShareButton) && React.createElement(ScreenShare, { option: options.screenShareButton, displayType: options.displayType, styles: screenShareButtonStyles }),
                            props.mobileView && React.createElement(MoreButton, { "data-ui-id": "call-with-chat-composite-more-button", strings: moreButtonStrings, onClick: props.onMoreButtonClicked, disabled: props.disableButtonsForLobbyPage }),
                            React.createElement(EndCall, { displayType: "compact", styles: endCallButtonStyles })))))),
        !props.mobileView && React.createElement(Stack, { horizontal: true, className: !props.mobileView ? mergeStyles(desktopButtonContainerStyle) : undefined },
            isEnabled(options === null || options === void 0 ? void 0 : options.peopleButton) && React.createElement(PeopleButton, { checked: props.peopleButtonChecked, showLabel: options.displayType !== 'compact', onClick: props.onPeopleButtonClicked, "data-ui-id": "call-with-chat-composite-people-button", disabled: props.disableButtonsForLobbyPage || isDisabled(options.peopleButton), strings: peopleButtonStrings, styles: commonButtonStyles }),
            isEnabled(options === null || options === void 0 ? void 0 : options.chatButton) && chatButton));
};
const desktopButtonContainerStyle = {
    padding: '0.75rem',
    columnGap: '0.5rem'
};
const desktopControlBarStyles = {
    root: desktopButtonContainerStyle
};
const getDesktopCommonButtonStyles = (theme) => ({
    root: {
        border: `solid 1px ${theme.palette.neutralQuaternaryAlt}`,
        borderRadius: theme.effects.roundedCorner4,
        minHeight: '2.5rem',
        maxWidth: '12rem' // allot extra space than the regular ControlBarButton. This is to give extra room to have the icon beside the text.
    },
    flexContainer: {
        display: 'flex',
        flexFlow: 'row nowrap'
    },
    textContainer: {
        // Override the default so that label doesn't introduce a new block.
        display: 'inline',
        // Ensure width is set to permit child to show ellipsis when there is a label that is too long
        maxWidth: '100%'
    },
    label: {
        fontSize: theme.fonts.medium.fontSize,
        // Ensure there is enough space between the icon and text to allow for the unread messages badge in the chat button
        marginLeft: '0.625rem',
        // Ensure letters that go above and below the standard text line like 'g', 'y', 'j' are not clipped
        lineHeight: '1.5rem',
        // Do not allow very long button texts to ruin the control bar experience, instead ensure long text is truncated and shows ellipsis
        display: 'block',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
        overflow: 'hidden'
    },
    splitButtonMenuButton: {
        border: `solid 1px ${theme.palette.neutralQuaternaryAlt}`,
        borderTopRightRadius: theme.effects.roundedCorner4,
        borderBottomRightRadius: theme.effects.roundedCorner4,
        borderTopLeftRadius: '0',
        borderBottomLeftRadius: '0'
    },
    splitButtonMenuButtonChecked: {
        // Default colors the menu half similarly for :hover and when button is checked.
        // To align with how the left-half is styled, override the checked style.
        background: 'none'
    }
});
const getDesktopScreenShareButtonStyles = (theme) => {
    const overrideStyles = {
        border: 'none',
        background: theme.palette.themePrimary,
        color: theme.palette.white,
        '* > svg': {
            fill: theme.palette.white
        }
    };
    const overrides = {
        rootChecked: overrideStyles,
        rootCheckedHovered: overrideStyles
    };
    return concatStyleSets(getDesktopCommonButtonStyles(theme), overrides);
};
const getDesktopEndCallButtonStyles = (theme) => {
    const overrides = {
        root: {
            // Suppress border around the dark-red button.
            border: 'none'
        }
    };
    return concatStyleSets(getDesktopCommonButtonStyles(theme), overrides);
};
const isEnabled = (option) => option !== false;
//# sourceMappingURL=CallWithChatControlBar.js.map