// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { _dominantSpeakersWithFlatId, _videoGalleryRemoteParticipantsMemo } from "../../../../../calling-component-bindings/src";
import * as reselect from 'reselect';
import { getDominantSpeakerInfo, getRemoteParticipants } from './baseSelectors';
/**
 * Get the most dominant remote participant, if no dominant speaker IDs exist, this uses
 * one of the remote participants with no bias towards which one.
 *
 * @private
 */
export const dominantRemoteParticipantSelector = reselect.createSelector([getRemoteParticipants, getDominantSpeakerInfo], (remoteParticipants, dominantSpeakerInfo) => {
    const dominantSpeakers = _dominantSpeakersWithFlatId(dominantSpeakerInfo);
    const dominantRemoteParticipant = remoteParticipants && Object.keys(remoteParticipants).length > 0 ? findDominantRemoteParticipant(remoteParticipants, dominantSpeakers !== null && dominantSpeakers !== void 0 ? dominantSpeakers : []) : undefined;
    return dominantRemoteParticipant ? _videoGalleryRemoteParticipantsMemo(updateUserDisplayNamesTrampoline(Object.values(dominantRemoteParticipant)))[0] : undefined;
});
const findDominantRemoteParticipant = (remoteParticipants, dominantSpeakerIds) => {
    let dominantRemoteParticipantId = dominantSpeakerIds[0];
    // Fallback to using the first remote participant if there are no dominant speaker IDs
    // or if the dominant speaker is no longer available in the list of remoteParticipantIds
    const remoteParticipantIds = Object.keys(remoteParticipants);
    if (!dominantRemoteParticipantId || !remoteParticipantIds.includes(dominantRemoteParticipantId)) {
        dominantRemoteParticipantId = remoteParticipantIds[0];
    }
    return {
        dominantRemoteParticipantId: remoteParticipants[dominantRemoteParticipantId]
    };
};
const updateUserDisplayNamesTrampoline = (remoteParticipants) => {
    return remoteParticipants;
};
//# sourceMappingURL=dominantRemoteParticipantSelector.js.map