// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { mergeStyles, Stack } from '@fluentui/react';
import { ErrorBar, MessageThread, SendBox, TypingIndicator, useTheme } from "../../../../react-components/src";
import React, { useCallback, useEffect } from 'react';
import { AvatarPersona } from '../common/AvatarPersona';
import { useAdapter } from './adapter/ChatAdapterProvider';
import { ChatHeader, getHeaderProps } from './ChatHeader';
import { FileUploadButtonWrapper as FileUploadButton } from './file-sharing';
import { useAdaptedSelector } from './hooks/useAdaptedSelector';
import { usePropsFor } from './hooks/usePropsFor';
import { chatArea, chatContainer, chatWrapper, messageThreadChatCompositeStyles, sendboxContainerStyles, typingIndicatorContainerStyles } from './styles/Chat.styles';
import { participantListContainerPadding } from '../common/styles/ParticipantContainer.styles';
import { toFlatCommunicationIdentifier } from "../../../../acs-ui-common/src";
/**
 * @private
 */
export const ChatScreen = (props) => {
    const { onFetchAvatarPersonaData, onRenderMessage, onRenderTypingIndicator, options, styles, fileSharing, formFactor } = props;
    const defaultNumberOfChatMessagesToReload = 5;
    const adapter = useAdapter();
    const theme = useTheme();
    useEffect(() => {
        // Initial data should be always fetched by the composite(or external caller) instead of the adapter
        adapter.fetchInitialData();
    }, [adapter]);
    const messageThreadProps = usePropsFor(MessageThread);
    const sendBoxProps = usePropsFor(SendBox);
    const typingIndicatorProps = usePropsFor(TypingIndicator);
    const headerProps = useAdaptedSelector(getHeaderProps);
    const errorBarProps = usePropsFor(ErrorBar);
    const onRenderAvatarCallback = useCallback((userId, defaultOptions) => {
        return React.createElement(AvatarPersona, Object.assign({ userId: userId, hidePersonaDetails: true }, defaultOptions, { dataProvider: onFetchAvatarPersonaData }));
    }, [onFetchAvatarPersonaData]);
    const messageThreadStyles = Object.assign({}, messageThreadChatCompositeStyles(theme.semanticColors.bodyBackground), styles === null || styles === void 0 ? void 0 : styles.messageThread);
    const typingIndicatorStyles = Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.typingIndicator);
    const sendBoxStyles = Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.sendBox);
    const userId = toFlatCommunicationIdentifier(adapter.getState().userId);
    const fileUploadButtonOnChange = useCallback((files) => {
        if (!files) {
            return;
        }
    }, [adapter, fileSharing, userId]);
    const AttachFileButton = useCallback(() => {
        if (!(fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler)) {
            return null;
        }
        return React.createElement(FileUploadButton, { accept: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, multiple: fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, onChange: fileUploadButtonOnChange });
    }, [fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.accept, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.multiple, fileSharing === null || fileSharing === void 0 ? void 0 : fileSharing.uploadHandler, fileUploadButtonOnChange]);
    return React.createElement(Stack, { className: chatContainer, grow: true },
        (options === null || options === void 0 ? void 0 : options.topic) !== false && React.createElement(ChatHeader, Object.assign({}, headerProps)),
        React.createElement(Stack, { className: chatArea, tokens: participantListContainerPadding, horizontal: true, grow: true },
            React.createElement(Stack, { className: chatWrapper, grow: true },
                (options === null || options === void 0 ? void 0 : options.errorBar) !== false && React.createElement(ErrorBar, Object.assign({}, errorBarProps)),
                React.createElement(MessageThread, Object.assign({}, messageThreadProps, { onRenderAvatar: onRenderAvatarCallback, onRenderMessage: onRenderMessage, numberOfChatMessagesToReload: defaultNumberOfChatMessagesToReload, styles: messageThreadStyles })),
                React.createElement(Stack, { className: mergeStyles(sendboxContainerStyles) },
                    React.createElement("div", { className: mergeStyles(typingIndicatorContainerStyles) }, onRenderTypingIndicator ? onRenderTypingIndicator(typingIndicatorProps.typingUsers) : React.createElement(TypingIndicator, Object.assign({}, typingIndicatorProps, { styles: typingIndicatorStyles }))),
                    React.createElement(Stack, { horizontal: formFactor === 'mobile' },
                        formFactor === 'mobile' && React.createElement(Stack, { verticalAlign: "center" },
                            React.createElement(AttachFileButton, null)),
                        React.createElement(Stack, { grow: true },
                            React.createElement(SendBox, Object.assign({}, sendBoxProps, { autoFocus: options === null || options === void 0 ? void 0 : options.autoFocus, styles: sendBoxStyles }))),
                        formFactor !== 'mobile' && React.createElement(AttachFileButton, null))))));
};
//# sourceMappingURL=ChatScreen.js.map