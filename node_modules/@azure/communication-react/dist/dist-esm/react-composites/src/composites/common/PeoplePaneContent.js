// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Stack } from '@fluentui/react';
import { ParticipantList } from "../../../../react-components/src";
import React, { useMemo } from 'react';
import { usePropsFor } from '../CallComposite/hooks/usePropsFor';
import { ParticipantListWithHeading } from '../common/ParticipantContainer';
import { peoplePaneContainerTokens } from '../common/styles/ParticipantContainer.styles';
import { participantListContainerStyles, peoplePaneContainerStyle } from './styles/PeoplePaneContent.styles';
import { convertContextualMenuItemToDrawerMenuItem } from '../CallWithChatComposite/ConvertContextualMenuItemToDrawerMenuItem';
import { AddPeopleButton } from './AddPeopleButton';
/**
 * @private
 */
export const PeoplePaneContent = (props) => {
    const { inviteLink, onFetchParticipantMenuItems, setDrawerMenuItems, strings, onRemoveParticipant } = props;
    const participantListDefaultProps = usePropsFor(ParticipantList);
    const removeButtonAllowed = hasRemoveParticipantsPermissionTrampoline();
    const setDrawerMenuItemsForParticipant = useMemo(() => {
        return (participant) => {
            if (participant) {
                let contextualMenuItems = createDefaultContextualMenuItems(participant, strings, removeButtonAllowed && participant.isRemovable ? participantListDefaultProps.onRemoveParticipant : undefined, participantListDefaultProps.myUserId);
                if (onFetchParticipantMenuItems) {
                    contextualMenuItems = onFetchParticipantMenuItems(participant.userId, participantListDefaultProps.myUserId, contextualMenuItems);
                }
                const drawerMenuItems = contextualMenuItems.map((contextualMenu) => convertContextualMenuItemToDrawerMenuItem(contextualMenu, () => setDrawerMenuItems([])));
                setDrawerMenuItems(drawerMenuItems);
            }
        };
    }, [strings, participantListDefaultProps.onRemoveParticipant, participantListDefaultProps.myUserId, removeButtonAllowed, onFetchParticipantMenuItems, setDrawerMenuItems]);
    const participantListProps = useMemo(() => {
        const onRemoveAParticipant = (participantId) => __awaiter(void 0, void 0, void 0, function* () { return onRemoveParticipant(participantId); });
        return Object.assign(Object.assign({}, participantListDefaultProps), { 
            // Passing undefined callback for mobile to avoid context menus for participants in ParticipantList are clicked
            onRemoveParticipant: props.mobileView ? undefined : onRemoveAParticipant, 
            // We want the drawer menu items to appear when participants in ParticipantList are clicked
            onParticipantClick: props.mobileView ? setDrawerMenuItemsForParticipant : undefined });
    }, [participantListDefaultProps, props.mobileView, setDrawerMenuItemsForParticipant, onRemoveParticipant]);
    const participantList = React.createElement(ParticipantListWithHeading, { isMobile: props.mobileView, participantListProps: participantListProps, onFetchAvatarPersonaData: props.onFetchAvatarPersonaData, onFetchParticipantMenuItems: props.mobileView ? undefined : props.onFetchParticipantMenuItems, title: props.strings.peoplePaneSubTitle });
    if (props.mobileView) {
        return React.createElement(Stack, { verticalFill: true, styles: peoplePaneContainerStyle, tokens: peoplePaneContainerTokens },
            React.createElement(Stack.Item, { grow: true, styles: participantListContainerStyles }, participantList),
            props.active && React.createElement(AddPeopleButton, { inviteLink: inviteLink, mobileView: props.mobileView, participantList: participantList, strings: strings }));
    }
    return React.createElement(AddPeopleButton, { inviteLink: inviteLink, mobileView: props.mobileView, participantList: participantList, strings: strings });
};
/**
 * Create default contextual menu items for particant
 * @param participant - participant to create contextual menu items for
 * @param strings - localized strings for menu item text
 * @param onRemoveParticipant - callback to remove participant
 * @param localParticipantUserId - Local participant user id
 * @returns - IContextualMenuItem[]
 */
const createDefaultContextualMenuItems = (participant, strings, onRemoveParticipant, localParticipantUserId) => {
    const menuItems = [];
    if (onRemoveParticipant && (participant === null || participant === void 0 ? void 0 : participant.userId) !== localParticipantUserId) {
        menuItems.push({
            key: 'remove',
            text: strings.removeMenuLabel,
            onClick: () => {
                if (participant === null || participant === void 0 ? void 0 : participant.userId) {
                    onRemoveParticipant === null || onRemoveParticipant === void 0 ? void 0 : onRemoveParticipant(participant === null || participant === void 0 ? void 0 : participant.userId);
                }
            },
            iconProps: {
                iconName: 'UserRemove'
            }
        });
    }
    return menuItems;
};
/**
 * @private
 */
const hasRemoveParticipantsPermissionTrampoline = () => {
    // Return true if stable.
    return true;
};
//# sourceMappingURL=PeoplePaneContent.js.map