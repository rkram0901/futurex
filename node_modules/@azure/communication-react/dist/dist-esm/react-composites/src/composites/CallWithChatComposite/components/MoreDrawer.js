// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import React, { useCallback } from 'react';
import { _DrawerMenu as DrawerMenu } from "../../../../../react-components/src";
import { isDisabled } from '../../CallComposite/utils';
const inferCallWithChatControlOptions = (callWithChatControls) => {
    if (callWithChatControls === false) {
        return false;
    }
    const options = callWithChatControls === true || callWithChatControls === undefined ? {} : callWithChatControls;
    return options;
};
/** @private */
export const MoreDrawer = (props) => {
    var _a, _b;
    const drawerMenuItems = [];
    const { speakers, onSelectSpeaker, onLightDismiss } = props;
    const onSpeakerItemClick = useCallback((_ev, itemKey) => {
        const selected = speakers === null || speakers === void 0 ? void 0 : speakers.find(speaker => speaker.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectSpeaker(selected);
        }
        onLightDismiss();
    }, [speakers, onSelectSpeaker, onLightDismiss]);
    const drawerSelectionOptions = inferCallWithChatControlOptions(props.callControls);
    if (props.speakers && props.speakers.length > 0) {
        drawerMenuItems.push({
            itemKey: 'speakers',
            disabled: props.disableButtonsForHoldScreen,
            text: props.strings.speakerMenuTitle,
            iconProps: {
                iconName: 'MoreDrawerSpeakers'
            },
            subMenuProps: props.speakers.map(speaker => ({
                itemKey: speaker.id,
                iconProps: {
                    iconName: isDeviceSelected(speaker, props.selectedSpeaker) ? 'MoreDrawerSelectedSpeaker' : 'MoreDrawerSpeakers'
                },
                text: speaker.name,
                onItemClick: onSpeakerItemClick,
                secondaryIconProps: isDeviceSelected(speaker, props.selectedSpeaker) ? {
                    iconName: 'Accept'
                } : undefined
            })),
            secondaryText: (_a = props.selectedSpeaker) === null || _a === void 0 ? void 0 : _a.name
        });
    }
    const { microphones, onSelectMicrophone } = props;
    const onMicrophoneItemClick = useCallback((_ev, itemKey) => {
        const selected = microphones === null || microphones === void 0 ? void 0 : microphones.find(mic => mic.id === itemKey);
        if (selected) {
            // This is unsafe - we're only passing in part of the argument to the handler.
            // But this is a known issue in our state.
            onSelectMicrophone(selected);
        }
        onLightDismiss();
    }, [microphones, onSelectMicrophone, onLightDismiss]);
    if (props.microphones && props.microphones.length > 0) {
        // Set props as Microphone if speakers can be enumerated else set as Audio Device
        const speakersAvailable = props.speakers && props.speakers.length > 0;
        const itemKey = speakersAvailable ? 'microphones' : 'audioDevices';
        const text = speakersAvailable ? props.strings.microphoneMenuTitle : props.strings.audioDeviceMenuTitle;
        const iconName = speakersAvailable ? 'MoreDrawerMicrophones' : 'MoreDrawerSpeakers';
        const selectedIconName = speakersAvailable ? 'MoreDrawerSelectedMicrophone' : 'MoreDrawerSelectedSpeaker';
        drawerMenuItems.push({
            itemKey: itemKey,
            disabled: props.disableButtonsForHoldScreen,
            text: text,
            iconProps: {
                iconName: iconName
            },
            subMenuProps: props.microphones.map(mic => ({
                itemKey: mic.id,
                iconProps: {
                    iconName: isDeviceSelected(mic, props.selectedMicrophone) ? selectedIconName : iconName
                },
                text: mic.name,
                onItemClick: onMicrophoneItemClick,
                secondaryIconProps: isDeviceSelected(mic, props.selectedMicrophone) ? {
                    iconName: 'Accept'
                } : undefined,
                disabled: drawerSelectionOptions !== false ? isDisabled(drawerSelectionOptions.microphoneButton) : undefined
            })),
            secondaryText: (_b = props.selectedMicrophone) === null || _b === void 0 ? void 0 : _b.name
        });
    }
    if (drawerSelectionOptions !== false && isEnabled(drawerSelectionOptions === null || drawerSelectionOptions === void 0 ? void 0 : drawerSelectionOptions.peopleButton)) {
        drawerMenuItems.push({
            itemKey: 'people',
            text: props.strings.peopleButtonLabel,
            iconProps: {
                iconName: 'MoreDrawerPeople'
            },
            onItemClick: props.onPeopleButtonClicked,
            disabled: drawerSelectionOptions !== false ? isDisabled(drawerSelectionOptions.peopleButton) : undefined
        });
    }
    return React.createElement(DrawerMenu, { items: drawerMenuItems, onLightDismiss: props.onLightDismiss });
};
const isDeviceSelected = (speaker, selectedSpeaker) => !!selectedSpeaker && speaker.id === selectedSpeaker.id;
const isEnabled = (option) => option !== false;
//# sourceMappingURL=MoreDrawer.js.map