import { AudioDeviceInfo, Call, CallAgent, GroupCallLocator, PermissionConstraints, PropertyChangedEvent, TeamsMeetingLinkLocator, StartCallOptions, VideoDeviceInfo } from '@azure/communication-calling';
import { CreateVideoStreamViewResult, VideoStreamOptions } from "../../../../../react-components/src";
import { ParticipantsJoinedListener, ParticipantsLeftListener, IsMutedChangedListener, CallIdChangedListener, IsLocalScreenSharingActiveChangedListener, DisplayNameChangedListener, IsSpeakingChangedListener, CallAdapter, CallEndedListener } from '../../CallComposite';
import { MessageReceivedListener, MessageReadListener, ChatAdapter, ParticipantsRemovedListener, ParticipantsAddedListener } from '../../ChatComposite';
import { CallWithChatAdapter } from './CallWithChatAdapter';
import { CallWithChatAdapterState } from '../state/CallWithChatAdapterState';
import { CommunicationTokenCredential, CommunicationUserIdentifier } from '@azure/communication-common';
import { AdapterError } from '../../common/adapters';
import { CallAdapterLocator } from '../../CallComposite/adapter/AzureCommunicationCallAdapter';
import { StatefulCallClient } from "../../../../../calling-stateful-client/src";
import { StatefulChatClient } from "../../../../../chat-stateful-client/src";
import { ChatThreadClient } from '@azure/communication-chat';
/**
 * CallWithChat adapter backed by Azure Communication Services.
 * Created for easy use with the {@link CallWithChatComposite}.
 */
export declare class AzureCommunicationCallWithChatAdapter implements CallWithChatAdapter {
    private callAdapter;
    private chatAdapter;
    private context;
    private onChatStateChange;
    private onCallStateChange;
    constructor(callAdapter: CallAdapter, chatAdapter: ChatAdapter);
    private bindPublicMethods;
    /** Join existing Call. */
    joinCall(microphoneOn?: boolean): Call | undefined;
    /** Leave current Call. */
    leaveCall(forEveryone?: boolean): Promise<void>;
    /** Start a new Call. */
    startCall(participants: string[], options?: StartCallOptions): Call | undefined;
    /**
     * Subscribe to state change events.
     * @param handler - handler to be called when the state changes. This is passed the new state.
     */
    onStateChange(handler: (state: CallWithChatAdapterState) => void): void;
    /**
     * Unsubscribe to state change events.
     * @param handler - handler to be no longer called when state changes.
     */
    offStateChange(handler: (state: CallWithChatAdapterState) => void): void;
    /** Get current Call and Chat state. */
    getState(): CallWithChatAdapterState;
    /** Dispose of the current CallWithChatAdapter. */
    dispose(): void;
    /** Remove a participant from the Call only. */
    removeParticipant(userId: string): Promise<void>;
    setCamera(device: VideoDeviceInfo, options?: VideoStreamOptions): Promise<void>;
    /** Set the microphone to be used in the Call. */
    setMicrophone(device: AudioDeviceInfo): Promise<void>;
    /** Set the speaker to be used in the Call. */
    setSpeaker(device: AudioDeviceInfo): Promise<void>;
    askDevicePermission(constraints: PermissionConstraints): Promise<void>;
    /** Query for available cameras. */
    queryCameras(): Promise<VideoDeviceInfo[]>;
    /** Query for available microphones. */
    queryMicrophones(): Promise<AudioDeviceInfo[]>;
    /** Query for available speakers. */
    querySpeakers(): Promise<AudioDeviceInfo[]>;
    /** Start the camera for the user in the Call. */
    startCamera(options?: VideoStreamOptions): Promise<void>;
    /** Stop the camera for the user in the Call. */
    stopCamera(): Promise<void>;
    /** Mute the user in the Call. */
    mute(): Promise<void>;
    /** Unmute the user in the Call. */
    unmute(): Promise<void>;
    /** Trigger the user to start screen share. */
    startScreenShare(): Promise<void>;
    /** Stop the current active screen share. */
    stopScreenShare(): Promise<void>;
    /** Create a stream view for a remote participants video feed. */
    createStreamView(remoteUserId?: string, options?: VideoStreamOptions): Promise<void | CreateVideoStreamViewResult>;
    /** Dispose of a created stream view of a remote participants video feed. */
    disposeStreamView(remoteUserId?: string, options?: VideoStreamOptions): Promise<void>;
    /** Fetch initial Call and Chat data such as chat messages. */
    fetchInitialData(): Promise<void>;
    /** Send a chat message. */
    sendMessage(content: string): Promise<void>;
    /** Send a chat read receipt. */
    sendReadReceipt(chatMessageId: string): Promise<void>;
    /** Send an isTyping indicator. */
    sendTypingIndicator(): Promise<void>;
    /** Load previous Chat messages. */
    loadPreviousChatMessages(messagesToLoad: number): Promise<boolean>;
    /** Update an existing message. */
    updateMessage(messageId: string, content: string, metadata?: Record<string, string>): Promise<void>;
    /** Delete an existing message. */
    deleteMessage(messageId: string): Promise<void>;
    on(event: 'callParticipantsJoined', listener: ParticipantsJoinedListener): void;
    on(event: 'callParticipantsLeft', listener: ParticipantsLeftListener): void;
    on(event: 'callEnded', listener: CallEndedListener): void;
    on(event: 'callError', listener: (e: AdapterError) => void): void;
    on(event: 'isMutedChanged', listener: IsMutedChangedListener): void;
    on(event: 'callIdChanged', listener: CallIdChangedListener): void;
    on(event: 'isLocalScreenSharingActiveChanged', listener: IsLocalScreenSharingActiveChangedListener): void;
    on(event: 'displayNameChanged', listener: DisplayNameChangedListener): void;
    on(event: 'isSpeakingChanged', listener: IsSpeakingChangedListener): void;
    on(event: 'messageReceived', listener: MessageReceivedListener): void;
    on(event: 'messageSent', listener: MessageReceivedListener): void;
    on(event: 'messageRead', listener: MessageReadListener): void;
    on(event: 'chatParticipantsAdded', listener: ParticipantsAddedListener): void;
    on(event: 'chatParticipantsRemoved', listener: ParticipantsRemovedListener): void;
    on(event: 'selectedMicrophoneChanged', listener: PropertyChangedEvent): void;
    on(event: 'selectedSpeakerChanged', listener: PropertyChangedEvent): void;
    on(event: 'chatError', listener: (e: AdapterError) => void): void;
    off(event: 'callParticipantsJoined', listener: ParticipantsJoinedListener): void;
    off(event: 'callParticipantsLeft', listener: ParticipantsLeftListener): void;
    off(event: 'callEnded', listener: CallEndedListener): void;
    off(event: 'callError', listener: (e: AdapterError) => void): void;
    off(event: 'isMutedChanged', listener: IsMutedChangedListener): void;
    off(event: 'callIdChanged', listener: CallIdChangedListener): void;
    off(event: 'isLocalScreenSharingActiveChanged', listener: IsLocalScreenSharingActiveChangedListener): void;
    off(event: 'displayNameChanged', listener: DisplayNameChangedListener): void;
    off(event: 'isSpeakingChanged', listener: IsSpeakingChangedListener): void;
    off(event: 'selectedMicrophoneChanged', listener: PropertyChangedEvent): void;
    off(event: 'selectedSpeakerChanged', listener: PropertyChangedEvent): void;
    off(event: 'messageReceived', listener: MessageReceivedListener): void;
    off(event: 'messageSent', listener: MessageReceivedListener): void;
    off(event: 'messageRead', listener: MessageReadListener): void;
    off(event: 'chatParticipantsAdded', listener: ParticipantsAddedListener): void;
    off(event: 'chatParticipantsRemoved', listener: ParticipantsRemovedListener): void;
    off(event: 'chatError', listener: (e: AdapterError) => void): void;
}
/**
 * Arguments for use in {@link createAzureCommunicationCallWithChatAdapter} to join a Call with an associated Chat thread.
 *
 * @public
 */
export interface CallAndChatLocator {
    /** Locator used by {@link createAzureCommunicationCallWithChatAdapter} to locate the call to join */
    callLocator: GroupCallLocator;
    /** Chat thread ID used by {@link createAzureCommunicationCallWithChatAdapter} to locate the chat thread to join */
    chatThreadId: string;
}
/**
 * Arguments for {@link createAzureCommunicationCallWithChatAdapter}
 *
 * @public
 */
export declare type AzureCommunicationCallWithChatAdapterArgs = {
    endpoint: string;
    userId: CommunicationUserIdentifier;
    displayName: string;
    credential: CommunicationTokenCredential;
    locator: CallAndChatLocator | TeamsMeetingLinkLocator;
};
/**
 * Create a CallWithChatAdapter backed by Azure Communication services
 * to plug into the {@link CallWithChatComposite}.
 *
 * @public
 */
export declare const createAzureCommunicationCallWithChatAdapter: ({ userId, displayName, credential, endpoint, locator }: AzureCommunicationCallWithChatAdapterArgs) => Promise<CallWithChatAdapter>;
/**
 * A custom React hook to simplify the creation of {@link CallWithChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallWithChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
export declare const useAzureCommunicationCallWithChatAdapter: (args: Partial<AzureCommunicationCallWithChatAdapterArgs>, afterCreate?: ((adapter: CallWithChatAdapter) => Promise<CallWithChatAdapter>) | undefined, beforeDispose?: ((adapter: CallWithChatAdapter) => Promise<void>) | undefined) => CallWithChatAdapter | undefined;
/**
 * Arguments for {@link createAzureCommunicationCallWithChatAdapterFromClient}
 *
 * @public
 */
export declare type AzureCommunicationCallWithChatAdapterFromClientArgs = {
    callLocator: CallAdapterLocator | TeamsMeetingLinkLocator;
    callAgent: CallAgent;
    callClient: StatefulCallClient;
    chatClient: StatefulChatClient;
    chatThreadClient: ChatThreadClient;
};
/**
 * Create a {@link CallWithChatAdapter} using the provided {@link StatefulChatClient} and {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient} and {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallWithChatAdapter} for a simpler API.
 *
 * @public
 */
export declare const createAzureCommunicationCallWithChatAdapterFromClients: ({ callClient, callAgent, callLocator, chatClient, chatThreadClient }: AzureCommunicationCallWithChatAdapterFromClientArgs) => Promise<CallWithChatAdapter>;
/**
 * Create a {@link CallWithChatAdapter} from the underlying adapters.
 *
 * This is an internal factory function used by browser tests to inject fake adapters for call and chat.
 *
 * @internal
 */
export declare const _createAzureCommunicationCallWithChatAdapterFromAdapters: (callAdapter: CallAdapter, chatAdapter: ChatAdapter) => CallWithChatAdapter;
//# sourceMappingURL=AzureCommunicationCallWithChatAdapter.d.ts.map