// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createAzureCommunicationCallAdapter } from '../../CallComposite';
import { callWithChatAdapterStateFromBackingStates, mergeCallAdapterStateIntoCallWithChatAdapterState, mergeChatAdapterStateIntoCallWithChatAdapterState } from '../state/CallWithChatAdapterState';
import { createAzureCommunicationChatAdapter, createAzureCommunicationChatAdapterFromClient } from '../../ChatComposite/adapter/AzureCommunicationChatAdapter';
import { EventEmitter } from 'events';
import { getChatThreadFromTeamsLink } from './parseTeamsUrl';
import { createAzureCommunicationCallAdapterFromClient } from '../../CallComposite/adapter/AzureCommunicationCallAdapter';
import { useEffect, useRef, useState } from 'react';
/** Context of Call with Chat, which is a centralized context for all state updates */
class CallWithChatContext {
    constructor(clientState, maxListeners = 50) {
        this.emitter = new EventEmitter();
        this.state = clientState;
        this.emitter.setMaxListeners(maxListeners);
    }
    onStateChange(handler) {
        this.emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this.emitter.off('stateChanged', handler);
    }
    setState(state) {
        this.state = state;
        this.emitter.emit('stateChanged', this.state);
    }
    getState() {
        return this.state;
    }
    updateClientState(clientState) {
        this.setState(clientState);
    }
    updateClientStateWithChatState(chatAdapterState) {
        this.updateClientState(mergeChatAdapterStateIntoCallWithChatAdapterState(this.state, chatAdapterState));
    }
    updateClientStateWithCallState(callAdapterState) {
        this.updateClientState(mergeCallAdapterStateIntoCallWithChatAdapterState(this.state, callAdapterState));
    }
}
/**
 * CallWithChat adapter backed by Azure Communication Services.
 * Created for easy use with the {@link CallWithChatComposite}.
 */
export class AzureCommunicationCallWithChatAdapter {
    constructor(callAdapter, chatAdapter) {
        this.bindPublicMethods();
        this.callAdapter = callAdapter;
        this.chatAdapter = chatAdapter;
        this.context = new CallWithChatContext(callWithChatAdapterStateFromBackingStates(callAdapter, chatAdapter));
        const onChatStateChange = (newChatAdapterState) => {
            this.context.updateClientStateWithChatState(newChatAdapterState);
        };
        this.chatAdapter.onStateChange(onChatStateChange);
        this.onChatStateChange = onChatStateChange;
        const onCallStateChange = (newCallAdapterState) => {
            this.context.updateClientStateWithCallState(newCallAdapterState);
        };
        this.callAdapter.onStateChange(onCallStateChange);
        this.onCallStateChange = onCallStateChange;
    }
    bindPublicMethods() {
        this.joinCall.bind(this);
        this.leaveCall.bind(this);
        this.startCall.bind(this);
        this.onStateChange.bind(this);
        this.offStateChange.bind(this);
        this.getState.bind(this);
        this.dispose.bind(this);
        this.setCamera.bind(this);
        this.setMicrophone.bind(this);
        this.setSpeaker.bind(this);
        this.askDevicePermission.bind(this);
        this.queryCameras.bind(this);
        this.queryMicrophones.bind(this);
        this.querySpeakers.bind(this);
        this.startCamera.bind(this);
        this.stopCamera.bind(this);
        this.mute.bind(this);
        this.unmute.bind(this);
        this.startScreenShare.bind(this);
        this.stopScreenShare.bind(this);
        this.removeParticipant.bind(this);
        this.createStreamView.bind(this);
        this.disposeStreamView.bind(this);
        this.fetchInitialData.bind(this);
        this.sendMessage.bind(this);
        this.sendReadReceipt.bind(this);
        this.sendTypingIndicator.bind(this);
        this.loadPreviousChatMessages.bind(this);
        this.updateMessage.bind(this);
        this.deleteMessage.bind(this);
        this.on.bind(this);
        this.off.bind(this);
    }
    /** Join existing Call. */
    joinCall(microphoneOn) {
        return this.callAdapter.joinCall(microphoneOn);
    }
    /** Leave current Call. */
    leaveCall(forEveryone) {
        return __awaiter(this, void 0, void 0, function* () {
            // Only remove self from the GroupCall. Contoso must manage access to Chat.
            yield this.callAdapter.leaveCall(forEveryone);
        });
    }
    /** Start a new Call. */
    startCall(participants, options) {
        let communicationParticipants = participants;
        return this.callAdapter.startCall(communicationParticipants, options);
    }
    /**
     * Subscribe to state change events.
     * @param handler - handler to be called when the state changes. This is passed the new state.
     */
    onStateChange(handler) {
        this.context.onStateChange(handler);
    }
    /**
     * Unsubscribe to state change events.
     * @param handler - handler to be no longer called when state changes.
     */
    offStateChange(handler) {
        this.context.offStateChange(handler);
    }
    /** Get current Call and Chat state. */
    getState() {
        return this.context.getState();
    }
    /** Dispose of the current CallWithChatAdapter. */
    dispose() {
        this.chatAdapter.offStateChange(this.onChatStateChange);
        this.callAdapter.offStateChange(this.onCallStateChange);
        this.chatAdapter.dispose();
        this.callAdapter.dispose();
    }
    /** Remove a participant from the Call only. */
    removeParticipant(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            let participant = userId;
            yield this.callAdapter.removeParticipant(participant);
        });
    }
    setCamera(device, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setCamera(device, options);
        });
    }
    /** Set the microphone to be used in the Call. */
    setMicrophone(device) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setMicrophone(device);
        });
    }
    /** Set the speaker to be used in the Call. */
    setSpeaker(device) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.setSpeaker(device);
        });
    }
    askDevicePermission(constraints) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.askDevicePermission(constraints);
        });
    }
    /** Query for available cameras. */
    queryCameras() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.queryCameras();
        });
    }
    /** Query for available microphones. */
    queryMicrophones() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.queryMicrophones();
        });
    }
    /** Query for available speakers. */
    querySpeakers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.querySpeakers();
        });
    }
    /** Start the camera for the user in the Call. */
    startCamera(options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.startCamera(options);
        });
    }
    /** Stop the camera for the user in the Call. */
    stopCamera() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.stopCamera();
        });
    }
    /** Mute the user in the Call. */
    mute() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.mute();
        });
    }
    /** Unmute the user in the Call. */
    unmute() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.unmute();
        });
    }
    /** Trigger the user to start screen share. */
    startScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.startScreenShare();
        });
    }
    /** Stop the current active screen share. */
    stopScreenShare() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.stopScreenShare();
        });
    }
    /** Create a stream view for a remote participants video feed. */
    createStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.callAdapter.createStreamView(remoteUserId, options);
        });
    }
    /** Dispose of a created stream view of a remote participants video feed. */
    disposeStreamView(remoteUserId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.callAdapter.disposeStreamView(remoteUserId, options);
        });
    }
    /** Fetch initial Call and Chat data such as chat messages. */
    fetchInitialData() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.fetchInitialData();
        });
    }
    /** Send a chat message. */
    sendMessage(content) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendMessage(content);
        });
    }
    /** Send a chat read receipt. */
    sendReadReceipt(chatMessageId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendReadReceipt(chatMessageId);
        });
    }
    /** Send an isTyping indicator. */
    sendTypingIndicator() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.chatAdapter.sendTypingIndicator();
        });
    }
    /** Load previous Chat messages. */
    loadPreviousChatMessages(messagesToLoad) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.loadPreviousChatMessages(messagesToLoad);
        });
    }
    /** Update an existing message. */
    updateMessage(messageId, content, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.updateMessage(messageId, content, metadata);
        });
    }
    /** Delete an existing message. */
    deleteMessage(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.chatAdapter.deleteMessage(messageId);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        switch (event) {
            case 'callParticipantsJoined':
                this.callAdapter.on('participantsJoined', listener);
                break;
            case 'callParticipantsLeft':
                this.callAdapter.on('participantsLeft', listener);
                break;
            case 'callEnded':
                this.callAdapter.on('callEnded', listener);
                break;
            case 'isMutedChanged':
                this.callAdapter.on('isMutedChanged', listener);
                break;
            case 'callIdChanged':
                this.callAdapter.on('callIdChanged', listener);
                break;
            case 'isLocalScreenSharingActiveChanged':
                this.callAdapter.on('isLocalScreenSharingActiveChanged', listener);
                break;
            case 'displayNameChanged':
                this.callAdapter.on('displayNameChanged', listener);
                break;
            case 'isSpeakingChanged':
                this.callAdapter.on('isSpeakingChanged', listener);
                break;
            case 'selectedMicrophoneChanged':
                this.callAdapter.on('selectedMicrophoneChanged', listener);
                break;
            case 'selectedSpeakerChanged':
                this.callAdapter.on('selectedSpeakerChanged', listener);
                break;
            case 'messageReceived':
                this.chatAdapter.on('messageReceived', listener);
                break;
            case 'messageSent':
                this.chatAdapter.on('messageSent', listener);
                break;
            case 'messageRead':
                this.chatAdapter.on('messageRead', listener);
                break;
            case 'chatParticipantsAdded':
                this.chatAdapter.on('participantsAdded', listener);
                break;
            case 'chatParticipantsRemoved':
                this.chatAdapter.on('participantsRemoved', listener);
                break;
            case 'callError':
                this.callAdapter.on('error', listener);
                break;
            case 'chatError':
                this.chatAdapter.on('error', listener);
                break;
            default:
                throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    off(event, listener) {
        switch (event) {
            case 'callParticipantsJoined':
                this.callAdapter.off('participantsJoined', listener);
                break;
            case 'callParticipantsLeft':
                this.callAdapter.off('participantsLeft', listener);
                break;
            case 'callEnded':
                this.callAdapter.off('callEnded', listener);
                break;
            case 'isMutedChanged':
                this.callAdapter.off('isMutedChanged', listener);
                break;
            case 'callIdChanged':
                this.callAdapter.off('callIdChanged', listener);
                break;
            case 'isLocalScreenSharingActiveChanged':
                this.callAdapter.off('isLocalScreenSharingActiveChanged', listener);
                break;
            case 'displayNameChanged':
                this.callAdapter.off('displayNameChanged', listener);
                break;
            case 'isSpeakingChanged':
                this.callAdapter.off('isSpeakingChanged', listener);
                break;
            case 'selectedMicrophoneChanged':
                this.callAdapter.off('selectedMicrophoneChanged', listener);
                break;
            case 'selectedSpeakerChanged':
                this.callAdapter.off('selectedSpeakerChanged', listener);
                break;
            case 'messageReceived':
                this.chatAdapter.off('messageReceived', listener);
                break;
            case 'messageSent':
                this.chatAdapter.off('messageSent', listener);
                break;
            case 'messageRead':
                this.chatAdapter.off('messageRead', listener);
                break;
            case 'chatParticipantsAdded':
                this.chatAdapter.off('participantsAdded', listener);
                break;
            case 'chatParticipantsRemoved':
                this.chatAdapter.off('participantsRemoved', listener);
                break;
            case 'callError':
                this.callAdapter.off('error', listener);
                break;
            case 'chatError':
                this.chatAdapter.off('error', listener);
                break;
            default:
                throw `Unknown AzureCommunicationCallWithChatAdapter Event: ${event}`;
        }
    }
}
/**
 * Create a CallWithChatAdapter backed by Azure Communication services
 * to plug into the {@link CallWithChatComposite}.
 *
 * @public
 */
export const createAzureCommunicationCallWithChatAdapter = ({ userId, displayName, credential, endpoint, locator }) => __awaiter(void 0, void 0, void 0, function* () {
    const callAdapterLocator = isTeamsMeetingLinkLocator(locator) ? locator : locator.callLocator;
    const createCallAdapterPromise = createAzureCommunicationCallAdapter({
        userId,
        displayName,
        credential,
        locator: callAdapterLocator
    });
    const threadId = isTeamsMeetingLinkLocator(locator) ? getChatThreadFromTeamsLink(locator.meetingLink) : locator.chatThreadId;
    const createChatAdapterPromise = createAzureCommunicationChatAdapter({
        endpoint,
        userId,
        displayName,
        credential,
        threadId
    });
    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);
    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
});
/**
 * A custom React hook to simplify the creation of {@link CallWithChatAdapter}.
 *
 * Similar to {@link createAzureCommunicationCallWithChatAdapter}, but takes care of asynchronous
 * creation of the adapter internally.
 *
 * Allows arguments to be undefined so that you can respect the rule-of-hooks and pass in arguments
 * as they are created. The adapter is only created when all arguments are defined.
 *
 * Note that you must memoize the arguments to avoid recreating adapter on each render.
 * See storybook for typical usage examples.
 *
 * @public
 */
export const useAzureCommunicationCallWithChatAdapter = (args, afterCreate, beforeDispose) => {
    const { credential, displayName, endpoint, locator, userId } = args;
    // State update needed to rerender the parent component when a new adapter is created.
    const [adapter, setAdapter] = useState(undefined);
    // Ref needed for cleanup to access the old adapter created asynchronously.
    const adapterRef = useRef(undefined);
    const afterCreateRef = useRef(undefined);
    const beforeDisposeRef = useRef(undefined);
    // These refs are updated on *each* render, so that the latest values
    // are used in the `useEffect` closures below.
    // Using a Ref ensures that new values for the callbacks do not trigger the
    // useEffect blocks, and a new adapter creation / distruction is not triggered.
    afterCreateRef.current = afterCreate;
    beforeDisposeRef.current = beforeDispose;
    useEffect(() => {
        if (!credential || !displayName || !endpoint || !locator || !userId) {
            return;
        }
        (() => __awaiter(void 0, void 0, void 0, function* () {
            if (adapterRef.current) {
                // Dispose the old adapter when a new one is created.
                //
                // This clean up function uses `adapterRef` because `adapter` can not be added to the dependency array of
                // this `useEffect` -- we do not want to trigger a new adapter creation because of the first adapter
                // creation.
                if (beforeDisposeRef.current) {
                    yield beforeDisposeRef.current(adapterRef.current);
                }
                adapterRef.current.dispose();
                adapterRef.current = undefined;
            }
            let newAdapter = yield createAzureCommunicationCallWithChatAdapter({
                credential,
                displayName,
                endpoint,
                locator,
                userId
            });
            if (afterCreateRef.current) {
                newAdapter = yield afterCreateRef.current(newAdapter);
            }
            adapterRef.current = newAdapter;
            setAdapter(newAdapter);
        }))();
    }, 
    // Explicitly list all arguments so that caller doesn't have to memoize the `args` object.
    [adapterRef, afterCreateRef, beforeDisposeRef, credential, displayName, endpoint, locator, userId]);
    // Dispose any existing adapter when the component unmounts.
    useEffect(() => {
        return () => {
            (() => __awaiter(void 0, void 0, void 0, function* () {
                if (adapterRef.current) {
                    if (beforeDisposeRef.current) {
                        yield beforeDisposeRef.current(adapterRef.current);
                    }
                    adapterRef.current.dispose();
                    adapterRef.current = undefined;
                }
            }))();
        };
    }, []);
    return adapter;
};
/**
 * Create a {@link CallWithChatAdapter} using the provided {@link StatefulChatClient} and {@link StatefulCallClient}.
 *
 * Useful if you want to keep a reference to {@link StatefulChatClient} and {@link StatefulCallClient}.
 * Consider using {@link createAzureCommunicationCallWithChatAdapter} for a simpler API.
 *
 * @public
 */
export const createAzureCommunicationCallWithChatAdapterFromClients = ({ callClient, callAgent, callLocator, chatClient, chatThreadClient }) => __awaiter(void 0, void 0, void 0, function* () {
    const createCallAdapterPromise = createAzureCommunicationCallAdapterFromClient(callClient, callAgent, callLocator);
    const createChatAdapterPromise = createAzureCommunicationChatAdapterFromClient(chatClient, chatThreadClient);
    const [callAdapter, chatAdapter] = yield Promise.all([createCallAdapterPromise, createChatAdapterPromise]);
    return new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
});
/**
 * Create a {@link CallWithChatAdapter} from the underlying adapters.
 *
 * This is an internal factory function used by browser tests to inject fake adapters for call and chat.
 *
 * @internal
 */
export const _createAzureCommunicationCallWithChatAdapterFromAdapters = (callAdapter, chatAdapter) => new AzureCommunicationCallWithChatAdapter(callAdapter, chatAdapter);
const isTeamsMeetingLinkLocator = (locator) => {
    return 'meetingLink' in locator;
};
//# sourceMappingURL=AzureCommunicationCallWithChatAdapter.js.map