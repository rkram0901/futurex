{"version":3,"file":"memoizeFnAll.js","sourceRoot":"","sources":["../../../../preprocess-dist/acs-ui-common/src/memoizeFnAll.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAelC,MAAM,OAAO,GAAG,CAAC,KAAgB,EAAE,KAAgB,EAAE,MAAiD,EAAW,EAAE;IACjH,OAAO,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AACnG,CAAC,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCG;AACH,MAAM,CAAC,MAAM,YAAY,GAAG,CAA6F,WAAiD,EAAE,oBAAiE,MAAM,CAAC,EAAE,EAAuC,EAAE;IAC7R,IAAI,KAAK,GAAG,IAAI,GAAG,EAAyB,CAAC;IAC7C,IAAI,SAAS,GAAG,IAAI,GAAG,EAAyB,CAAC;IACjD,OAAO,CAAC,QAA2C,EAAY,EAAE;QAC/D,MAAM,UAAU,GAAyC,CAAC,GAAS,EAAE,GAAG,IAAW,EAAU,EAAE;YAC7F,MAAM,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAC7B,IAAI,KAAK,EAAE;gBACT,MAAM,CAAC,OAAO,EAAE,GAAG,CAAC,GAAG,KAAK,CAAC;gBAC7B,IAAI,OAAO,CAAC,OAAO,EAAE,IAAI,EAAE,iBAAiB,CAAC,EAAE;oBAC7C,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;oBAChC,OAAO,GAAG,CAAC;iBACZ;aACF;YACD,MAAM,GAAG,GAAG,WAAW,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;YACtC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;YAChC,OAAO,GAAG,CAAC;QACb,CAAC,CAAC;QACF,MAAM,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC;QACtC,KAAK,GAAG,SAAS,CAAC;QAClB,SAAS,GAAG,IAAI,GAAG,EAAyB,CAAC;QAC7C,OAAO,QAAQ,CAAC;IAClB,CAAC,CAAC;AACJ,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * A function type where the first argument is a key used to memoize results.\n *\n * @public\n */\nexport type FunctionWithKey<KeyT, ArgsT extends unknown[], RetT> = (key: KeyT, ...args: ArgsT) => RetT;\n\n/**\n * A function type that is called with the result of a memoized functions return value.\n *\n * @public\n */\nexport type CallbackType<KeyT, ArgsT extends unknown[], FnRetT> = (memoizedFn: FunctionWithKey<KeyT, ArgsT, FnRetT>) => FnRetT[];\nconst argsCmp = (args1: unknown[], args2: unknown[], objCmp: (obj1: unknown, obj2: unknown) => boolean): boolean => {\n  return args1.length === args2.length && args1.every((arg1, index) => objCmp(args2[index], arg1));\n};\n\n/**\n * The function memoize a series of function calls in a single pass,\n * it memoizes all the args and return in a single run of the callback function, and read it in the next round of execution\n * note: this is a memory opimized function which will only memoize one round of bulk calls\n * @param  fnToMemoize - the function needs to be bulk memorized and a key key paramter needs to be provided as cache id\n * @param  shouldCacheUpdate - the validate function for comparing 2 argument, return true when 2 args are equal\n * @returns callback function includes a series calls of memoizedFn, and each call will get cache result if args are the same(according to shouldCacheUpdate fn)\n * @example\n * ```ts\n * const items = [{id:1, value:3}];\n * const heavyFn = (_key, value) => { // key is not used in the function, but it is a cache id\n *   // assume this is a heavy caculation\n *   return value+1;\n * }\n *\n * const memoizeHeavyFnAll = memoizeFnAll(heavyFn);\n * const generateValueArray = (memoizedHeavyFn) => (\n *   items.map(item => {\n *     memoizedHeavyFn(item.id, item.value);\n *   })\n * );\n *\n * const result = memoizeHeavyFnAll(generateValueArray); // Cache: {}, nextCache: {1: 4 *new}, heavyFn call times: 1\n *\n * // Argument changed\n * items[0].value = 2\n * const result0 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 4}, nextCache: {1: 3 *new}, heavyFn call times: 1\n *\n * // Cache added\n * items.push({id:3, value:4});\n * const result1 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3 *hit}, nextCache: {1: 3, 3: 5 *new}, heavyFn call times: 1\n *\n * // Cache removed\n * delete items[0];\n * const result2 = memoizeHeavyFnAll(generateValueArray); // Cache: {1: 3, 3: 5 *hit}, nextCache: {3: 5}, heavyFn call times: 0\n * ```\n *\n * @public\n */\nexport const memoizeFnAll = <KeyT, ArgsT extends unknown[], FnRetT, CallBackT extends CallbackType<KeyT, ArgsT, FnRetT>>(fnToMemoize: FunctionWithKey<KeyT, ArgsT, FnRetT>, shouldCacheUpdate: (args1: unknown, args2: unknown) => boolean = Object.is): ((callback: CallBackT) => FnRetT[]) => {\n  let cache = new Map<KeyT, [ArgsT, FnRetT]>();\n  let nextCache = new Map<KeyT, [ArgsT, FnRetT]>();\n  return (callback: CallbackType<KeyT, ArgsT, FnRetT>): FnRetT[] => {\n    const memoizedFn: FunctionWithKey<KeyT, ArgsT, FnRetT> = (key: KeyT, ...args: ArgsT): FnRetT => {\n      const value = cache.get(key);\n      if (value) {\n        const [preArgs, ret] = value;\n        if (argsCmp(preArgs, args, shouldCacheUpdate)) {\n          nextCache.set(key, [args, ret]);\n          return ret;\n        }\n      }\n      const ret = fnToMemoize(key, ...args);\n      nextCache.set(key, [args, ret]);\n      return ret;\n    };\n    const retValue = callback(memoizedFn);\n    cache = nextCache;\n    nextCache = new Map<KeyT, [ArgsT, FnRetT]>();\n    return retValue;\n  };\n};"]}