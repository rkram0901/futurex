{"version":3,"file":"TypingIndicator.js","sourceRoot":"","sources":["../../../../../preprocess-dist/react-components/src/components/TypingIndicator.tsx"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { typingIndicatorContainerStyle, typingIndicatorStringStyle } from './styles/TypingIndicator.styles';\nimport React from 'react';\nimport { BaseCustomStyles, CommunicationParticipant } from '../types';\nimport { IStyle, mergeStyles, Stack, Text } from '@fluentui/react';\nimport { useLocale } from '../localization/LocalizationProvider';\nimport { useIdentifiers } from '../identifiers';\nimport { _IObjectMap } from '@internal/acs-ui-common';\n\n/**\n * Fluent styles for {@link TypingIndicator}.\n *\n * @public\n */\nexport interface TypingIndicatorStylesProps extends BaseCustomStyles {\n  /** Styles for each typing user's displayName. */\n  typingUserDisplayName?: IStyle;\n  /** Styles for the typing string. */\n  typingString?: IStyle;\n}\n\n/**\n * Strings of {@link TypingIndicator} that can be overridden.\n *\n * @public\n */\nexport interface TypingIndicatorStrings {\n  /**\n   * String template to use when one user is typing. Placeholders: [user].\n   * @example\n   * ```\n   * <TypingIndicator\n   *  strings={{ multipleUsersAbbreviateOne: '{users} is typing...' }}\n   *  typingUsers={[{ userId: 'user1', displayName: 'Claire' }]}\n   * />\n   * ```\n   * would be 'Claire is typing...'\n   **/\n  singleUser: string;\n  /**\n   * String template to use when multiple users are typing. Placeholders: [users].\n   * @example\n   * ```\n   * <TypingIndicator\n   *  strings={{ multipleUsers: '{users} are typing...' }}\n   *  typingUsers={[\n   *    { userId: 'user1', displayName: 'Claire' },\n   *    { userId: 'user2', displayName: 'Christopher' }\n   *  ]}\n   * />\n   * ```\n   * would be 'Claire, Chris are typing...'\n   **/\n  multipleUsers: string;\n  /**\n   * String template to use when multiple users are typing with one other user abbreviated. Placeholders: [users].\n   * @example\n   * ```typescript\n   * <TypingIndicator\n   * strings={{ multipleUsersAbbreviateOne: '{users} and 1 other are typing...' }}\n   * typingUsers={[\n   * { userId: 'user1', displayName: 'Claire Romanov' },\n   * { userId: 'user2', displayName: 'Christopher Rutherford' }\n   * ]}\n   * />\n   * ```\n   * would be 'Claire Romanov and 1 other are typing...'\n   **/\n  multipleUsersAbbreviateOne: string;\n  /**\n   * String template to use when multiple users are typing with one other user abbreviated. Placeholders: [users, numOthers].\n   * @example\n   * ```\n   * <TypingIndicator\n   *  strings={{ multipleUsersAbbreviateMany: '{users} and {numOthers} others are typing...' }}\n   *  typingUsers={[\n   *    { userId: 'user1', displayName: 'Claire Romanov' },\n   *    { userId: 'user2', displayName: 'Christopher Rutherford' },\n   *    { userId: 'user3', displayName: 'Jill Vernblom' }\n   *  ]}\n   * />\n   * ```\n   * would be 'Claire Romanov and 2 others are typing...'\n   **/\n  multipleUsersAbbreviateMany: string;\n  /**\n   * String to use as delimiter to separate multiple users.\n   * @example\n   * ```\n   * <TypingIndicator\n   *  strings={{ delimiter: ' + ' }}\n   *  typingUsers={[\n   *    { userId: 'user1', displayName: 'Claire' },\n   *    { userId: 'user2', displayName: 'Chris' },\n   *    { userId: 'user3', displayName: 'Jill' }\n   *  ]}\n   * />\n   * ```\n   * would be 'Claire + Chris + Jill are typing...'\n   **/\n  delimiter: string;\n}\n\n/**\n * Props for {@link TypingIndicator}.\n *\n * @public\n */\nexport interface TypingIndicatorProps {\n  /** List of the typing users. */\n  typingUsers: CommunicationParticipant[];\n  /** Callback to render typing users */\n  onRenderUser?: (users: CommunicationParticipant) => JSX.Element;\n  /**\n   * Allows users to pass in an object contains custom CSS styles.\n   * @Example\n   * ```\n   * <TypingIndicator styles={{ root: { background: 'blue' } }} />\n   * ```\n   */\n  styles?: TypingIndicatorStylesProps;\n\n  /**\n   * Optional strings to override in component\n   */\n  strings?: Partial<TypingIndicatorStrings>;\n}\nconst MAXIMUM_LENGTH_OF_TYPING_USERS = 35;\n\n/**\n * Helper function to create element wrapping all typing users\n * @param typingUsers typing users\n * @param delimiter string to separate typing users\n * @param onRenderUser optional callback to render each typing user\n * @param userDisplayNameStyles optional additional IStyle to apply to each element containing users name\n * @returns element wrapping all typing users\n */\nconst getUsersElement = (typingUsers: CommunicationParticipant[], delimiter: string, onRenderUser?: (users: CommunicationParticipant) => JSX.Element, userDisplayNameStyles?: IStyle): JSX.Element => {\n  const userElements: JSX.Element[] = [];\n  typingUsers.forEach((user, index) => {\n    userElements.push(onRenderUser ? onRenderUser(user) : <Text className={mergeStyles(userDisplayNameStyles)} key={`user-${index}`}>\n          {user.displayName}\n        </Text>);\n    userElements.push(<Text key={`comma-${index}`}>{`${delimiter}`}</Text>);\n  });\n  // pop last comma\n  userElements.pop();\n  return <>{userElements}</>;\n};\n\n/**\n * Helper function to get a string of all typing users\n * @param typingUsers typing users\n * @param delimiter string to separate typing users\n * @returns string of all typing users\n */\nconst getNamesString = (typingUsers: CommunicationParticipant[], delimiter: string): string => {\n  const userNames: string[] = [];\n  typingUsers.forEach(user => {\n    if (user.displayName) {\n      userNames.push(user.displayName);\n    }\n  });\n  return userNames.join(delimiter);\n};\n\n/**\n * Helper function to create span elements making up the typing indicator string\n * @param strings TypingIndicatorStrings containing strings to create span elements\n * @param usersElement JSX.Element containing all typing users\n * @param numTypingUsers number of total typing users\n * @param numUserNotMentioned number of typing users abbreviated\n * @returns array of span elements making up the typing indicator string\n */\nconst getSpanElements = (strings: TypingIndicatorStrings, usersElement: JSX.Element, numTypingUsers: number, numTypingUsersAbbreviated: number): JSX.Element[] => {\n  let variables: Record<string, JSX.Element> = {};\n  let typingString = '';\n  if (numTypingUsers === 1) {\n    typingString = strings.singleUser;\n    variables = {\n      user: usersElement\n    };\n  } else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {\n    typingString = strings.multipleUsers;\n    variables = {\n      users: usersElement\n    };\n  } else if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {\n    typingString = strings.multipleUsersAbbreviateOne;\n    variables = {\n      users: usersElement\n    };\n  } else if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {\n    typingString = strings.multipleUsersAbbreviateMany;\n    variables = {\n      users: usersElement,\n      numOthers: <>{numTypingUsersAbbreviated}</>\n    };\n  }\n  return formatInlineElements(typingString, variables);\n};\n\n/**\n * Helper function to get the string making up the typing indicator string\n * @param strings TypingIndicatorStrings containing strings to create span elements\n * @param namesString string of all typing users\n * @param numTypingUsers number of total typing users\n * @param numUserNotMentioned number of typing users abbreviated\n * @returns typing indicator string\n */\nconst getIndicatorString = (strings: TypingIndicatorStrings, namesString: string, numTypingUsers: number, numTypingUsersAbbreviated: number): string | undefined => {\n  if (numTypingUsers === 1) {\n    return strings.singleUser.replace('{user}', namesString);\n  }\n  if (numTypingUsers > 1 && numTypingUsersAbbreviated === 0) {\n    return strings.multipleUsers.replace('{users}', namesString);\n  }\n  if (numTypingUsers > 1 && numTypingUsersAbbreviated === 1) {\n    return strings.multipleUsersAbbreviateOne.replace('{users}', namesString);\n  }\n  if (numTypingUsers > 1 && numTypingUsersAbbreviated > 1) {\n    return strings.multipleUsersAbbreviateMany.replace('{users}', namesString).replace('{numOthers}', `${numTypingUsersAbbreviated}`);\n  }\n  return undefined;\n};\nconst IndicatorComponent = (typingUsers: CommunicationParticipant[], strings: TypingIndicatorStrings, onRenderUser?: (users: CommunicationParticipant) => JSX.Element, styles?: TypingIndicatorStylesProps): JSX.Element => {\n  const typingUsersMentioned: CommunicationParticipant[] = [];\n  let totalCharacterCount = 0;\n  const ids = useIdentifiers();\n  for (const typingUser of typingUsers) {\n    if (!typingUser.displayName) {\n      continue;\n    }\n    let additionalCharCount = typingUser.displayName.length;\n    // The typing users will be separated by the delimiter. We account for that additional length when we generate the final string.\n    if (typingUsersMentioned.length > 0) {\n      additionalCharCount += strings.delimiter.length;\n    }\n    if (totalCharacterCount + additionalCharCount <= MAXIMUM_LENGTH_OF_TYPING_USERS || typingUsersMentioned.length === 0) {\n      typingUsersMentioned.push(typingUser);\n      totalCharacterCount += additionalCharCount;\n    } else {\n      break;\n    }\n  }\n  const usersElement: JSX.Element = getUsersElement(typingUsersMentioned, strings.delimiter, onRenderUser, styles?.typingUserDisplayName);\n  const numUserNotMentioned = typingUsers.length - typingUsersMentioned.length;\n  const spanElements: JSX.Element[] = getSpanElements(strings, usersElement, typingUsers.length, numUserNotMentioned);\n  const labelString = getIndicatorString(strings, getNamesString(typingUsersMentioned, strings.delimiter), typingUsers.length, numUserNotMentioned);\n  return <div data-ui-id={ids.typingIndicator} className={mergeStyles(typingIndicatorStringStyle, styles?.typingString)} key=\"typingStringKey\" role=\"status\" aria-label={labelString}>\n      {spanElements}\n    </div>;\n};\n\n/**\n * Component to notify local user when one or more participants in the chat thread are typing.\n *\n * @public\n */\nexport const TypingIndicator = (props: TypingIndicatorProps): JSX.Element => {\n  const {\n    typingUsers,\n    onRenderUser,\n    styles\n  } = props;\n  const {\n    strings\n  } = useLocale();\n  const typingUsersToRender = typingUsers.filter(typingUser => typingUser.displayName !== undefined);\n  const indicatorComponent = IndicatorComponent(typingUsersToRender, {\n    ...strings.typingIndicator,\n    ...props.strings\n  }, onRenderUser, styles);\n  return <Stack className={mergeStyles(typingIndicatorContainerStyle, styles?.root)}>{indicatorComponent}</Stack>;\n};\n\n/**\n * Create an array of span elements by replacing the pattern \"\\{\\}\" in str with the elements\n * passed in as vars and creating inline elements from the rest\n *\n * @param str - The string to be formatted\n * @param vars - Variables to use to format the string\n * @returns formatted JSX elements\n */\nconst formatInlineElements = (str: string, vars: _IObjectMap<JSX.Element>): JSX.Element[] => {\n  if (!str) {\n    return [];\n  }\n  if (!vars) {\n    return [];\n  }\n  const elements: JSX.Element[] = [];\n\n  // regex to search for the pattern \"{}\"\n  const placeholdersRegex = /{(\\w+)}/g;\n  const regex = RegExp(placeholdersRegex);\n  let array: RegExpExecArray | null = regex.exec(str);\n  let prev = 0;\n  while (array !== null) {\n    if (prev !== array.index) {\n      elements.push(<Text key={elements.length}>{str.substring(prev, array.index)}</Text>);\n    }\n    elements.push(<Text key={elements.length}>{vars[array[0].substring(1, array[0].length - 1)]}</Text>);\n    prev = regex.lastIndex;\n    array = regex.exec(str);\n  }\n  elements.push(<Text key={elements.length}>{str.substring(prev)}</Text>);\n  return elements;\n};\"../../../acs-ui-common/src\""]}