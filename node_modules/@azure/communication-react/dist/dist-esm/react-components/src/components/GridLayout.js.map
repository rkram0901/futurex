{"version":3,"file":"GridLayout.js","sourceRoot":"","sources":["../../../../../preprocess-dist/react-components/src/components/GridLayout.tsx"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { IStyle, mergeStyles } from '@fluentui/react';\nimport React, { useRef, useEffect, useState, useMemo } from 'react';\nimport { BaseCustomStyles } from '../types';\nimport { gridLayoutStyle } from './styles/GridLayout.styles';\n\n/**\n * Props for {@link GridLayout}.\n *\n * @public\n */\nexport interface GridLayoutProps {\n  children: React.ReactNode;\n  /**\n   * Allows users to pass in an object contains custom CSS styles.\n   * @Example\n   * ```\n   * <GridLayout styles={{ root: { background: 'blue' } }} />\n   * ```\n   */\n  styles?: BaseCustomStyles;\n}\n\n/**\n * {@link GridLayout} Component Styles.\n * @public\n */\nexport interface GridLayoutStyles extends BaseCustomStyles {\n  /** Styles for each child of {@link GridLayout} */\n  children?: IStyle;\n}\n\n/**\n * A component to lay out audio / video participants tiles in a call.\n *\n * @public\n */\nexport const GridLayout = (props: GridLayoutProps): JSX.Element => {\n  const {\n    children,\n    styles\n  } = props;\n  const numberOfChildren = React.Children.count(children);\n  const [currentWidth, setCurrentWidth] = useState(0);\n  const [currentHeight, setCurrentHeight] = useState(0);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const observer = useRef(new ResizeObserver((entries): void => {\n    const {\n      width,\n      height\n    } = entries[0].contentRect;\n    setCurrentWidth(width);\n    setCurrentHeight(height);\n  }));\n  useEffect(() => {\n    if (containerRef.current) {\n      observer.current.observe(containerRef.current);\n    }\n    const currentObserver = observer.current;\n    return () => currentObserver.disconnect();\n  }, [observer, containerRef]);\n  const gridProps = useMemo(() => {\n    return calculateGridProps(numberOfChildren, currentWidth, currentHeight);\n  }, [numberOfChildren, currentWidth, currentHeight]);\n  const cssGridStyles = useMemo(() => createGridStyles(numberOfChildren, gridProps), [numberOfChildren, gridProps]);\n  return <div ref={containerRef} className={mergeStyles(gridLayoutStyle, cssGridStyles, styles?.root)}>\n      {children}\n    </div>;\n};\n\n/**\n * The cell aspect ratio we aim for in a grid\n */\nconst TARGET_CELL_ASPECT_RATIO = 16 / 9;\n/**\n * The minimum cell aspect ratio we allow\n */\nconst MINIMUM_CELL_ASPECT_RATIO_ALLOWED = 8 / 9;\nconst isCloserThan = (a: number, b: number, target: number): boolean => {\n  return Math.abs(target - a) < Math.abs(target - b);\n};\n\n/**\n * Properties to describe a grid. The number of rows, number of columns and whether it fills horizontally or vertically.\n *\n * @Example\n * ```\n *  ______________________\n * |_______|_______|______|\n * |___________|__________| This grid has 2 rows, 3 columns and fills horizontally.\n *  ______________\n * |    |    |    |\n * |____|____|    |\n * |    |    |    |\n * |____|____|____| This grid has 2 rows, 3 columns and fills vertically.\n *  _______________\n * |       |       |\n * |_______|_______|\n * |       |       | If all cells are equal, we default the fill direction as horizontal.\n * |_______|_______| This grid has 2 rows, 2 columns and fills horizontally.\n * ```\n */\ntype GridProps = {\n  fillDirection: FillDirection;\n  rows: number;\n  columns: number;\n};\ntype FillDirection = 'horizontal' | 'vertical';\n\n/**\n * Get the best GridProps to place a number of items in a grid as evenly as possible given the width and height of the grid\n * @param numberOfItems - number of items to place in grid\n * @param width - width of grid\n * @param height - height of grid\n * @returns GridProps\n */\nexport const calculateGridProps = (numberOfItems: number, width: number, height: number): GridProps => {\n  if (numberOfItems <= 0) {\n    return {\n      fillDirection: 'horizontal',\n      rows: 0,\n      columns: 0\n    };\n  }\n  // If width or height are 0 then we return rows and column evenly\n  if (width <= 0 || height <= 0) {\n    return {\n      fillDirection: 'horizontal',\n      rows: Math.ceil(Math.sqrt(numberOfItems)),\n      columns: Math.ceil(Math.sqrt(numberOfItems))\n    };\n  }\n  const aspectRatio = width / height;\n  // Approximate how many rows to divide the grid to achieve cells close to the TARGET_CELL_ASPECT_RATIO\n  let rows = Math.floor(Math.sqrt(TARGET_CELL_ASPECT_RATIO / aspectRatio * numberOfItems)) || 1;\n  // Make sure rows do not exceed numberOfItems\n  rows = Math.min(rows, numberOfItems);\n  // Given the rows, get the minimum columns needed to create enough cells for the number of items\n  let columns = Math.ceil(numberOfItems / rows);\n\n  // Default fill direction to horizontal\n  let fillDirection: 'horizontal' | 'vertical' = 'horizontal';\n  while (rows < numberOfItems) {\n    // If cell aspect ratio is less than MINIMUM_CELL_ASPECT_RATIO_ALLOWED then try more rows\n    if (rows / columns * aspectRatio < MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {\n      rows += 1;\n      columns = Math.ceil(numberOfItems / rows);\n      continue;\n    }\n    if (numberOfItems < rows * columns) {\n      // We need to check that stretching columns vertically will result in only one less cell in stretched columns.\n      // Likewise, we need to check that stretching rows horizonally will result in only one less cell in stretched rows.\n      // e.g. For 4 rows, 2 columns, but only 6 items, we cannot stretch vertically because that would result in a\n      // column of 2 cells which is less by more than 1 compared to the unstretched column.\n      //  _________\n      // |____|    |\n      // |____|____|\n      // |____|    |\n      // |____|____|\n\n      const canStretchVertically = numberOfItems >= rows + (columns - 1) * (rows - 1);\n      const canStretchHorizontally = numberOfItems >= columns + (rows - 1) * (columns - 1);\n      if (!canStretchVertically && !canStretchHorizontally) {\n        rows += 1;\n        columns = Math.ceil(numberOfItems / rows);\n        continue;\n      } else if (!canStretchVertically) {\n        break;\n      } else if (!canStretchHorizontally) {\n        fillDirection = 'vertical';\n        break;\n      }\n\n      // We need to figure out whether the big cells should stretch horizontally or vertically\n      // to fill in the empty spaces\n      // e.g. For 2 rows, 3 columns, but only 5 items, we need to choose whether to stretch cells\n      //       horizontally            or           vertically\n      //  ______________________               _______________________\n      // |       |       |      |             |       |       |       |\n      // |_______|_______|______|             |_______|_______|       |\n      // |           |          |             |       |       |       |\n      // |___________|__________|             |_______|_______|_______|\n\n      // Calculate the aspect ratio of big cells stretched horizontally\n      const horizontallyStretchedCellRatio = rows / (columns - 1) * aspectRatio;\n      // Calculate the aspect ratio of big cells stretched vertically\n      const verticallyStretchedCellRatio = (rows - 1) / columns * aspectRatio;\n      // We know the horizontally stretched cells aspect ratio is higher than MINIMUM_CELL_ASPECT_RATIO_ALLOWED. If vertically stretched cells\n      // is also higher than the MINIMUM_CELL_ASPECT_RATIO_ALLOWED, then choose which aspect ratio is better.\n      if (verticallyStretchedCellRatio >= MINIMUM_CELL_ASPECT_RATIO_ALLOWED) {\n        // If vertically stetched cell has an aspect ratio closer to TARGET_CELL_ASPECT_RATIO then change the fill direction to vertical\n        if (isCloserThan(verticallyStretchedCellRatio, horizontallyStretchedCellRatio, TARGET_CELL_ASPECT_RATIO)) {\n          fillDirection = 'vertical';\n        }\n      }\n    }\n    break;\n  }\n  return {\n    fillDirection,\n    rows,\n    columns\n  };\n};\n\n/**\n * Creates a styles classname with CSS Grid related styles given GridProps and the number of items to distribute as evenly as possible.\n * @param numberOfItems - number of items to place in grid\n * @param gridProps - GridProps that define the number of rows, number of columns, and the fill direction\n * @returns - classname\n */\nexport const createGridStyles = (numberOfItems: number, gridProps: GridProps): string => {\n  const isHorizontal = gridProps.fillDirection === 'horizontal';\n  // Blocks are either rows or columns depending on whether we fill horizontally or vertically. Each block may differ in the number of cells.\n  const blocks = isHorizontal ? gridProps.rows : gridProps.columns;\n  const smallCellsPerBlock = Math.ceil(numberOfItems / blocks);\n  const bigCellsPerBlock = Math.floor(numberOfItems / blocks);\n  const numBigCells = (gridProps.rows * gridProps.columns - numberOfItems) * bigCellsPerBlock;\n  // Get grid units\n  // e.g. If some blocks have 2 big cells while others have 3 small cells, we need to work with 6 units per block\n  const units = smallCellsPerBlock * bigCellsPerBlock;\n  const gridStyles = isHorizontal ? {\n    gridTemplateColumns: `repeat(${units}, minmax(0, 1fr))`,\n    gridTemplateRows: `repeat(${blocks}, minmax(0, 1fr))`,\n    gridAutoFlow: 'row'\n  } : {\n    gridTemplateColumns: `repeat(${blocks}, minmax(0, 1fr))`,\n    gridTemplateRows: `repeat(${units}, minmax(0, 1fr))`,\n    gridAutoFlow: 'column'\n  };\n  const smallCellStyle = isHorizontal ? {\n    '> *': {\n      gridColumn: `auto / span ${units / smallCellsPerBlock}`\n    }\n  } : {\n    '> *': {\n      gridRow: `auto / span ${units / smallCellsPerBlock}`\n    }\n  };\n\n  // If there are big cells, we are choosing to place the latest children into the big cells.\n  // That is why we use the '> *:nth-last-child(-n + ${numBigCells})' CSS selector below\n  const bigCellStyle = numBigCells ? {\n    [`> *:nth-last-child(-n + ${numBigCells})`]: isHorizontal ? {\n      gridColumn: `auto / span ${units / bigCellsPerBlock}`\n    } : {\n      gridRow: `auto / span ${units / bigCellsPerBlock}`\n    }\n  } : {};\n  return mergeStyles(gridStyles, smallCellStyle, bigCellStyle);\n};"]}