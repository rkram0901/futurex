// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import React, { useState, useMemo, useCallback } from 'react';
import { mergeStyles, concatStyleSets, Icon, Stack } from '@fluentui/react';
import { sendBoxStyle, sendButtonStyle, sendIconStyle, sendBoxWrapperStyles, borderAndBoxShadowStyle } from './styles/SendBox.styles';
import { useTheme } from '../theming';
import { useLocale } from '../localization';
import { useIdentifiers } from '../identifiers';
import { InputBoxComponent } from './InputBoxComponent';
import { VoiceOverButton } from './VoiceOverButton';
import { SendBoxErrors } from './SendBoxErrors';
const EMPTY_MESSAGE_REGEX = /^\s*$/;
const MAXIMUM_LENGTH_OF_MESSAGE = 8000;
/**
 * Component for typing and sending messages.
 *
 * Supports sending typing notification when user starts entering text.
 * Supports an optional message below the text input field.
 *
 * @public
 */
export const SendBox = (props) => {
    const { disabled, systemMessage, supportNewline, onSendMessage, onTyping, onRenderIcon, onRenderSystemMessage, styles, autoFocus } = props;
    const theme = useTheme();
    const localeStrings = useLocale().strings.sendBox;
    const strings = Object.assign(Object.assign({}, localeStrings), props.strings);
    const ids = useIdentifiers();
    const activeFileUploads = activeFileUploadsTrampoline(props);
    const [textValue, setTextValue] = useState('');
    const [textValueOverflow, setTextValueOverflow] = useState(false);
    const sendTextFieldRef = React.useRef(null);
    const [fileUploadsPendingError, setFileUploadsPendingError] = useState(undefined);
    const sendMessageOnClick = () => {
        var _a;
        // don't send a message when disabled
        if (disabled || textValueOverflow) {
            return;
        }
        // Don't send message until all files have been uploaded successfully
        setFileUploadsPendingError(undefined);
        if (hasIncompleteFileUploads(props)) {
            return;
        }
        // we dont want to send empty messages including spaces, newlines, tabs
        // Message can be empty if there is a valid file upload
        if (!EMPTY_MESSAGE_REGEX.test(textValue) || hasFile(props)) {
            onSendMessage && onSendMessage(sanitizeText(textValue));
            setTextValue('');
        }
        (_a = sendTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    const setText = (event, newValue) => {
        if (newValue === undefined) {
            return;
        }
        if (newValue.length > MAXIMUM_LENGTH_OF_MESSAGE) {
            setTextValueOverflow(true);
        }
        else {
            setTextValueOverflow(false);
        }
        setTextValue(newValue);
    };
    const textTooLongMessage = textValueOverflow ? strings.textTooLong : undefined;
    const errorMessage = systemMessage !== null && systemMessage !== void 0 ? systemMessage : textTooLongMessage;
    const mergedSendButtonStyle = useMemo(() => mergeStyles(sendButtonStyle, styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer), [styles === null || styles === void 0 ? void 0 : styles.sendMessageIconContainer]);
    const mergedStyles = useMemo(() => concatStyleSets(styles), [styles]);
    const hasText = !!textValue;
    const hasTextOrFile = hasText || hasFile(props);
    const mergedSendIconStyle = useMemo(() => mergeStyles(sendIconStyle, {
        color: !!errorMessage || !hasTextOrFile ? theme.palette.neutralTertiary : theme.palette.themePrimary
    }, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon), [errorMessage, hasTextOrFile, theme, styles === null || styles === void 0 ? void 0 : styles.sendMessageIcon]);
    const onRenderSendIcon = useCallback((isHover) => onRenderIcon ? onRenderIcon(isHover) : React.createElement(Icon, { iconName: isHover && textValue ? 'SendBoxSendHovered' : 'SendBoxSend', className: mergedSendIconStyle }), [mergedSendIconStyle, onRenderIcon, textValue]);
    // Ensure that errors are cleared when there are no files in sendbox
    React.useEffect(() => {
        if (!(activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.filter(upload => !upload.error).length)) {
            setFileUploadsPendingError(undefined);
        }
    }, [activeFileUploads]);
    const sendBoxErrorsProps = useMemo(() => {
        var _a;
        return {
            fileUploadsPendingError: fileUploadsPendingError,
            fileUploadError: (_a = activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.filter(fileUpload => fileUpload.error).pop()) === null || _a === void 0 ? void 0 : _a.error
        };
    }, [activeFileUploads, fileUploadsPendingError]);
    return React.createElement(Stack, { className: mergeStyles(sendBoxWrapperStyles) },
        React.createElement(SendBoxErrors, Object.assign({}, sendBoxErrorsProps)),
        React.createElement(Stack, { className: mergeStyles(borderAndBoxShadowStyle({
                theme,
                hasErrorMessage: !!errorMessage,
                disabled: !!disabled
            })) },
            React.createElement(InputBoxComponent, { autoFocus: autoFocus, "data-ui-id": ids.sendboxTextField, inlineChildren: true, disabled: disabled, errorMessage: onRenderSystemMessage ? onRenderSystemMessage(errorMessage) : errorMessage, textFieldRef: sendTextFieldRef, id: "sendbox", inputClassName: sendBoxStyle, placeholderText: strings.placeholderText, textValue: textValue, onChange: setText, onKeyDown: () => {
                    onTyping && onTyping();
                }, onEnterKeyDown: () => {
                    sendMessageOnClick();
                }, styles: mergedStyles, supportNewline: supportNewline, maxLength: MAXIMUM_LENGTH_OF_MESSAGE },
                React.createElement(VoiceOverButton, { onRenderIcon: onRenderSendIcon, onClick: e => {
                        if (!textValueOverflow) {
                            sendMessageOnClick();
                        }
                        e.stopPropagation();
                    }, id: 'sendIconWrapper', className: mergedSendButtonStyle, ariaLabel: localeStrings.sendButtonAriaLabel, tooltipContent: localeStrings.sendButtonAriaLabel }))));
};
/**
 * @private
 */
const hasIncompleteFileUploads = (props) => {
    const activeFileUploads = activeFileUploadsTrampoline(props);
    return !!((activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.length) && !activeFileUploads.filter(fileUpload => !fileUpload.error).every(fileUpload => fileUpload.uploadComplete));
};
const hasFile = (props) => {
    const activeFileUploads = activeFileUploadsTrampoline(props);
    return !!(activeFileUploads === null || activeFileUploads === void 0 ? void 0 : activeFileUploads.find(file => !file.error));
    return false;
};
const sanitizeText = (message) => {
    if (EMPTY_MESSAGE_REGEX.test(message)) {
        return '';
    }
    else {
        return message;
    }
};
const activeFileUploadsTrampoline = (props) => {
    return [];
};
//# sourceMappingURL=SendBox.js.map