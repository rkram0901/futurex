// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { concatStyleSets, Icon, mergeStyles, Stack } from '@fluentui/react';
import { _formatString } from "../../../../acs-ui-common/src";
import { useTheme } from '../../theming/FluentThemeProvider';
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { editBoxStyle, inputBoxIcon, editingButtonStyle, editBoxStyleSet } from '../styles/EditBox.styles';
import { InputBoxButton, InputBoxComponent } from '../InputBoxComponent';
import { borderAndBoxShadowStyle } from '../styles/SendBox.styles';
import { _FileUploadCards } from '../FileUploadCards';
const MAXIMUM_LENGTH_OF_MESSAGE = 8000;
const onRenderCancelIcon = (color) => {
    const className = mergeStyles(inputBoxIcon, {
        color
    });
    return React.createElement(Icon, { iconName: 'EditBoxCancel', className: className });
};
const onRenderSubmitIcon = (color) => {
    const className = mergeStyles(inputBoxIcon, {
        color
    });
    return React.createElement(Icon, { iconName: 'EditBoxSubmit', className: className });
};
/**
 * @private
 */
export const ChatMessageComponentAsEditBox = (props) => {
    const { onCancel, onSubmit, strings, message } = props;
    const [textValue, setTextValue] = useState(message.content || '');
    const [attachedFilesMetadata, setAttachedFilesMetadata] = React.useState(getMessageAttachedFilesMetadata(message));
    const editTextFieldRef = React.useRef(null);
    const theme = useTheme();
    const messageState = getMessageState(textValue, attachedFilesMetadata !== null && attachedFilesMetadata !== void 0 ? attachedFilesMetadata : []);
    const submitEnabled = messageState === 'OK';
    useEffect(() => {
        var _a;
        (_a = editTextFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, []);
    const setText = (event, newValue) => {
        setTextValue(newValue !== null && newValue !== void 0 ? newValue : '');
    };
    const textTooLongMessage = messageState === 'too long' ? _formatString(strings.editBoxTextLimit, {
        limitNumber: `${MAXIMUM_LENGTH_OF_MESSAGE}`
    }) : undefined;
    const onRenderThemedCancelIcon = useCallback(() => onRenderCancelIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const onRenderThemedSubmitIcon = useCallback(() => onRenderSubmitIcon(theme.palette.neutralSecondary), [theme.palette.neutralSecondary]);
    const editBoxStyles = useMemo(() => {
        return concatStyleSets(editBoxStyleSet, {
            textField: {
                borderColor: theme.palette.themePrimary
            }
        });
    }, [theme.palette.themePrimary]);
    const onRenderFileUploads = useCallback(() => {
        return (attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.length) && React.createElement("div", { style: {
                margin: '0.25rem'
            } },
            React.createElement(_FileUploadCards, { activeFileUploads: attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.map(file => ({
                    id: file.name,
                    filename: file.name,
                    progress: 1
                })), onCancelFileUpload: fileId => {
                    setAttachedFilesMetadata(attachedFilesMetadata === null || attachedFilesMetadata === void 0 ? void 0 : attachedFilesMetadata.filter(file => file.name !== fileId));
                } }));
    }, [attachedFilesMetadata]);
    return React.createElement(Stack, { className: mergeStyles(borderAndBoxShadowStyle({
            theme,
            hasErrorMessage: false,
            disabled: false
        })) },
        React.createElement(InputBoxComponent, { inlineChildren: props.inlineEditButtons, id: 'editbox', textFieldRef: editTextFieldRef, inputClassName: editBoxStyle(props.inlineEditButtons), placeholderText: strings.editBoxPlaceholderText, textValue: textValue, onChange: setText, onEnterKeyDown: () => {
                submitEnabled && onSubmit(textValue, message.metadata, {
                    attachedFilesMetadata
                });
            }, supportNewline: false, maxLength: MAXIMUM_LENGTH_OF_MESSAGE, errorMessage: textTooLongMessage, styles: editBoxStyles },
            React.createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxCancelButton, tooltipContent: strings.editBoxCancelButton, onRenderIcon: onRenderThemedCancelIcon, onClick: () => {
                    onCancel && onCancel();
                }, id: 'dismissIconWrapper' }),
            React.createElement(InputBoxButton, { className: editingButtonStyle, ariaLabel: strings.editBoxSubmitButton, tooltipContent: strings.editBoxSubmitButton, onRenderIcon: onRenderThemedSubmitIcon, onClick: e => {
                    submitEnabled && onSubmit(textValue, message.metadata, {
                        attachedFilesMetadata
                    });
                    e.stopPropagation();
                }, id: 'submitIconWrapper' })),
        onRenderFileUploads());
};
const isMessageTooLong = (messageText) => messageText.length > MAXIMUM_LENGTH_OF_MESSAGE;
const isMessageEmpty = (messageText, attachedFilesMetadata) => messageText.trim().length === 0 && attachedFilesMetadata.length === 0;
const getMessageState = (messageText, attachedFilesMetadata) => isMessageEmpty(messageText, attachedFilesMetadata) ? 'too short' : isMessageTooLong(messageText) ? 'too long' : 'OK';
// @TODO: Remove when file-sharing feature becomes stable.
const getMessageAttachedFilesMetadata = (message) => {
    return [];
};
//# sourceMappingURL=ChatMessageComponentAsEditBox.js.map