// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { useCallback, useRef } from 'react';
import { smartDominantSpeakerParticipants } from '../../../gallery';
const DEFAULT_MAX_REMOTE_VIDEOSTREAMS = 4;
const DEFAULT_MAX_AUDIO_DOMINANT_SPEAKERS = 6;
/**
 * @private
 */
export const useFloatingLocalVideoLayout = (props) => {
    var _a, _b;
    const visibleVideoParticipants = useRef([]);
    const visibleAudioParticipants = useRef([]);
    const { remoteParticipants, dominantSpeakers, maxRemoteVideoStreams = DEFAULT_MAX_REMOTE_VIDEOSTREAMS, maxAudioDominantSpeakers = DEFAULT_MAX_AUDIO_DOMINANT_SPEAKERS, isScreenShareActive = false } = props;
    visibleVideoParticipants.current = smartDominantSpeakerParticipants({
        participants: (_a = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter(p => { var _a; return (_a = p.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable; })) !== null && _a !== void 0 ? _a : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleVideoParticipants.current,
        maxDominantSpeakers: maxRemoteVideoStreams
    }).slice(0, maxRemoteVideoStreams);
    const visibleVideoParticipantsSet = new Set(visibleVideoParticipants.current.map(p => p.userId));
    visibleAudioParticipants.current = smartDominantSpeakerParticipants({
        participants: (_b = remoteParticipants === null || remoteParticipants === void 0 ? void 0 : remoteParticipants.filter(p => !visibleVideoParticipantsSet.has(p.userId))) !== null && _b !== void 0 ? _b : [],
        dominantSpeakers,
        lastVisibleParticipants: visibleAudioParticipants.current,
        maxDominantSpeakers: maxAudioDominantSpeakers
    });
    const getGridParticipants = useCallback(() => {
        if (isScreenShareActive) {
            return [];
        }
        return visibleVideoParticipants.current.length > 0 ? visibleVideoParticipants.current : visibleAudioParticipants.current;
    }, [isScreenShareActive]);
    const gridParticipants = getGridParticipants();
    const getHorizontalGalleryRemoteParticipants = useCallback(() => {
        if (isScreenShareActive) {
            // If screen sharing is active, assign video and audio participants as horizontal gallery participants
            return visibleVideoParticipants.current.concat(visibleAudioParticipants.current);
        }
        else {
            // If screen sharing is not active, then assign all video tiles as grid tiles.
            // If there are no video tiles, then assign audio tiles as grid tiles.
            return visibleVideoParticipants.current.length > 0 ? visibleAudioParticipants.current : [];
        }
    }, [isScreenShareActive]);
    const horizontalGalleryParticipants = getHorizontalGalleryRemoteParticipants();
    return {
        gridParticipants,
        horizontalGalleryParticipants
    };
};
/**
 * @private
 */
export const usePinnedParticipantLayout = (props) => {
    // map remote participants by userId
    const remoteParticipantMap = props.remoteParticipants.reduce((map, remoteParticipant) => {
        map[remoteParticipant.userId] = remoteParticipant;
        return map;
    }, {});
    // count pinned participants with video
    let pinnedParticipantsWithVideoOnCount = 0;
    // get pinned participants in the same order of pinned participant user ids using remoteParticipantMap
    const pinnedParticipants = [];
    props.pinnedParticipantUserIds.forEach(id => {
        var _a;
        const pinnedParticipant = remoteParticipantMap[id];
        if (pinnedParticipant) {
            pinnedParticipants.push(pinnedParticipant);
            if ((_a = pinnedParticipant.videoStream) === null || _a === void 0 ? void 0 : _a.isAvailable) {
                pinnedParticipantsWithVideoOnCount++;
            }
        }
    });
    // get unpinned participants by filtering all remote participants using a set of pinned participant user ids
    const pinnedParticipantUserIdSet = new Set(props.pinnedParticipantUserIds);
    const unpinnedParticipants = props.remoteParticipants.filter(p => !pinnedParticipantUserIdSet.has(p.userId));
    const floatingLocalVideoLayoutProps = Object.assign(Object.assign({}, props), { 
        // if there are pinned participants then we should only consider unpinned participants
        remoteParticipants: unpinnedParticipants, 
        // if there is a maximum of remote video streams we need to subtract pinned participants with video
        maxRemoteVideoStreams: props.maxRemoteVideoStreams ? props.maxRemoteVideoStreams - pinnedParticipantsWithVideoOnCount : undefined });
    const floatingLocalVideoLayout = useFloatingLocalVideoLayout(floatingLocalVideoLayoutProps);
    if (props.pinnedParticipantUserIds.length === 0) {
        return floatingLocalVideoLayout;
    }
    return {
        gridParticipants: props.isScreenShareActive ? [] : pinnedParticipants,
        horizontalGalleryParticipants: props.isScreenShareActive ? pinnedParticipants.concat(floatingLocalVideoLayout.horizontalGalleryParticipants) : floatingLocalVideoLayout.gridParticipants.concat(floatingLocalVideoLayout.horizontalGalleryParticipants)
    };
};
//# sourceMappingURL=videoGalleryLayoutUtils.js.map