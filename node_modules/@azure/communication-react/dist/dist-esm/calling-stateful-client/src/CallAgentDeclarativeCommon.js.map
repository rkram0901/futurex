{"version":3,"file":"CallAgentDeclarativeCommon.js","sourceRoot":"","sources":["../../../../preprocess-dist/calling-stateful-client/src/CallAgentDeclarativeCommon.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Call, CallAgent, CallEndReason, CollectionUpdatedEvent } from '@azure/communication-calling';\nimport { IncomingCallCommon, CallAgentCommon, CallCommon } from './BetaToStableTypes';\nimport { CallContext } from './CallContext';\nimport { DeclarativeCall } from './CallDeclarative';\nimport { CallSubscriber } from './CallSubscriber';\nimport { convertSdkCallToDeclarativeCall, convertSdkIncomingCallToDeclarativeIncomingCall } from './Converter';\nimport { DeclarativeIncomingCall, incomingCallDeclaratify } from './IncomingCallDeclarative';\nimport { IncomingCallSubscriber } from './IncomingCallSubscriber';\nimport { InternalCallContext } from './InternalCallContext';\nimport { disposeAllViews, disposeAllViewsFromCall } from './StreamUtils';\n\n/**\n *\n * @private\n */\nexport type DeclarativeCallCommon = CallCommon & {\n  /**\n   * Stop any declarative specific subscriptions and remove declarative subscribers.\n   */\n  unsubscribe(): void;\n};\n\n/**\n * ProxyCallAgent proxies CallAgent and saves any returned state in the given context. It will subscribe to all state\n * updates in the CallAgent and in the contained Calls and RemoteParticipants. When dispose is called it will\n * unsubscribe from all state updates.\n */\nexport abstract class ProxyCallAgentCommon {\n  private _context: CallContext;\n  private _internalContext: InternalCallContext;\n  private _callSubscribers: Map<CallCommon, CallSubscriber>;\n  private _incomingCallSubscribers: Map<string, IncomingCallSubscriber>;\n  private _declarativeIncomingCalls: Map<string, DeclarativeIncomingCall>;\n  private _declarativeCalls: Map<CallCommon, DeclarativeCallCommon>;\n  private _externalCallsUpdatedListeners: Set<CollectionUpdatedEvent<CallCommon>>;\n  constructor(context: CallContext, internalContext: InternalCallContext) {\n    this._context = context;\n    this._internalContext = internalContext;\n    this._callSubscribers = new Map<Call, CallSubscriber>();\n    this._incomingCallSubscribers = new Map<string, IncomingCallSubscriber>();\n    this._declarativeIncomingCalls = new Map<string, DeclarativeIncomingCall>();\n    this._declarativeCalls = new Map<Call, DeclarativeCall>();\n    this._externalCallsUpdatedListeners = new Set<CollectionUpdatedEvent<CallCommon>>();\n  }\n\n  // Unsubscribe is called when CallAgent is disposed. This should mean no more updating of existing call but we don't\n  // remove any existing state.\n  protected unregisterSubscriber = (): void => {\n    for (const [_, callSubscriber] of this._callSubscribers.entries()) {\n      callSubscriber.unsubscribe();\n    }\n    this._callSubscribers.clear();\n    for (const [_, incomingCallSubscriber] of this._incomingCallSubscribers.entries()) {\n      incomingCallSubscriber.unsubscribe();\n    }\n    this._incomingCallSubscribers.clear();\n    this._declarativeIncomingCalls.clear();\n    for (const [_, declarativeCall] of this._declarativeCalls.entries()) {\n      declarativeCall.unsubscribe();\n    }\n    this._declarativeCalls.clear();\n  };\n  protected abstract unsubscribe(): void;\n  protected abstract callDeclaratify(call: CallCommon, context: CallContext): DeclarativeCallCommon;\n  protected callsUpdated = (event: {\n    added: CallCommon[];\n    removed: CallCommon[];\n  }): void => {\n    const addedStatefulCall: DeclarativeCallCommon[] = [];\n    for (const call of event.added) {\n      const statefulCall = this.addCall(call);\n      addedStatefulCall.push(statefulCall);\n    }\n    const removedStatefulCall: DeclarativeCallCommon[] = [];\n    for (const call of event.removed) {\n      disposeAllViewsFromCall(this._context, this._internalContext, call.id);\n      const callSubscriber = this._callSubscribers.get(call);\n      if (callSubscriber) {\n        callSubscriber.unsubscribe();\n        this._callSubscribers.delete(call);\n      }\n      this._context.setCallEnded(call.id, call.callEndReason);\n      const declarativeCall = this._declarativeCalls.get(call);\n      if (declarativeCall) {\n        declarativeCall.unsubscribe();\n        removedStatefulCall.push(declarativeCall);\n        this._declarativeCalls.delete(call);\n      } else {\n        removedStatefulCall.push(this.callDeclaratify(call, this._context));\n      }\n    }\n    for (const externalCallsUpdatedListener of this._externalCallsUpdatedListeners) {\n      externalCallsUpdatedListener({\n        added: addedStatefulCall,\n        removed: removedStatefulCall\n      });\n    }\n  };\n  private setIncomingCallEnded = (incomingCallId: string, callEndReason: CallEndReason): void => {\n    const incomingCallSubscriber = this._incomingCallSubscribers.get(incomingCallId);\n    if (incomingCallSubscriber) {\n      incomingCallSubscriber.unsubscribe();\n      this._incomingCallSubscribers.delete(incomingCallId);\n    }\n    this._declarativeIncomingCalls.delete(incomingCallId);\n    this._context.setIncomingCallEnded(incomingCallId, callEndReason);\n  };\n  protected incomingCall = ({\n    incomingCall\n  }: {\n    incomingCall: IncomingCallCommon;\n  }): void => {\n    // Make sure to not subscribe to the incoming call if we are already subscribed to it.\n    if (!this._incomingCallSubscribers.has(incomingCall.id)) {\n      this._incomingCallSubscribers.set(incomingCall.id, new IncomingCallSubscriber(incomingCall, this.setIncomingCallEnded));\n    }\n    this._declarativeIncomingCalls.set(incomingCall.id, incomingCallDeclaratify(incomingCall, this._context));\n    this._context.setIncomingCall(convertSdkIncomingCallToDeclarativeIncomingCall(incomingCall));\n  };\n  protected addCall = (call: CallCommon): DeclarativeCallCommon => {\n    this._callSubscribers.get(call)?.unsubscribe();\n\n    // For API extentions we need to have the call in the state when we are subscribing as we may want to update the\n    // state during the subscription process in the subscriber so we add the call to state before subscribing.\n    this._context.setCall(convertSdkCallToDeclarativeCall(call));\n    this._callSubscribers.set(call, new CallSubscriber(call, this._context, this._internalContext));\n    return this.getOrCreateDeclarativeCall(call);\n  };\n  private getOrCreateDeclarativeCall = (call: CallCommon): DeclarativeCallCommon => {\n    const declarativeCall = this._declarativeCalls.get(call);\n    if (declarativeCall) {\n      return declarativeCall;\n    }\n    const newDeclarativeCall = this.callDeclaratify(call, this._context);\n    this._declarativeCalls.set(call, newDeclarativeCall);\n    return newDeclarativeCall;\n  };\n\n  // args could be either from teamsCall or Call, set it as unknown and cast it in child class later\n  protected abstract startCall(agent: CallAgentCommon, args: unknown[]): CallCommon;\n  protected abstract joinCall(agent: CallAgentCommon, args: unknown[]): CallCommon;\n  protected abstract agentSubscribe(agent: CallAgentCommon, args: unknown[]): void;\n  protected abstract agentUnsubscribe(agent: CallAgentCommon, args: unknown[]): void;\n\n  // We can't directly override get function because it is proxied,\n  // Add a getCommon function and call it in child class\n  protected getCommon<AgentType extends CallAgent, P extends keyof CallAgent>(target: AgentType, prop: P): any {\n    switch (prop) {\n      case 'startCall':\n        {\n          return this._context.withErrorTeedToState((...args: Parameters<AgentType['startCall']>): CallCommon => {\n            const call = this.startCall(target, args);\n            this.addCall(call);\n            return this.getOrCreateDeclarativeCall(call);\n          }, 'CallAgent.startCall');\n        }\n      case 'join':\n        {\n          return this._context.withErrorTeedToState((...args: Parameters<AgentType['join']>): CallCommon => {\n            const call = this.joinCall(target, args);\n            this.addCall(call);\n            return this.getOrCreateDeclarativeCall(call);\n          }, 'CallAgent.join');\n        }\n      case 'calls':\n        {\n          return Array.from(this._declarativeCalls.values());\n        }\n      case 'on':\n        {\n          return (...args: Parameters<AgentType['on']>): void => {\n            const isCallsUpdated = args[0] === 'callsUpdated';\n            if (isCallsUpdated) {\n              const listener = args[1];\n              this._externalCallsUpdatedListeners.add((listener as CollectionUpdatedEvent<CallCommon>));\n            } else {\n              this.agentSubscribe(target, args);\n            }\n          };\n        }\n      case 'off':\n        {\n          return (...args: Parameters<AgentType['off']>): void => {\n            const isCallsUpdated = args[0] === 'callsUpdated';\n            if (isCallsUpdated) {\n              const listener = args[1];\n              this._externalCallsUpdatedListeners.delete((listener as CollectionUpdatedEvent<CallCommon>));\n            } else {\n              this.agentUnsubscribe(target, args);\n            }\n          };\n        }\n      case 'dispose':\n        {\n          // Wrapping CallAgent.dispose in a callback type (): Promise<void> to accomodate the change of CallAgent.dispose\n          // in calling beta version 1.8.0-beta.1 from callback type (): Promise<void> to (): void\n          const callAgentDisposeAsyncCallbackWrapper = async (): Promise<void> => {\n            await target.dispose();\n            return Promise.resolve();\n          };\n          return (): Promise<void> => {\n            return callAgentDisposeAsyncCallbackWrapper().then(() => {\n              this.unsubscribe();\n            });\n          };\n        }\n      /**\n       * This attribute is a special case and doesn't exist on the CallAgent interface.\n       * We need this to be able to return a declarative incoming call object using the call agent.\n       * In a standard headless SDK usage, the right way to get an incoming call is to use the `incomingCall` event.\n       * However, using the declarative layer, the ideal usage would be to:\n       * 1. subscribe to the `onStateChange` event\n       * 2. Get the incoming call from the new state and it's ID\n       * 3. Use `callAgent.incomingCalls` and filter an incoming call ID to get a declarative incoming call object\n       */\n      case 'incomingCalls':\n        {\n          return Array.from(this._declarativeIncomingCalls.values());\n        }\n      default:\n        return Reflect.get(target, prop);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport const clearCallRelatedState = (context: CallContext, internalContext: InternalCallContext): void => {\n  // Make sure there are no existing call data if creating a new CallAgentDeclarative (if creating a new\n  // CallAgentDeclarative after disposing of the hold one will mean context have old call state). TODO: should we stop\n  // rendering when the previous callAgent is disposed?\n  disposeAllViews(context, internalContext);\n  context.clearCallRelatedState();\n  internalContext.clearCallRelatedState();\n};"]}