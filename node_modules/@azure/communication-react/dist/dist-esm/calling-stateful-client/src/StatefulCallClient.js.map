{"version":3,"file":"StatefulCallClient.js","sourceRoot":"","sources":["../../../../preprocess-dist/calling-stateful-client/src/StatefulCallClient.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;;;;;;;;;AAElC,OAAO,EAAE,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AACtE,OAAO,EAAE,UAAU,EAAuD,MAAM,8BAA8B,CAAC;AAE/G,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAC5C,OAAO,EAAE,oBAAoB,EAAwB,MAAM,wBAAwB,CAAC;AACpF,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAC5D,OAAO,EAAE,UAAU,EAAE,WAAW,EAAoB,MAAM,eAAe,CAAC;AAC1E,OAAO,EAAwD,iBAAiB,EAAE,MAAM,6BAA6B,CAAC;AACtH,OAAO,EAAE,6BAA6B,EAAE,iBAAiB,EAAE,gCAAgC;AAC3F,OAAO,EAAE,qBAAqB,EAAE,MAAM,UAAU,CAAC;AACjD,OAAO,EAAE,kCAAkC,EAAE,MAAM,sCAAsC,CAAC;AA0H1F;;;;GAIG;AACH,MAAM,eAAe;IAMnB,YAAY,OAAoB,EAAE,eAAoC;QACpE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;IAC1C,CAAC;IACM,GAAG,CAA6B,MAAkB,EAAE,IAAO;QAChE,QAAQ,IAAI,EAAE;YACZ,KAAK,iBAAiB;gBACpB;oBACE,OAAO,IAAI,CAAC,QAAQ,CAAC,yBAAyB,CAAC,CAAO,GAAG,IAA+C,EAAiC,EAAE;wBACzI,sGAAsG;wBACtG,2GAA2G;wBAC3G,6CAA6C;wBAC7C,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,CAAC;wBACxD,IAAI,CAAC,UAAU,GAAG,oBAAoB,CAAC,SAAS,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;wBACxF,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;4BACzB,WAAW,EAAE,IAAI,CAAC,UAAU,CAAC,WAAW;yBACzC,CAAC,CAAC;wBACH,OAAO,IAAI,CAAC,UAAU,CAAC;oBACzB,CAAC,CAAA,EAAE,4BAA4B,CAAC,CAAC;iBAClC;YACH,KAAK,sBAAsB;gBACzB;oBACE,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;iBAClC;YACH,KAAK,kBAAkB;gBACrB;oBACE,OAAO,IAAI,CAAC,QAAQ,CAAC,yBAAyB,CAAC,GAAS,EAAE;wBACxD,qGAAqG;wBACrG,8GAA8G;wBAC9G,0GAA0G;wBAC1G,MAAM,aAAa,GAAG,MAAM,MAAM,CAAC,gBAAgB,EAAE,CAAC;wBACtD,IAAI,IAAI,CAAC,iBAAiB,EAAE;4BAC1B,IAAI,IAAI,CAAC,iBAAiB,KAAK,aAAa,EAAE;gCAC5C,OAAO,IAAI,CAAC,cAAc,CAAC;6BAC5B;iCAAM;gCACL,MAAM,IAAI,KAAK,CAAC,sGAAsG,GAAG,wFAAwF,CAAC,CAAC;6BACpN;yBACF;6BAAM;4BACL,IAAI,CAAC,iBAAiB,GAAG,aAAa,CAAC;yBACxC;wBACD,IAAI,CAAC,cAAc,GAAG,wBAAwB,CAAC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAC7E,OAAO,IAAI,CAAC,cAAc,CAAC;oBAC7B,CAAC,CAAA,EAAE,6BAA6B,CAAC,CAAC;iBACnC;YACH,KAAK,SAAS;gBACZ,GAAE;YACJ;gBACE,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SACpC;IACH,CAAC;CACF;AAgCD;;;;;;;;;;;;;GAaG;AACH,MAAM,CAAC,MAAM,wBAAwB,GAAG,CAAC,IAA4B,EAAE,OAAmC,EAAsB,EAAE;IAChI,qBAAqB,CAAC,IAAI,CAAC,2DAA2D,iBAAiB,EAAE,EAAE,CAAC,CAAC;IAC7G,OAAO,gCAAgC,CAAC,IAAI,UAAU,CAAC,gBAAgB,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB,CAAC,CAAC,EAAE,IAAI,WAAW,CAAC,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,uBAAuB,CAAC,EAAE,IAAI,mBAAmB,EAAE,CAAC,CAAC;AACtN,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,gCAAgC,GAAG,CAAC,UAAsB,EAAE,OAAoB,EAAE,eAAoC,EAAsB,EAAE;IACzJ,MAAM,CAAC,cAAc,CAAC,UAAU,EAAE,UAAU,EAAE;QAC5C,YAAY,EAAE,KAAK;QACnB,KAAK,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,QAAQ,EAAE;KAChC,CAAC,CAAC;IACH,MAAM,CAAC,cAAc,CAAC,UAAU,EAAE,eAAe,EAAE;QACjD,YAAY,EAAE,KAAK;QACnB,KAAK,EAAE,CAAC,OAAyC,EAAE,EAAE,CAAC,OAAO,CAAC,aAAa,CAAC,OAAO,CAAC;KACrF,CAAC,CAAC;IACH,MAAM,CAAC,cAAc,CAAC,UAAU,EAAE,gBAAgB,EAAE;QAClD,YAAY,EAAE,KAAK;QACnB,KAAK,EAAE,CAAC,OAAyC,EAAE,EAAE,CAAC,OAAO,CAAC,cAAc,CAAC,OAAO,CAAC;KACtF,CAAC,CAAC;IACH,MAAM,CAAC,cAAc,CAAC,UAAU,EAAE,YAAY,EAAE;QAC9C,YAAY,EAAE,KAAK;QACnB,KAAK,EAAE,CAAO,MAA0B,EAAE,aAAkD,EAAE,MAAsD,EAAE,OAA2B,EAAyC,EAAE;YAC1N,MAAM,iBAAiB,GAAG,aAAa,CAAC,CAAC,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YACvF,MAAM,MAAM,GAAG,MAAM,UAAU,CAAC,OAAO,EAAE,eAAe,EAAE,MAAM,EAAE,iBAAiB,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;YACtG,oLAAoL;YACpL,IAAI,IAAI,IAAI,MAAM,IAAI,MAAM,IAAI,aAAa,IAAI,MAAM,EAAE;gBACvD,MAAM,cAAc,GAAG,6BAA6B,CAAC,aAAa,CAAC,CAAC;gBACpE,MAAM,CAAC,IAAI,GAAG,kCAAkC,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC;aAC3G;YACD,OAAO,MAAM,CAAC;QAChB,CAAC,CAAA;KACF,CAAC,CAAC;IACH,MAAM,CAAC,cAAc,CAAC,UAAU,EAAE,aAAa,EAAE;QAC/C,YAAY,EAAE,KAAK;QACnB,KAAK,EAAE,CAAC,MAA0B,EAAE,aAAkD,EAAE,MAAsD,EAAQ,EAAE;YACtJ,MAAM,iBAAiB,GAAG,aAAa,CAAC,CAAC,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YACvF,WAAW,CAAC,OAAO,EAAE,eAAe,EAAE,MAAM,EAAE,iBAAiB,EAAE,MAAM,CAAC,CAAC;QAC3E,CAAC;KACF,CAAC,CAAC;IACH,OAAQ,IAAI,KAAK,CAAC,UAAU,EAAE,IAAI,eAAe,CAAC,OAAO,EAAE,eAAe,CAAC,CAAwB,CAAC;AACtG,CAAC,CAAC;AACF,MAAM,gBAAgB,GAAG,CAAC,OAA2B,EAAqB,EAAE;;IAC1E,MAAM,IAAI,GAAG,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,0CAAE,IAAI,mCAAI,EAAE,CAAC;IAC9C,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;IAC/B,uCACK,OAAO,KACV,WAAW,kCACN,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,KACvB,IAAI,OAEN;AACJ,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { deviceManagerDeclaratify } from './DeviceManagerDeclarative';\nimport { CallClient, CallClientOptions, CreateViewOptions, DeviceManager } from '@azure/communication-calling';\nimport { CallClientState, LocalVideoStreamState, RemoteVideoStreamState } from './CallClientState';\nimport { CallContext } from './CallContext';\nimport { callAgentDeclaratify, DeclarativeCallAgent } from './CallAgentDeclarative';\nimport { InternalCallContext } from './InternalCallContext';\nimport { createView, disposeView, CreateViewResult } from './StreamUtils';\nimport { CommunicationIdentifier, CommunicationUserIdentifier, getIdentifierKind } from '@azure/communication-common';\nimport { toFlatCommunicationIdentifier, _getApplicationId } from '@internal/acs-ui-common';\nimport { callingStatefulLogger } from './Logger';\nimport { videoStreamRendererViewDeclaratify } from './VideoStreamRendererViewDeclarative';\n\n/**\n * Defines the methods that allow CallClient {@link @azure/communication-calling#CallClient} to be used statefully.\n * The interface provides access to proxied state and also allows registering a handler for state change events. For\n * state definition see {@link CallClientState}.\n *\n * State change events are driven by:\n * - Returned data from {@link @azure/communication-calling#DeviceManager} APIs.\n * - Returned data from {@link @azure/communication-calling#CallAgent} APIs.\n * - Listeners automatically attached to various azure communication-calling objects:\n *   - CallAgent 'incomingCall'\n *   - CallAgent 'callsUpdated'\n *   - DeviceManager 'videoDevicesUpdated'\n *   - DeviceManager 'audioDevicesUpdated\n *   - DeviceManager 'selectedMicrophoneChanged'\n *   - DeviceManager 'selectedSpeakerChanged'\n *   - Call 'stateChanged'\n *   - Call 'idChanged'\n *   - Call 'isMutedChanged'\n *   - Call 'isScreenSharingOnChanged'\n *   - Call 'remoteParticipantsUpdated'\n *   - Call 'localVideoStreamsUpdated'\n *   - IncomingCall 'callEnded'\n *   - RemoteParticipant 'stateChanged'\n *   - RemoteParticipant 'isMutedChanged'\n *   - RemoteParticipant 'displayNameChanged'\n *   - RemoteParticipant 'isSpeakingChanged'\n *   - RemoteParticipant 'videoStreamsUpdated'\n *   - RemoteVideoStream 'isAvailableChanged'\n *   - TranscriptionCallFeature 'isTranscriptionActiveChanged'\n *   - RecordingCallFeature 'isRecordingActiveChanged'\n *\n * @public\n */\nexport interface StatefulCallClient extends CallClient {\n  /**\n   * Holds all the state that we could proxy from CallClient {@link @azure/communication-calling#CallClient} as\n   * CallClientState {@link CallClientState}.\n   */\n  getState(): CallClientState;\n  /**\n   * Allows a handler to be registered for 'stateChanged' events.\n   *\n   * @param handler - Callback to receive the state.\n   */\n  onStateChange(handler: (state: CallClientState) => void): void;\n  /**\n   * Allows unregistering for 'stateChanged' events.\n   *\n   * @param handler - Original callback to be unsubscribed.\n   */\n  offStateChange(handler: (state: CallClientState) => void): void;\n  /**\n   * Renders a {@link RemoteVideoStreamState} or {@link LocalVideoStreamState} and stores the resulting\n   * {@link VideoStreamRendererViewState} under the relevant {@link RemoteVideoStreamState} or\n   * {@link LocalVideoStreamState} or as unparented view in the state. Under the hood calls\n   * {@link @azure/communication-calling#VideoStreamRenderer.createView}.\n   *\n   * Scenario 1: Render RemoteVideoStreamState\n   * - CallId is required, participantId is required, and stream of type RemoteVideoStreamState is required\n   * - Resulting {@link VideoStreamRendererViewState} is stored in the given callId and participantId in\n   * {@link CallClientState}\n   *\n   * Scenario 2: Render LocalVideoStreamState for a call\n   * - CallId is required, participantId must be undefined, and stream of type LocalVideoStreamState is required.\n   * - The {@link @azure/communication-calling#Call.localVideoStreams} must already be started using\n   *   {@link @azure/communication-calling#Call.startVideo}.\n   * - Resulting {@link VideoStreamRendererViewState} is stored in the given callId {@link CallState.localVideoStreams}\n   *   in {@link CallClientState}.\n   *\n   * - Scenario 2: Render LocalVideoStreamState not part of a call (example rendering camera for local preview)\n   * - CallId must be undefined, participantId must be undefined, and stream of type LocalVideoStreamState is required.\n   * - Resulting {@link VideoStreamRendererViewState} is stored in under the given LocalVideoStreamState in\n   *   {@link CallClientState.deviceManager.unparentedViews}\n   *\n   * @param callId - CallId for the given stream. Can be undefined if the stream is not part of any call.\n   * @param participantId - {@link RemoteParticipant.identifier} associated with the given RemoteVideoStreamState. Could\n   *   be undefined if rendering LocalVideoStreamState.\n   * @param stream - The LocalVideoStreamState or RemoteVideoStreamState to start rendering.\n   * @param options - Options that are passed to the {@link @azure/communication-calling#VideoStreamRenderer}.\n   */\n  createView(callId: string | undefined, participantId: CommunicationIdentifier | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState, options?: CreateViewOptions): Promise<CreateViewResult | undefined>;\n  /**\n   * Stops rendering a {@link RemoteVideoStreamState} or {@link LocalVideoStreamState} and removes the\n   * {@link VideoStreamRendererView} from the relevant {@link RemoteVideoStreamState} in {@link CallClientState} or\n   * {@link LocalVideoStream} in {@link CallClientState} or appropriate\n   * {@link CallClientState.deviceManager.unparentedViews} Under the hood calls\n   * {@link @azure/communication-calling#VideoStreamRenderer.dispose}.\n   *\n   * Its important to disposeView to clean up resources properly.\n   *\n   * Scenario 1: Dispose RemoteVideoStreamState\n   * - CallId is required, participantId is required, and stream of type RemoteVideoStreamState is required\n   *\n   * Scenario 2: Dispose LocalVideoStreamState for a call\n   * - CallId is required, participantId must be undefined, and stream of type LocalVideoStreamState is required.\n   *\n   * - Scenario 2: Dispose LocalVideoStreamState not part of a call\n   * - CallId must be undefined, participantId must be undefined, and stream of type LocalVideoStreamState is required.\n   * - LocalVideoStreamState must be the original one passed to createView.\n   *\n   * @param callId - CallId for the given stream. Can be undefined if the stream is not part of any call.\n   * @param participantId - {@link RemoteParticipant.identifier} associated with the given RemoteVideoStreamState. Could\n   *   be undefined if disposing LocalVideoStreamState.\n   * @param stream - The LocalVideoStreamState or RemoteVideoStreamState to dispose.\n   */\n  disposeView(callId: string | undefined, participantId: CommunicationIdentifier | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState): void;\n}\n\n/**\n * A function to modify the state of the StatefulCallClient.\n *\n * Provided as a callback to the {@link StatefulCallClient.modifyState} method.\n *\n * The function must modify the provided state in place as much as possible.\n * Making large modifications can lead to bad performance by causing spurious rerendering of the UI.\n *\n * Consider using commonly used modifier functions exported from this package.\n */\nexport type CallStateModifier = (state: CallClientState) => void;\n\n/**\n * ProxyCallClient proxies CallClient {@link @azure/communication-calling#CallClient} and subscribes to all events that\n * affect state. ProxyCallClient keeps its own copy of the call state and when state is updated, ProxyCallClient emits\n * the event 'stateChanged'.\n */\nclass ProxyCallClient implements ProxyHandler<CallClient> {\n  private _context: CallContext;\n  private _internalContext: InternalCallContext;\n  private _callAgent: DeclarativeCallAgent | undefined;\n  private _deviceManager: DeviceManager | undefined;\n  private _sdkDeviceManager: DeviceManager | undefined;\n  constructor(context: CallContext, internalContext: InternalCallContext) {\n    this._context = context;\n    this._internalContext = internalContext;\n  }\n  public get<P extends keyof CallClient>(target: CallClient, prop: P): any {\n    switch (prop) {\n      case 'createCallAgent':\n        {\n          return this._context.withAsyncErrorTeedToState(async (...args: Parameters<CallClient['createCallAgent']>): Promise<DeclarativeCallAgent> => {\n            // createCallAgent will throw an exception if the previous callAgent was not disposed. If the previous\n            // callAgent was disposed then it would have unsubscribed to events so we can just create a new declarative\n            // callAgent if the createCallAgent succeeds.\n            const callAgent = await target.createCallAgent(...args);\n            this._callAgent = callAgentDeclaratify(callAgent, this._context, this._internalContext);\n            this._context.setCallAgent({\n              displayName: this._callAgent.displayName\n            });\n            return this._callAgent;\n          }, 'CallClient.createCallAgent');\n        }\n      case 'createTeamsCallAgent':\n        {\n          return Reflect.get(target, prop);\n        }\n      case 'getDeviceManager':\n        {\n          return this._context.withAsyncErrorTeedToState(async () => {\n            // As of writing, the SDK always returns the same instance of DeviceManager so we keep a reference of\n            // DeviceManager and if it does not change we return the cached DeclarativeDeviceManager. If it does not we'll\n            // throw an error that indicate we need to fix this issue as our implementation has diverged from the SDK.\n            const deviceManager = await target.getDeviceManager();\n            if (this._sdkDeviceManager) {\n              if (this._sdkDeviceManager === deviceManager) {\n                return this._deviceManager;\n              } else {\n                throw new Error('Multiple DeviceManager not supported. This means a incompatible version of communication-calling is ' + 'used OR calling declarative was not properly updated to communication-calling version.');\n              }\n            } else {\n              this._sdkDeviceManager = deviceManager;\n            }\n            this._deviceManager = deviceManagerDeclaratify(deviceManager, this._context);\n            return this._deviceManager;\n          }, 'CallClient.getDeviceManager');\n        }\n      case 'feature':\n        {}\n      default:\n        return Reflect.get(target, prop);\n    }\n  }\n}\n\n/**\n * Arguments to construct the StatefulCallClient.\n *\n * @public\n */\nexport type StatefulCallClientArgs = {\n  /**\n   * UserId from SDK. This is provided for developer convenience to easily access the userId from the\n   * state. It is not used by StatefulCallClient.\n   */\n  userId: CommunicationUserIdentifier;\n};\n\n/**\n * Options to construct the StatefulCallClient with.\n *\n * @public\n */\nexport type StatefulCallClientOptions = {\n  /**\n   * Options to construct the {@link @axure/communication-calling#CallClient} with.\n   */\n  callClientOptions: CallClientOptions;\n  /**\n   * Sets the max listeners limit of the 'stateChange' event. Defaults to the node.js EventEmitter.defaultMaxListeners\n   * if not specified.\n   */\n  maxStateChangeListeners?: number;\n};\n\n/**\n * Creates a StatefulCallClient {@link StatefulCallClient} by proxying CallClient\n * {@link @azure/communication-calling#CallClient} with ProxyCallClient {@link ProxyCallClient} which then allows access\n * to state in a declarative way.\n *\n * It is important to use the {@link @azure/communication-calling#DeviceManager} and\n * {@link @azure/communication-calling#CallAgent} and {@link @azure/communication-calling#Call} (and etc.) that are\n * obtained from the StatefulCallClient in order for their state changes to be proxied properly.\n *\n * @param args - {@link StatefulCallClientArgs}\n * @param options - {@link StatefulCallClientOptions}\n *\n * @public\n */\nexport const createStatefulCallClient = (args: StatefulCallClientArgs, options?: StatefulCallClientOptions): StatefulCallClient => {\n  callingStatefulLogger.info(`Creating calling stateful client using library version: ${_getApplicationId()}`);\n  return createStatefulCallClientWithDeps(new CallClient(withTelemetryTag(options?.callClientOptions)), new CallContext(getIdentifierKind(args.userId), options?.maxStateChangeListeners), new InternalCallContext());\n};\n\n/**\n * Package-internal version of createStatefulCallClient that allows dependency injection.\n *\n * This function should not be exported from the package.\n */\nexport const createStatefulCallClientWithDeps = (callClient: CallClient, context: CallContext, internalContext: InternalCallContext): StatefulCallClient => {\n  Object.defineProperty(callClient, 'getState', {\n    configurable: false,\n    value: () => context.getState()\n  });\n  Object.defineProperty(callClient, 'onStateChange', {\n    configurable: false,\n    value: (handler: (state: CallClientState) => void) => context.onStateChange(handler)\n  });\n  Object.defineProperty(callClient, 'offStateChange', {\n    configurable: false,\n    value: (handler: (state: CallClientState) => void) => context.offStateChange(handler)\n  });\n  Object.defineProperty(callClient, 'createView', {\n    configurable: false,\n    value: async (callId: string | undefined, participantId: CommunicationIdentifier | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState, options?: CreateViewOptions): Promise<CreateViewResult | undefined> => {\n      const participantIdKind = participantId ? getIdentifierKind(participantId) : undefined;\n      const result = await createView(context, internalContext, callId, participantIdKind, stream, options);\n      // We only need to declaratify the VideoStreamRendererView object for remote participants. Because the updateScalingMode only needs to be called on remote participant stream views.\n      if ('id' in stream && callId && participantId && result) {\n        const participantKey = toFlatCommunicationIdentifier(participantId);\n        result.view = videoStreamRendererViewDeclaratify(result.view, context, callId, participantKey, stream.id);\n      }\n      return result;\n    }\n  });\n  Object.defineProperty(callClient, 'disposeView', {\n    configurable: false,\n    value: (callId: string | undefined, participantId: CommunicationIdentifier | undefined, stream: LocalVideoStreamState | RemoteVideoStreamState): void => {\n      const participantIdKind = participantId ? getIdentifierKind(participantId) : undefined;\n      disposeView(context, internalContext, callId, participantIdKind, stream);\n    }\n  });\n  return (new Proxy(callClient, new ProxyCallClient(context, internalContext)) as StatefulCallClient);\n};\nconst withTelemetryTag = (options?: CallClientOptions): CallClientOptions => {\n  const tags = options?.diagnostics?.tags ?? [];\n  tags.push(_getApplicationId());\n  return {\n    ...options,\n    diagnostics: {\n      ...options?.diagnostics,\n      tags\n    }\n  };\n};\"../../acs-ui-common/src\""]}