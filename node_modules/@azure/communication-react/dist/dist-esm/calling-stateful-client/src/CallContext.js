// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createClientLogger, getLogLevel } from '@azure/logger';
import EventEmitter from 'events';
import { enableMapSet, enablePatches, produce } from 'immer';
import { _safeJSONStringify, toFlatCommunicationIdentifier } from "../../acs-ui-common/src";
import { CallError } from './CallClientState';
import { callingStatefulLogger } from './Logger';
import { CallIdHistory } from './CallIdHistory';
enableMapSet();
// Needed to generate state diff for verbose logging.
enablePatches();
// TODO: How can we make this configurable?
/**
 * @private
 */
export const MAX_CALL_HISTORY_LENGTH = 10;
/**
 * @private
 */
export class CallContext {
    constructor(userId, maxListeners = 50, /* @conditional-compile-remove(PSTN-calls) */ alternateCallerId) {
        this._callIdHistory = new CallIdHistory();
        this._logger = createClientLogger('communication-react:calling-context');
        this._state = {
            calls: {},
            callsEnded: {},
            incomingCalls: {},
            incomingCallsEnded: {},
            deviceManager: {
                isSpeakerSelectionAvailable: false,
                cameras: [],
                microphones: [],
                speakers: [],
                unparentedViews: []
            },
            callAgent: undefined,
            userId: userId,
            latestErrors: {}
        };
        this._emitter = new EventEmitter();
        this._emitter.setMaxListeners(maxListeners);
        this._atomicId = 0;
    }
    getState() {
        return this._state;
    }
    modifyState(modifier) {
        const priorState = this._state;
        this._state = produce(this._state, modifier, (patches) => {
            if (getLogLevel() === 'verbose') {
                // Log to `info` because AzureLogger.verbose() doesn't show up in console.
                this._logger.info(`State change: ${_safeJSONStringify(patches)}`);
            }
        });
        if (this._state !== priorState) {
            this._emitter.emit('stateChanged', this._state);
        }
    }
    onStateChange(handler) {
        this._emitter.on('stateChanged', handler);
    }
    offStateChange(handler) {
        this._emitter.off('stateChanged', handler);
    }
    // Disposing of the CallAgentDeclarative will not clear the state. If we create a new CallAgentDeclarative, we should
    // make sure the state is clean because any left over state (if previous CallAgentDeclarative was disposed) may be
    // invalid.
    clearCallRelatedState() {
        this.modifyState((draft) => {
            draft.calls = {};
            draft.incomingCalls = {};
            draft.callsEnded = {};
            draft.incomingCallsEnded = {};
        });
    }
    setCallAgent(callAgent) {
        this.modifyState((draft) => {
            draft.callAgent = callAgent;
        });
    }
    setCall(call) {
        this.modifyState((draft) => {
            const latestCallId = this._callIdHistory.latestCallId(call.id);
            const existingCall = draft.calls[latestCallId];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
                existingCall.state = call.state;
                existingCall.callEndReason = call.callEndReason;
                existingCall.direction = call.direction;
                existingCall.isMuted = call.isMuted;
                existingCall.isScreenSharingOn = call.isScreenSharingOn;
                existingCall.localVideoStreams = call.localVideoStreams;
                existingCall.remoteParticipants = call.remoteParticipants;
                existingCall.transcription.isTranscriptionActive = call.transcription.isTranscriptionActive;
                existingCall.recording.isRecordingActive = call.recording.isRecordingActive; // We don't update the startTime and endTime if we are updating an existing active call
            }
            else {
                draft.calls[latestCallId] = call;
            }
        });
    }
    removeCall(callId) {
        this.modifyState((draft) => {
            delete draft.calls[this._callIdHistory.latestCallId(callId)];
        });
    }
    setCallEnded(callId, callEndReason) {
        const latestCallId = this._callIdHistory.latestCallId(callId);
        this.modifyState((draft) => {
            const call = draft.calls[latestCallId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.calls[latestCallId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.callsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.callsEnded[findOldestCallEnded(draft.callsEnded)];
                }
                draft.callsEnded[latestCallId] = call;
            }
        });
    }
    setCallState(callId, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.state = state;
            }
        });
    }
    setCallId(newCallId, oldCallId) {
        this._callIdHistory.updateCallIdHistory(newCallId, oldCallId);
        this.modifyState((draft) => {
            const call = draft.calls[oldCallId];
            if (call) {
                call.id = newCallId;
                delete draft.calls[oldCallId];
                draft.calls[newCallId] = call;
            }
        });
    }
    setCallIsScreenSharingOn(callId, isScreenSharingOn) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isScreenSharingOn = isScreenSharingOn;
            }
        });
    }
    setCallRemoteParticipants(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipants[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipants[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        });
    }
    setCallRemoteParticipantsEnded(callId, addRemoteParticipant, removeRemoteParticipant) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                removeRemoteParticipant.forEach((id) => {
                    delete call.remoteParticipantsEnded[id];
                });
                addRemoteParticipant.forEach((participant) => {
                    call.remoteParticipantsEnded[toFlatCommunicationIdentifier(participant.identifier)] = participant;
                });
            }
        });
    }
    setCallLocalVideoStream(callId, streams) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.localVideoStreams = streams;
            }
        });
    }
    setCallIsMicrophoneMuted(callId, isMicrophoneMuted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.isMuted = isMicrophoneMuted;
            }
        });
    }
    setCallDominantSpeakers(callId, dominantSpeakers) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.dominantSpeakers = dominantSpeakers;
            }
        });
    }
    setCallRecordingActive(callId, isRecordingActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.recording.isRecordingActive = isRecordingActive;
            }
        });
    }
    setCallTranscriptionActive(callId, isTranscriptionActive) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.transcription.isTranscriptionActive = isTranscriptionActive;
            }
        });
    }
    setCallScreenShareParticipant(callId, participantKey) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                call.screenShareRemoteParticipant = participantKey;
            }
        });
    }
    setLocalVideoStreamRendererView(callId, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                if (call.localVideoStreams.length > 0) {
                    call.localVideoStreams[0].view = view;
                }
            }
        });
    }
    setParticipantState(callId, participantKey, state) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.state = state;
                }
            }
        });
    }
    setParticipantIsMuted(callId, participantKey, muted) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isMuted = muted;
                }
            }
        });
    }
    setParticipantDisplayName(callId, participantKey, displayName) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.displayName = displayName;
                }
            }
        });
    }
    setParticipantIsSpeaking(callId, participantKey, isSpeaking) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    participant.isSpeaking = isSpeaking;
                }
            }
        });
    }
    setParticipantVideoStream(callId, participantKey, stream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    // Set is called by subscriber will not modify any rendered stream so if there is existing stream only
                    // modify the values that subscriber has access to.
                    const existingStream = participant.videoStreams[stream.id];
                    if (existingStream) {
                        existingStream.isAvailable = stream.isAvailable;
                        existingStream.mediaStreamType = stream.mediaStreamType;
                    }
                    else {
                        participant.videoStreams[stream.id] = stream;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamIsAvailable(callId, participantKey, streamId, isAvailable) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.isAvailable = isAvailable;
                    }
                }
            }
        });
    }
    setRemoteVideoStreams(callId, participantKey, addRemoteVideoStream, removeRemoteVideoStream) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    for (const id of removeRemoteVideoStream) {
                        delete participant.videoStreams[id];
                    }
                    for (const newStream of addRemoteVideoStream) {
                        // This should only be called by the subscriber and some properties are add by other components so if the
                        // stream already exists, only update the values that subscriber knows about.
                        const stream = participant.videoStreams[newStream.id];
                        if (stream) {
                            stream.mediaStreamType = newStream.mediaStreamType;
                            stream.isAvailable = newStream.isAvailable;
                        }
                        else {
                            participant.videoStreams[newStream.id] = newStream;
                        }
                    }
                }
            }
        });
    }
    setRemoteVideoStreamRendererView(callId, participantKey, streamId, view) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream) {
                        stream.view = view;
                    }
                }
            }
        });
    }
    setRemoteVideoStreamViewScalingMode(callId, participantKey, streamId, scalingMode) {
        this.modifyState((draft) => {
            const call = draft.calls[this._callIdHistory.latestCallId(callId)];
            if (call) {
                const participant = call.remoteParticipants[participantKey];
                if (participant) {
                    const stream = participant.videoStreams[streamId];
                    if (stream && stream.view) {
                        stream.view.scalingMode = scalingMode;
                    }
                }
            }
        });
    }
    setIncomingCall(call) {
        this.modifyState((draft) => {
            const existingCall = draft.incomingCalls[call.id];
            if (existingCall) {
                existingCall.callerInfo = call.callerInfo;
            }
            else {
                draft.incomingCalls[call.id] = call;
            }
        });
    }
    removeIncomingCall(callId) {
        this.modifyState((draft) => {
            delete draft.incomingCalls[callId];
        });
    }
    setIncomingCallEnded(callId, callEndReason) {
        this.modifyState((draft) => {
            const call = draft.incomingCalls[callId];
            if (call) {
                call.endTime = new Date();
                call.callEndReason = callEndReason;
                delete draft.incomingCalls[callId];
                // Performance note: This loop should run only once because the number of entries
                // is never allowed to exceed MAX_CALL_HISTORY_LENGTH. A loop is used for correctness.
                while (Object.keys(draft.incomingCallsEnded).length >= MAX_CALL_HISTORY_LENGTH) {
                    delete draft.incomingCallsEnded[findOldestCallEnded(draft.incomingCallsEnded)];
                }
                draft.incomingCallsEnded[callId] = call;
            }
        });
    }
    setDeviceManagerIsSpeakerSelectionAvailable(isSpeakerSelectionAvailable) {
        this.modifyState((draft) => {
            draft.deviceManager.isSpeakerSelectionAvailable = isSpeakerSelectionAvailable;
        });
    }
    setDeviceManagerSelectedMicrophone(selectedMicrophone) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedMicrophone = selectedMicrophone;
        });
    }
    setDeviceManagerSelectedSpeaker(selectedSpeaker) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedSpeaker = selectedSpeaker;
        });
    }
    setDeviceManagerSelectedCamera(selectedCamera) {
        this.modifyState((draft) => {
            draft.deviceManager.selectedCamera = selectedCamera;
        });
    }
    setDeviceManagerCameras(cameras) {
        this.modifyState((draft) => {
            /**
             * SDK initializes cameras with one dummy camera with value { id: 'camera:id', name: '', deviceType: 'USBCamera' } immediately after
             * camera permissions are granted. So selectedCamera will have this value before the actual cameras are obtained. Therefore we should reset
             * selectedCamera to the first camera when there are cameras AND when current selectedCamera does not exist in the new array of cameras *
             */
            if (cameras.length > 0 && !cameras.some(camera => { var _a; return camera.id === ((_a = draft.deviceManager.selectedCamera) === null || _a === void 0 ? void 0 : _a.id); })) {
                draft.deviceManager.selectedCamera = cameras[0];
            }
            draft.deviceManager.cameras = cameras;
        });
    }
    setDeviceManagerMicrophones(microphones) {
        this.modifyState((draft) => {
            draft.deviceManager.microphones = microphones;
        });
    }
    setDeviceManagerSpeakers(speakers) {
        this.modifyState((draft) => {
            draft.deviceManager.speakers = speakers;
        });
    }
    setDeviceManagerDeviceAccess(deviceAccess) {
        this.modifyState((draft) => {
            draft.deviceManager.deviceAccess = deviceAccess;
        });
    }
    setDeviceManagerUnparentedView(localVideoStream, view) {
        this.modifyState((draft) => {
            draft.deviceManager.unparentedViews.push({
                source: localVideoStream.source,
                mediaStreamType: localVideoStream.mediaStreamType,
                view: view
            });
        });
    }
    deleteDeviceManagerUnparentedView(localVideoStream) {
        this.modifyState((draft) => {
            const foundIndex = draft.deviceManager.unparentedViews.findIndex(stream => stream.source.id === localVideoStream.source.id && stream.mediaStreamType === localVideoStream.mediaStreamType);
            if (foundIndex !== -1) {
                draft.deviceManager.unparentedViews.splice(foundIndex, 1);
            }
        });
    }
    getAndIncrementAtomicId() {
        const id = this._atomicId;
        this._atomicId++;
        return id;
    }
    /**
     * Tees any errors encountered in an async function to the state.
     *
     * @param action Async function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withAsyncErrorTeedToState(action, target) {
        return (...args) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        });
    }
    /**
     * Tees any errors encountered in an function to the state.
     *
     * @param action Function to execute.
     * @param target The error target to tee error to.
     * @returns Result of calling `f`. Also re-raises any exceptions thrown from `f`.
     * @throws CallError. Exceptions thrown from `f` are tagged with the failed `target.
     */
    withErrorTeedToState(action, target) {
        return (...args) => {
            try {
                callingStatefulLogger.info(`Calling stateful client target function called: ${target}`);
                return action(...args);
            }
            catch (error) {
                const callError = toCallError(target, error);
                this.setLatestError(target, callError);
                throw callError;
            }
        };
    }
    setLatestError(target, error) {
        this.modifyState((draft) => {
            draft.latestErrors[target] = error;
        });
    }
}
const toCallError = (target, error) => {
    if (error instanceof Error) {
        return new CallError(target, error);
    }
    return new CallError(target, new Error(error));
};
const findOldestCallEnded = (calls) => {
    var _a, _b, _c, _d;
    const callEntries = Object.entries(calls);
    let [oldestCallId, oldestCall] = callEntries[0];
    if (oldestCall.endTime === undefined) {
        return oldestCallId;
    }
    for (const [callId, call] of callEntries.slice(1)) {
        if (call.endTime === undefined) {
            return callId;
        }
        if (((_b = (_a = call.endTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) < ((_d = (_c = oldestCall.endTime) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0)) {
            [oldestCallId, oldestCall] = [callId, call];
        }
    }
    return oldestCallId;
};
//# sourceMappingURL=CallContext.js.map