"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStateManager = void 0;
var React = require("react");
var getDefinedProps = function (props) {
    var definedProps = {};
    Object.keys(props).forEach(function (propName) {
        if (props[propName] !== undefined) {
            definedProps[propName] = props[propName];
        }
    });
    return definedProps;
};
var useStateManager = function (managerFactory, options) {
    if (options === void 0) { options = {}; }
    var _a = options.mapPropsToInitialState, mapPropsToInitialState = _a === void 0 ? function () { return ({}); } : _a, _b = options.mapPropsToState, mapPropsToState = _b === void 0 ? function () { return ({}); } : _b, _c = options.sideEffects, sideEffects = _c === void 0 ? [] : _c;
    var latestActions = React.useMemo(function () { return ({}); }, 
    // The change of `managerFactory` should trigger recreation of `latestActions` as they can be different between
    // managers
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [managerFactory]);
    var latestManager = React.useRef(null);
    // Heads up! forceUpdate() is used only for triggering rerenders, stateManager is SSOT
    var _d = React.useReducer(function (c) { return c + 1; }, 0), forceUpdate = _d[1];
    // If manager exists, the current state will be used
    var initialState = latestManager.current ? latestManager.current.state : getDefinedProps(mapPropsToInitialState());
    latestManager.current = managerFactory({
        // Factory has already configured actions
        actions: {},
        state: __assign(__assign({}, initialState), getDefinedProps(mapPropsToState())),
        sideEffects: __spreadArray(__spreadArray([], sideEffects), [
            // `sideEffect` is called with two arguments, but hooks don't support the second callback
            // argument
            function () { return forceUpdate(); },
        ]),
    });
    // We need to keep the same reference to an object with actions to allow usage them as
    // a dependency in useCallback() hook
    Object.assign(latestActions, latestManager.current.actions);
    // For development environments we disallow ability to extend object with other properties to
    // avoid misusage
    if (process.env.NODE_ENV !== 'production') {
        if (Object.isExtensible(latestActions))
            Object.preventExtensions(latestActions);
    }
    // We need to pass exactly `manager.state` to provide the same state object during the same render
    // frame.
    // It keeps behavior consistency between React state tools and our managers
    // https://github.com/facebook/react/issues/11527#issuecomment-360199710
    // Object.freeze() is used only in dev-mode to avoid usage mistakes
    return {
        state: process.env.NODE_ENV === 'production' ? latestManager.current.state : Object.freeze(latestManager.current.state),
        actions: latestActions,
    };
};
exports.useStateManager = useStateManager;
