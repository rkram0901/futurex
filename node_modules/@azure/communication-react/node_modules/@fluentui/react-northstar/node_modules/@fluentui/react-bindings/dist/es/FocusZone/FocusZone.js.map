{"version":3,"sources":["FocusZone/FocusZone.tsx"],"names":["FocusZoneDirection","FocusZoneTabbableElements","IS_ENTER_DISABLED_ATTRIBUTE","IS_FOCUSABLE_ATTRIBUTE","getCode","keyboardKey","SpacebarKey","React","cx","PropTypes","elementContains","findScrollableParent","getDocument","getParent","getWindow","shouldWrapFocus","getElementType","getUnhandledProps","getNextElement","getPreviousElement","isElementFocusZone","isElementFocusSubZone","isElementTabbable","getElementIndexPath","getFocusableByIndexPath","FOCUSZONE_ID_ATTRIBUTE","handleRef","TABINDEX","NO_VERTICAL_WRAP","NO_HORIZONTAL_WRAP","LARGE_DISTANCE_FROM_CENTER","LARGE_NEGATIVE_DISTANCE_FROM_CENTER","_allInstances","outerZones","_windowToOuterZoneMap","Map","register","window","FZ","get","add","set","Set","size","unregister","delete","getOutZone","ALLOWED_INPUT_TYPES","ALLOW_VIRTUAL_ELEMENTS","_raiseClickFromKeyboardEvent","target","ev","event","MouseEvent","ctrlKey","metaKey","shiftKey","altKey","bubbles","cancelable","dispatchEvent","_onKeyDownCapture","Tab","forEach","zone","updateTabIndexes","FocusZone","props","_root","current","_id","_activeElement","_lastIndexPath","_isParked","_parkedTabIndex","_defaultFocusElement","_focusAlignment","_isInnerZone","_processingTabKey","windowElement","setRef","elem","innerRef","process","env","NODE_ENV","nodeType","Error","_onBlur","setParkedFocus","_onFocus","onActiveElementChanged","stopFocusPropagation","shouldFocusInnerElementWhenReceivedFocus","defaultTabbableElement","shouldIgnoreNotFocusable","dataset","isFocusable","newActiveElement","isImmediateDescendant","isImmediateDescendantOfZone","parentElement","maybeElementToFocus","focus","setFocusAlignment","stopPropagation","_onMouseDown","disabled","path","push","length","pop","setActiveElement","_onKeyDown","direction","shouldEnterInnerZone","pagingSupportDisabled","undefined","doc","onKeyDown","activeElement","isDefaultPrevented","innerZone","getFirstInnerZone","focusElement","firstChild","tryInvokeClickForFocusable","ArrowLeft","vertical","preventDefaultWhenHandled","moveFocusLeft","ArrowRight","moveFocusRight","ArrowUp","horizontal","moveFocusUp","ArrowDown","moveFocusDown","PageDown","moveFocusPaging","PageUp","handleTabKey","all","inputOnly","isElementInput","focusChanged","tabWithDirection","isRtl","shouldResetActiveElementWhenTabFromZone","Home","isContentEditableElement","shouldInputLoseFocus","End","lastChild","Enter","preventDefault","getHorizontalDistanceFromCenter","isForward","activeRect","targetRect","leftAlignment","left","targetRectTop","Math","floor","top","activeRectBottom","bottom","targetRectBottom","activeRectTop","isValidCandidateOnpagingDown","isValidCandidateOnpagingUp","width","abs","componentDidMount","body","addEventListener","querySelector","shouldFocusOnMount","componentDidUpdate","preventFocusRestoration","elementToFocus","componentWillUnmount","removeEventListener","render","className","ElementType","unhandledProps","propTypes","evaluateFocusBeforeRender","children","forceIntoFirstElement","getAttribute","ownerZoneElement","getOwnerZone","ownerZone","focusLast","element","forceAlignment","shouldReceiveFocus","focusedElement","shouldRestoreFocus","isParked","allowFocusRoot","setAttribute","removeAttribute","previousActiveElement","tabIndex","targetElement","shouldRaiseClicks","tagName","forRootElement","rootElement","child","firstElementChild","match","nextElementSibling","moveFocus","getDistanceFromCenter","useDefaultWrap","candidateDistance","candidateElement","changedFocus","isBidirectional","bidirectional","getBoundingClientRect","elementDistance","isCircularNavigation","lastElementChild","targetTop","distance","shouldWrap","topBottomComparison","parseFloat","toFixed","right","scrollableParent","targetBottom","pagesize","clientHeight","isElementPassedPageSizeOnPagingDown","isElementPassedPageSizeOnPagingUp","isHorizontal","isVertical","rect","height","onElement","childNodes","childIndex","toLowerCase","type","indexOf","selectionStart","selectionEnd","isRangeSelected","inputValue","value","isReadonly","readOnly","shouldInputLoseFocusOnArrowKey","noWrapDataAttribute","checkForNoWrap","Component","string","number","func","bool","as","elementType","onFocus","any","defaultProps","displayName"],"mappings":"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","sourcesContent":["import {\n  FocusZoneDirection,\n  FocusZoneTabbableElements,\n  IS_ENTER_DISABLED_ATTRIBUTE,\n  IS_FOCUSABLE_ATTRIBUTE,\n  getCode,\n  keyboardKey,\n  SpacebarKey,\n} from '@fluentui/accessibility';\nimport * as React from 'react';\nimport cx from 'classnames';\nimport * as _ from 'lodash';\nimport * as PropTypes from 'prop-types';\n\nimport {\n  elementContains,\n  findScrollableParent,\n  getDocument,\n  getParent,\n  getWindow,\n  shouldWrapFocus,\n} from '@uifabric/utilities';\n\nimport { getElementType } from '../utils/getElementType';\nimport { getUnhandledProps } from '../utils/getUnhandledProps';\nimport { FocusZoneProps, IFocusZone } from './FocusZone.types';\nimport {\n  getNextElement,\n  getPreviousElement,\n  isElementFocusZone,\n  isElementFocusSubZone,\n  isElementTabbable,\n  getElementIndexPath,\n  getFocusableByIndexPath,\n  FOCUSZONE_ID_ATTRIBUTE,\n} from './focusUtilities';\nimport { handleRef } from '@fluentui/react-component-ref';\n\nconst TABINDEX = 'tabindex';\nconst NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nconst NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nconst LARGE_DISTANCE_FROM_CENTER = 999999999;\nconst LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\n\nconst _allInstances: {\n  [key: string]: FocusZone;\n} = {};\n\nconst outerZones = {\n  _windowToOuterZoneMap: new Map<Window, Set<FocusZone>>(),\n  register(window: Window, FZ: FocusZone) {\n    if (this._windowToOuterZoneMap.get(window)) {\n      this._windowToOuterZoneMap.get(window)?.add(FZ);\n    } else {\n      this._windowToOuterZoneMap.set(window, new Set([FZ]));\n    }\n\n    return this._windowToOuterZoneMap.get(window)?.size;\n  },\n  unregister(window: Window, FZ: FocusZone) {\n    this._windowToOuterZoneMap.get(window)?.delete(FZ);\n    if (this._windowToOuterZoneMap.get(window)?.size === 0) {\n      this._windowToOuterZoneMap.delete(window);\n    }\n  },\n  getOutZone(window: Window) {\n    return this._windowToOuterZoneMap.get(window);\n  },\n};\n\ninterface Point {\n  left: number;\n  top: number;\n}\nconst ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];\n\nconst ALLOW_VIRTUAL_ELEMENTS = false;\n\n/**\n * Raises a click on a target element based on a keyboard event.\n */\nfunction _raiseClickFromKeyboardEvent(target: Element, ev?: React.KeyboardEvent<HTMLElement>): void {\n  const event = new MouseEvent('click', {\n    ctrlKey: ev?.ctrlKey,\n    metaKey: ev?.metaKey,\n    shiftKey: ev?.shiftKey,\n    altKey: ev?.altKey,\n    bubbles: ev?.bubbles,\n    cancelable: ev?.cancelable,\n  });\n\n  target.dispatchEvent(event);\n}\n\n/**\n * Handle global tab presses so that we can patch tabindexes on the fly.\n */\nfunction _onKeyDownCapture(ev: KeyboardEvent) {\n  if (getCode(ev) === keyboardKey.Tab) {\n    outerZones.getOutZone(getWindow(ev.target as Element)!)?.forEach(zone => zone.updateTabIndexes());\n  }\n}\n\nexport class FocusZone extends React.Component<FocusZoneProps> implements IFocusZone {\n  static propTypes = {\n    className: PropTypes.string,\n    direction: PropTypes.number,\n    defaultTabbableElement: PropTypes.func,\n    shouldFocusOnMount: PropTypes.bool,\n    shouldResetActiveElementWhenTabFromZone: PropTypes.bool,\n    shouldRaiseClicks: PropTypes.bool,\n    shouldFocusInnerElementWhenReceivedFocus: PropTypes.bool,\n    disabled: PropTypes.bool,\n    as: PropTypes.elementType as PropTypes.Requireable<React.ElementType>,\n    isCircularNavigation: PropTypes.bool,\n    shouldEnterInnerZone: PropTypes.func,\n    onActiveElementChanged: PropTypes.func,\n    shouldReceiveFocus: PropTypes.func,\n    handleTabKey: PropTypes.number,\n    shouldInputLoseFocusOnArrowKey: PropTypes.func,\n    stopFocusPropagation: PropTypes.bool,\n    onFocus: PropTypes.func,\n    preventDefaultWhenHandled: PropTypes.bool,\n    isRtl: PropTypes.bool,\n    preventFocusRestoration: PropTypes.bool,\n    pagingSupportDisabled: PropTypes.bool,\n    shouldIgnoreNotFocusable: PropTypes.bool,\n    innerRef: PropTypes.any,\n  };\n\n  static defaultProps: FocusZoneProps = {\n    isCircularNavigation: false,\n    direction: FocusZoneDirection.bidirectional,\n    as: 'div',\n    preventDefaultWhenHandled: true,\n    shouldRaiseClicks: false,\n  };\n\n  static displayName = 'FocusZone';\n  static className = 'ms-FocusZone';\n\n  static outerZones = outerZones;\n\n  _root: { current: HTMLElement | null } = { current: null };\n  _id: string;\n  /** The most recently focused child element. */\n  _activeElement: HTMLElement | null;\n\n  /**\n   * The index path to the last focused child element.\n   */\n  _lastIndexPath: number[] | undefined;\n\n  /**\n   * Flag to define when we've intentionally parked focus on the root element to temporarily\n   * hold focus until items appear within the zone.\n   */\n  _isParked: boolean = false;\n  _parkedTabIndex: string | null | undefined;\n\n  /** The child element with tabindex=0. */\n  _defaultFocusElement: HTMLElement | null;\n  _focusAlignment: Point;\n  _isInnerZone: boolean;\n\n  /** Used to allow us to move to next focusable element even when we're focusing on a input element when pressing tab */\n  _processingTabKey: boolean;\n\n  windowElement: Window | null;\n\n  constructor(props: FocusZoneProps) {\n    super(props);\n\n    this._id = _.uniqueId('FocusZone');\n\n    this._focusAlignment = {\n      left: 0,\n      top: 0,\n    };\n\n    this._processingTabKey = false;\n  }\n\n  componentDidMount(): void {\n    _allInstances[this._id] = this;\n\n    if (!this._root.current) {\n      return;\n    }\n\n    // @ts-ignore\n    this.windowElement = getWindow(this._root.current);\n    let parentElement = getParent(this._root.current, ALLOW_VIRTUAL_ELEMENTS);\n    const doc = getDocument(this._root.current);\n\n    // @ts-ignore\n    while (parentElement && parentElement !== doc.body && parentElement.nodeType === 1) {\n      if (isElementFocusZone(parentElement)) {\n        this._isInnerZone = true;\n        break;\n      }\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    if (!this._isInnerZone && this.windowElement) {\n      outerZones.register(this.windowElement, this);\n\n      if (outerZones.getOutZone(this.windowElement)?.size === 1) {\n        this.windowElement.addEventListener('keydown', _onKeyDownCapture, true);\n      }\n    }\n\n    this._root.current.addEventListener('blur', this._onBlur, true);\n\n    // Assign initial tab indexes so that we can set initial focus as appropriate.\n    this.updateTabIndexes();\n\n    if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n      this._activeElement = this.getDocument().querySelector(this.props.defaultTabbableElement) as HTMLElement;\n    }\n\n    if (this.props.shouldFocusOnMount) {\n      this.focus();\n    }\n  }\n\n  componentDidUpdate(): void {\n    if (!this._root.current) {\n      return;\n    }\n    const doc = getDocument(this._root.current);\n\n    if (\n      !this.props.preventFocusRestoration &&\n      doc &&\n      this._lastIndexPath &&\n      (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === this._root.current)\n    ) {\n      // The element has been removed after the render, attempt to restore focus.\n      const elementToFocus = getFocusableByIndexPath(this._root.current as HTMLElement, this._lastIndexPath);\n\n      if (elementToFocus) {\n        this.setActiveElement(elementToFocus, true);\n        elementToFocus.focus();\n        this.setParkedFocus(false);\n      } else {\n        // We had a focus path to restore, but now that path is unresolvable. Park focus\n        // on the container until we can try again.\n        this.setParkedFocus(true);\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    delete _allInstances[this._id];\n    outerZones.unregister(this.windowElement!, this);\n\n    if (!this._isInnerZone) {\n      if (this.windowElement && !outerZones.getOutZone(this.windowElement)) {\n        this.windowElement.removeEventListener('keydown', _onKeyDownCapture, true);\n      }\n    }\n\n    if (this._root.current) {\n      this._root.current.removeEventListener('blur', this._onBlur, true);\n    }\n\n    this._activeElement = null;\n    this._defaultFocusElement = null;\n  }\n\n  render() {\n    const { className } = this.props;\n\n    const ElementType = getElementType(this.props);\n    const unhandledProps = getUnhandledProps(_.keys(FocusZone.propTypes) as any, this.props);\n\n    // Note, right before rendering/reconciling proceeds, we need to record if focus\n    // was in the zone before the update. This helper will track this and, if focus\n    // was actually in the zone, what the index path to the element is at this time.\n    // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n    // the case the element was removed.\n    this.evaluateFocusBeforeRender();\n    return (\n      <ElementType\n        {...unhandledProps}\n        ref={this.setRef}\n        className={cx(FocusZone.className, className)}\n        data-focuszone-id={this._id}\n        onKeyDown={this._onKeyDown}\n        onFocus={this._onFocus}\n        onMouseDownCapture={this._onMouseDown}\n      >\n        {this.props.children}\n      </ElementType>\n    );\n  }\n\n  /**\n   * Sets focus to the first tabbable item in the zone.\n   * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focus(forceIntoFirstElement: boolean = false): boolean {\n    if (this._root.current) {\n      if (\n        !forceIntoFirstElement &&\n        this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        this._isInnerZone\n      ) {\n        const ownerZoneElement = this.getOwnerZone(this._root.current) as HTMLElement;\n\n        if (ownerZoneElement !== this._root.current) {\n          const ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n\n          return !!ownerZone && ownerZone.focusElement(this._root.current);\n        }\n\n        return false;\n      }\n      if (\n        !forceIntoFirstElement &&\n        this._activeElement &&\n        elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS) &&\n        isElementTabbable(this._activeElement)\n      ) {\n        this._activeElement.focus();\n        return true;\n      }\n\n      const firstChild = this._root.current.firstChild as HTMLElement;\n\n      return this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement);\n    }\n    return false;\n  }\n\n  /**\n   * Sets focus to the last tabbable item in the zone.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusLast(): boolean {\n    if (this._root.current) {\n      const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n\n      return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement);\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets focus to a specific child element within the zone. This can be used in conjunction with\n   * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n   * location and then focus.)\n   * @param element - The child element within the zone to focus.\n   * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n   * @returns True if focus could be set to an active element, false if no operation was taken.\n   */\n  focusElement(element: HTMLElement, forceAlignment?: boolean): boolean {\n    const { shouldReceiveFocus } = this.props;\n\n    if (shouldReceiveFocus && !shouldReceiveFocus(element)) {\n      return false;\n    }\n\n    if (element) {\n      this.setActiveElement(element, forceAlignment);\n      if (this._activeElement) {\n        this._activeElement.focus();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  setRef = (elem: HTMLElement): void => {\n    this._root.current = elem;\n    handleRef(this.props.innerRef, elem);\n    if (process.env.NODE_ENV !== 'production') {\n      if (elem !== null && !(elem?.nodeType === 1)) {\n        throw new Error(\n          'FocusZone: we expect that ElementType (\"as\" prop) will be a plain element (div, span, etc.) or an element that supports ref forwarding (React.forwardRef())',\n        );\n      }\n    }\n  };\n\n  // Record if focus was in the zone, what the index path to the element is at this time.\n  evaluateFocusBeforeRender(): void {\n    if (!this._root.current) {\n      return;\n    }\n    const doc = getDocument(this._root.current);\n\n    if (!doc) {\n      return;\n    }\n\n    const focusedElement = doc.activeElement as HTMLElement;\n\n    // Only update the index path if we are not parked on the root.\n    if (focusedElement !== this._root.current) {\n      const shouldRestoreFocus = elementContains(this._root.current, focusedElement, ALLOW_VIRTUAL_ELEMENTS);\n\n      this._lastIndexPath = shouldRestoreFocus\n        ? getElementIndexPath(this._root.current as HTMLElement, doc.activeElement as HTMLElement)\n        : undefined;\n    }\n  }\n\n  /**\n   * When focus is in the zone at render time but then all focusable elements are removed,\n   * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n   * focus to the closest path from previous. If the user tabs away from the parked container,\n   * we restore focusability to the pre-parked state.\n   */\n  setParkedFocus(isParked: boolean): void {\n    if (this._root.current && this._isParked !== isParked) {\n      this._isParked = isParked;\n\n      if (isParked) {\n        if (!this.props.allowFocusRoot) {\n          this._parkedTabIndex = this._root.current.getAttribute('tabindex');\n          this._root.current.setAttribute('tabindex', '-1');\n        }\n        this._root.current.focus();\n      } else if (!this.props.allowFocusRoot) {\n        if (this._parkedTabIndex) {\n          this._root.current.setAttribute('tabindex', this._parkedTabIndex);\n          this._parkedTabIndex = undefined;\n        } else {\n          this._root.current.removeAttribute('tabindex');\n        }\n      }\n    }\n  }\n\n  _onBlur = () => {\n    this.setParkedFocus(false);\n  };\n\n  _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    const {\n      onActiveElementChanged,\n      stopFocusPropagation,\n      shouldFocusInnerElementWhenReceivedFocus,\n      defaultTabbableElement,\n      shouldIgnoreNotFocusable,\n    } = this.props;\n\n    if (shouldIgnoreNotFocusable && ev.target?.dataset.isFocusable === 'false') {\n      return;\n    }\n\n    let newActiveElement: HTMLElement | null | undefined;\n    const isImmediateDescendant = this.isImmediateDescendantOfZone(ev.target as HTMLElement);\n\n    if (isImmediateDescendant) {\n      newActiveElement = ev.target as HTMLElement;\n    } else {\n      let parentElement = ev.target as HTMLElement;\n\n      while (parentElement && parentElement !== this._root.current) {\n        if (isElementTabbable(parentElement) && this.isImmediateDescendantOfZone(parentElement)) {\n          newActiveElement = parentElement;\n          break;\n        }\n        parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n      }\n    }\n\n    // If an inner focusable element should be focused when FocusZone container receives focus\n    if (shouldFocusInnerElementWhenReceivedFocus && ev.target === this._root.current) {\n      const maybeElementToFocus =\n        defaultTabbableElement &&\n        typeof defaultTabbableElement === 'function' &&\n        this._root.current &&\n        defaultTabbableElement(this._root.current);\n\n      // try to focus defaultTabbable element\n      if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {\n        newActiveElement = maybeElementToFocus;\n        maybeElementToFocus.focus();\n      } else {\n        // force focus on first focusable element\n        this.focus(true);\n        if (this._activeElement) {\n          // set to null as new active element was handled in method above\n\n          newActiveElement = null;\n        }\n      }\n    }\n\n    if (newActiveElement && newActiveElement !== this._activeElement) {\n      this._activeElement = newActiveElement;\n\n      if (isImmediateDescendant) {\n        this.setFocusAlignment(this._activeElement);\n        this.updateTabIndexes();\n      }\n    }\n\n    if (onActiveElementChanged) {\n      onActiveElementChanged(this._activeElement as HTMLElement, ev);\n    }\n\n    if (stopFocusPropagation) {\n      ev.stopPropagation();\n    }\n\n    _.invoke(this.props, 'onFocus', ev);\n  };\n\n  _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { disabled } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    let target = ev.target as HTMLElement;\n    const path: HTMLElement[] = [];\n\n    while (target && target !== this._root.current) {\n      path.push(target);\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    }\n\n    while (path.length) {\n      target = path.pop() as HTMLElement;\n\n      if (target && isElementTabbable(target)) {\n        this.setActiveElement(target, true);\n      }\n\n      if (isElementFocusZone(target)) {\n        // Stop here since the focus zone will take care of its own children.\n        break;\n      }\n    }\n  };\n\n  setActiveElement(element: HTMLElement, forceAlignment?: boolean): void {\n    const previousActiveElement = this._activeElement;\n\n    this._activeElement = element;\n\n    if (previousActiveElement) {\n      if (isElementFocusZone(previousActiveElement)) {\n        this.updateTabIndexes(previousActiveElement);\n      }\n\n      previousActiveElement.tabIndex = -1;\n    }\n\n    if (this._activeElement) {\n      if (!this._focusAlignment || forceAlignment) {\n        this.setFocusAlignment(element, true, true);\n      }\n\n      this._activeElement.tabIndex = 0;\n    }\n  }\n\n  preventDefaultWhenHandled(ev: React.KeyboardEvent<HTMLElement>): void {\n    this.props.preventDefaultWhenHandled && ev.preventDefault();\n  }\n\n  /**\n   * Handle the keystrokes.\n   */\n  _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean | undefined => {\n    const { direction, disabled, shouldEnterInnerZone, pagingSupportDisabled } = this.props;\n\n    if (disabled) {\n      return undefined;\n    }\n\n    const doc = getDocument(this._root.current);\n\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // @ts-ignore\n    if (doc.activeElement === this._root.current && this._isInnerZone) {\n      // If this element has focus, it is being controlled by a parent.\n      // Ignore the keystroke.\n      return undefined;\n    }\n\n    // If the default has been prevented, do not process keyboard events.\n    if (ev.isDefaultPrevented()) {\n      return undefined;\n    }\n\n    if (\n      shouldEnterInnerZone &&\n      shouldEnterInnerZone(ev) &&\n      this.isImmediateDescendantOfZone(ev.target as HTMLElement)\n    ) {\n      // Try to focus\n      const innerZone = this.getFirstInnerZone();\n\n      if (innerZone) {\n        if (!innerZone.focus(true)) {\n          return undefined;\n        }\n      } else if (isElementFocusSubZone(ev.target as HTMLElement)) {\n        if (\n          !this.focusElement(\n            getNextElement(\n              ev.target as HTMLElement,\n              (ev.target as HTMLElement).firstChild as HTMLElement,\n              true,\n            ) as HTMLElement,\n          )\n        ) {\n          return undefined;\n        }\n      } else {\n        return undefined;\n      }\n    } else if (ev.altKey) {\n      return undefined;\n    } else {\n      switch (getCode(ev)) {\n        case SpacebarKey:\n          // @ts-ignore\n          if (this.tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.ArrowLeft:\n          if (direction !== FocusZoneDirection.vertical) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusLeft()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowRight:\n          if (direction !== FocusZoneDirection.vertical) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusRight()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowUp:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusUp()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.ArrowDown:\n          if (direction !== FocusZoneDirection.horizontal) {\n            this.preventDefaultWhenHandled(ev);\n            if (this.moveFocusDown()) {\n              break;\n            }\n          }\n          return undefined;\n\n        case keyboardKey.PageDown:\n          if (!pagingSupportDisabled && this.moveFocusPaging(true)) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.PageUp:\n          if (!pagingSupportDisabled && this.moveFocusPaging(false)) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.Tab:\n          if (\n            this.props.handleTabKey === FocusZoneTabbableElements.all ||\n            (this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n              this.isElementInput(ev.target as HTMLElement))\n          ) {\n            let focusChanged = false;\n            this._processingTabKey = true;\n            if (\n              direction === FocusZoneDirection.vertical ||\n              !this.shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP)\n            ) {\n              focusChanged = ev.shiftKey ? this.moveFocusUp() : this.moveFocusDown();\n            } else {\n              const tabWithDirection = this.props.isRtl ? !ev.shiftKey : ev.shiftKey;\n              focusChanged = tabWithDirection ? this.moveFocusLeft() : this.moveFocusRight();\n            }\n            this._processingTabKey = false;\n            if (focusChanged) {\n              break;\n            }\n          } else if (this.props.shouldResetActiveElementWhenTabFromZone) {\n            this._activeElement = null;\n          }\n          return undefined;\n\n        case keyboardKey.Home:\n          if (\n            this.isContentEditableElement(ev.target as HTMLElement) ||\n            (this.isElementInput(ev.target as HTMLElement) &&\n              !this.shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n          const firstChild = this._root.current && (this._root.current.firstChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            firstChild &&\n            this.focusElement(getNextElement(this._root.current, firstChild, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.End:\n          if (\n            this.isContentEditableElement(ev.target as HTMLElement) ||\n            (this.isElementInput(ev.target as HTMLElement) &&\n              !this.shouldInputLoseFocus(ev.target as HTMLInputElement, false))\n          ) {\n            return false;\n          }\n\n          const lastChild = this._root.current && (this._root.current.lastChild as HTMLElement | null);\n          if (\n            this._root.current &&\n            this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true) as HTMLElement)\n          ) {\n            break;\n          }\n          return undefined;\n\n        case keyboardKey.Enter:\n          // @ts-ignore\n          if (this.tryInvokeClickForFocusable(ev.target as HTMLElement, ev)) {\n            break;\n          }\n          return undefined;\n\n        default:\n          return undefined;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n\n    return undefined;\n  };\n\n  /**\n   * Walk up the dom try to find a focusable element.\n   */\n  tryInvokeClickForFocusable(targetElement: HTMLElement, ev?: React.KeyboardEvent<HTMLElement>): boolean {\n    let target = targetElement;\n\n    if (target === this._root.current || !this.props.shouldRaiseClicks) {\n      return false;\n    }\n\n    do {\n      if (\n        target.tagName === 'BUTTON' ||\n        target.tagName === 'A' ||\n        target.tagName === 'INPUT' ||\n        target.tagName === 'TEXTAREA'\n      ) {\n        return false;\n      }\n\n      if (\n        this.isImmediateDescendantOfZone(target) &&\n        target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n        target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true'\n      ) {\n        _raiseClickFromKeyboardEvent(target, ev);\n        return true;\n      }\n\n      target = getParent(target, ALLOW_VIRTUAL_ELEMENTS) as HTMLElement;\n    } while (target !== this._root.current);\n\n    return false;\n  }\n\n  /**\n   * Traverse to find first child zone.\n   */\n  getFirstInnerZone(forRootElement?: HTMLElement | null): FocusZone | null {\n    const rootElement = forRootElement || this._activeElement || this._root.current;\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (isElementFocusZone(rootElement)) {\n      return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n    }\n\n    let child = rootElement.firstElementChild as HTMLElement | null;\n\n    while (child) {\n      if (isElementFocusZone(child)) {\n        return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE) as string];\n      }\n      const match = this.getFirstInnerZone(child);\n\n      if (match) {\n        return match;\n      }\n\n      child = child.nextElementSibling as HTMLElement | null;\n    }\n\n    return null;\n  }\n\n  moveFocus(\n    isForward: boolean,\n    getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number,\n    // @ts-ignore\n    ev?: Event,\n    useDefaultWrap: boolean = true,\n  ): boolean {\n    let element = this._activeElement;\n    let candidateDistance = -1;\n    let candidateElement: HTMLElement | undefined = undefined;\n    let changedFocus = false;\n    const isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n\n    if (!element || !this._root.current) {\n      return false;\n    }\n\n    if (this.isElementInput(element)) {\n      if (!this.shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n\n    const activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n\n    do {\n      element = (isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element)) as HTMLElement;\n\n      if (isBidirectional) {\n        if (element) {\n          const targetRect = element.getBoundingClientRect();\n          const elementDistance = getDistanceFromCenter(activeRect as ClientRect, targetRect);\n\n          if (elementDistance === -1 && candidateDistance === -1) {\n            candidateElement = element;\n            break;\n          }\n\n          if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n\n          if (candidateDistance >= 0 && elementDistance < 0) {\n            break;\n          }\n        }\n      } else {\n        candidateElement = element;\n        break;\n      }\n    } while (element);\n\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n\n    return changedFocus;\n  }\n\n  moveFocusDown(): boolean {\n    let targetTop = -1;\n    const leftAlignment = this._focusAlignment.left;\n\n    if (\n      this.moveFocus(true, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n\n        if (targetRectTop < activeRectBottom) {\n          if (!this.shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusUp(): boolean {\n    let targetTop = -1;\n    const leftAlignment = this._focusAlignment.left;\n\n    if (\n      this.moveFocus(false, (activeRect: ClientRect, targetRect: ClientRect) => {\n        let distance = -1;\n        // ClientRect values can be floats that differ by very small fractions of a decimal.\n        // If the difference between top and bottom are within a pixel then we should treat\n        // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n        // but without Math.Floor they will be handled incorrectly.\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectTop = Math.floor(activeRect.top);\n\n        if (targetRectBottom > activeRectTop) {\n          if (!this.shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n            return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n          return LARGE_DISTANCE_FROM_CENTER;\n        }\n\n        if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n          targetTop = targetRectTop;\n          if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n            distance = 0;\n          } else {\n            distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n          }\n        }\n\n        return distance;\n      })\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusLeft(): boolean {\n    const shouldWrap = this.shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this.moveFocus(\n        // @ts-ignore\n        this.props.isRtl,\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (this.props.isRtl) {\n            // When in RTL, this comparison should be the same as the one in moveFocusRight for LTR.\n            // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n            // This is important, because we want to be comparing the top of the target rect\n            // with the bottom of the active rect.\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.right <= activeRect.right &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = activeRect.right - targetRect.right;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /* ev */,\n        shouldWrap,\n      )\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  moveFocusRight(): boolean {\n    const shouldWrap = this.shouldWrapFocus(this._activeElement as HTMLElement, NO_HORIZONTAL_WRAP);\n    if (\n      this.moveFocus(\n        !this.props.isRtl,\n        (activeRect: ClientRect, targetRect: ClientRect) => {\n          let distance = -1;\n          let topBottomComparison;\n\n          if (this.props.isRtl) {\n            // When in RTL, this comparison should be the same as the one in moveFocusLeft for LTR.\n            // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n            // This is important, because we want to be comparing the bottom of the target rect\n            // with the top of the active rect.\n            topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n          } else {\n            topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n          }\n\n          if (\n            topBottomComparison &&\n            targetRect.left >= activeRect.left &&\n            this.props.direction !== FocusZoneDirection.vertical\n          ) {\n            distance = targetRect.left - activeRect.left;\n          } else if (!shouldWrap) {\n            distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n          }\n\n          return distance;\n        },\n        undefined /* ev */,\n        shouldWrap,\n      )\n    ) {\n      this.setFocusAlignment(this._activeElement as HTMLElement, true, false);\n      return true;\n    }\n\n    return false;\n  }\n\n  getHorizontalDistanceFromCenter = (isForward: boolean, activeRect: ClientRect, targetRect: ClientRect): number => {\n    const leftAlignment = this._focusAlignment.left;\n    // ClientRect values can be floats that differ by very small fractions of a decimal.\n    // If the difference between top and bottom are within a pixel then we should treat\n    // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n    // but without Math.Floor they will be handled incorrectly.\n    const targetRectTop = Math.floor(targetRect.top);\n    const activeRectBottom = Math.floor(activeRect.bottom);\n    const targetRectBottom = Math.floor(targetRect.bottom);\n    const activeRectTop = Math.floor(activeRect.top);\n    const isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n    const isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n\n    if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n      if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n        return 0;\n      }\n      return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n    }\n\n    if (!this.shouldWrapFocus(this._activeElement as HTMLElement, NO_VERTICAL_WRAP)) {\n      return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n    }\n    return LARGE_DISTANCE_FROM_CENTER;\n  };\n\n  moveFocusPaging(isForward: boolean, useDefaultWrap: boolean = true): boolean {\n    let element = this._activeElement;\n    if (!element || !this._root.current) {\n      return false;\n    }\n    if (this.isElementInput(element)) {\n      if (!this.shouldInputLoseFocus(element as HTMLInputElement, isForward)) {\n        return false;\n      }\n    }\n    const scrollableParent = findScrollableParent(element);\n    if (!scrollableParent) {\n      return false;\n    }\n    let candidateDistance = -1;\n    let candidateElement = undefined;\n    let targetTop = -1;\n    let targetBottom = -1;\n    const pagesize = (scrollableParent as HTMLElement).clientHeight;\n    const activeRect = element.getBoundingClientRect();\n    do {\n      element = isForward\n        ? getNextElement(this._root.current, element)\n        : getPreviousElement(this._root.current, element);\n      if (element) {\n        const targetRect = element.getBoundingClientRect();\n        const targetRectTop = Math.floor(targetRect.top);\n        const activeRectBottom = Math.floor(activeRect.bottom);\n        const targetRectBottom = Math.floor(targetRect.bottom);\n        const activeRectTop = Math.floor(activeRect.top);\n        const elementDistance = this.getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n        const isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n        const isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n\n        if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n          break;\n        }\n        if (elementDistance > -1) {\n          // for paging down\n          if (isForward && targetRectTop > targetTop) {\n            targetTop = targetRectTop;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (!isForward && targetRectBottom < targetBottom) {\n            // for paging up\n            targetBottom = targetRectBottom;\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n            candidateDistance = elementDistance;\n            candidateElement = element;\n          }\n        }\n      }\n    } while (element);\n\n    let changedFocus = false;\n    // Focus the closest candidate\n    if (candidateElement && candidateElement !== this._activeElement) {\n      changedFocus = true;\n      this.focusElement(candidateElement);\n      this.setFocusAlignment(candidateElement as HTMLElement, false, true);\n    } else if (this.props.isCircularNavigation && useDefaultWrap) {\n      if (isForward) {\n        return this.focusElement(\n          getNextElement(this._root.current, this._root.current.firstElementChild as HTMLElement, true) as HTMLElement,\n        );\n      }\n      return this.focusElement(\n        getPreviousElement(\n          this._root.current,\n          this._root.current.lastElementChild as HTMLElement,\n          true,\n          true,\n          true,\n        ) as HTMLElement,\n      );\n    }\n    return changedFocus;\n  }\n\n  setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean) {\n    if (\n      this.props.direction === FocusZoneDirection.bidirectional &&\n      (!this._focusAlignment || isHorizontal || isVertical)\n    ) {\n      const rect = element.getBoundingClientRect();\n      const left = rect.left + rect.width / 2;\n      const top = rect.top + rect.height / 2;\n\n      if (!this._focusAlignment) {\n        this._focusAlignment = { left, top };\n      }\n\n      if (isHorizontal) {\n        this._focusAlignment.left = left;\n      }\n\n      if (isVertical) {\n        this._focusAlignment.top = top;\n      }\n    }\n  }\n\n  isImmediateDescendantOfZone(element?: HTMLElement): boolean {\n    return this.getOwnerZone(element) === this._root.current;\n  }\n\n  getOwnerZone(element?: HTMLElement): HTMLElement | null {\n    const doc = getDocument(this._root.current);\n    let parentElement = getParent(element as HTMLElement, ALLOW_VIRTUAL_ELEMENTS);\n\n    // @ts-ignore\n    while (parentElement && parentElement !== this._root.current && parentElement !== doc.body) {\n      if (isElementFocusZone(parentElement)) {\n        return parentElement;\n      }\n\n      parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n    }\n\n    return this._root.current;\n  }\n\n  updateTabIndexes(onElement?: HTMLElement) {\n    let element = onElement;\n\n    if (\n      !this._activeElement &&\n      this.props.defaultTabbableElement &&\n      typeof this.props.defaultTabbableElement === 'function'\n    ) {\n      this._activeElement = this.props.defaultTabbableElement(this._root.current as HTMLElement);\n    }\n\n    if (!element && this._root.current) {\n      this._defaultFocusElement = null;\n      element = this._root.current;\n      if (this._activeElement && !elementContains(element, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) {\n        this._activeElement = null;\n      }\n    }\n\n    // If active element changes state to disabled, set it to null.\n    // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n    if (this._activeElement && !isElementTabbable(this._activeElement)) {\n      this._activeElement = null;\n    }\n\n    const childNodes = element && element.children;\n\n    for (let childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n      const child = childNodes[childIndex] as HTMLElement;\n\n      if (!isElementFocusZone(child)) {\n        // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n        if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n\n        if (isElementTabbable(child)) {\n          if (this.props.disabled) {\n            child.setAttribute(TABINDEX, '-1');\n          } else if (\n            !this._isInnerZone &&\n            ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n          ) {\n            this._defaultFocusElement = child;\n            if (child.getAttribute(TABINDEX) !== '0') {\n              child.setAttribute(TABINDEX, '0');\n            }\n          } else if (child.getAttribute(TABINDEX) !== '-1') {\n            child.setAttribute(TABINDEX, '-1');\n          }\n        } else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n          // Disgusting IE hack. Sad face.\n          child.setAttribute('focusable', 'false');\n        }\n      } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n        if (\n          !this._isInnerZone &&\n          ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)\n        ) {\n          this._defaultFocusElement = child;\n          if (child.getAttribute(TABINDEX) !== '0') {\n            child.setAttribute(TABINDEX, '0');\n          }\n        } else if (child.getAttribute(TABINDEX) !== '-1') {\n          child.setAttribute(TABINDEX, '-1');\n        }\n      }\n\n      this.updateTabIndexes(child);\n    }\n  }\n\n  isContentEditableElement(element: HTMLElement): boolean {\n    return element && element.getAttribute('contenteditable') === 'true';\n  }\n\n  isElementInput(element: HTMLElement): boolean {\n    if (\n      element &&\n      element.tagName &&\n      (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  shouldInputLoseFocus(element: HTMLInputElement, isForward?: boolean) {\n    // If a tab was used, we want to focus on the next element.\n    if (\n      !this._processingTabKey &&\n      element &&\n      element.type &&\n      ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1\n    ) {\n      const selectionStart = element.selectionStart;\n      const selectionEnd = element.selectionEnd;\n      const isRangeSelected = selectionStart !== selectionEnd;\n      const inputValue = element.value;\n      const isReadonly = element.readOnly;\n\n      // We shouldn't lose focus in the following cases:\n      // 1. There is range selected.\n      // 2. When selection start is larger than 0 and it is backward and not readOnly.\n      // 3. when selection start is not the end of length and it is forward and not readOnly.\n      // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit tab)\n      // and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is determined by calling the\n      // callback shouldInputLoseFocusOnArrowKey\n      if (\n        isRangeSelected ||\n        (selectionStart! > 0 && !isForward && !isReadonly) ||\n        (selectionStart !== inputValue.length && isForward && !isReadonly) ||\n        (!!this.props.handleTabKey &&\n          !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  shouldWrapFocus(\n    element: HTMLElement,\n    noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n  ): boolean {\n    return !!this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n  }\n\n  getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"],"file":"FocusZone.js"}