"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var React = require("react");
var ReactDOM = require("react-dom");
var ReactTestUtils = require("react-dom/test-utils");
var test_utils_1 = require("./test-utils");
// rAF does not exist in node - let's mock it
window.requestAnimationFrame = function (callback) {
    var r = window.setTimeout(callback, 0);
    ReactTestUtils.act(function () {
        jest.runAllTimers();
    });
    return r;
};
// ReactTestUtils.act(() => {
jest.useFakeTimers();
// });
var FocusTrapZoneTestComponent = /** @class */ (function (_super) {
    __extends(FocusTrapZoneTestComponent, _super);
    function FocusTrapZoneTestComponent(props) {
        var _this = _super.call(this, props) || this;
        _this._toggleFirst = function () { return _this.setState({ isShowingFirst: !_this.state.isShowingFirst }); };
        _this._toggleSecond = function () { return _this.setState({ isShowingSecond: !_this.state.isShowingSecond }); };
        _this.state = { isShowingFirst: false, isShowingSecond: false };
        return _this;
    }
    FocusTrapZoneTestComponent.prototype.render = function () {
        return (React.createElement("div", null,
            React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: true, isClickableOutsideFocusTrap: false },
                React.createElement("button", { className: 'a', onClick: this._toggleFirst }, "a"),
                React.createElement("button", { className: 'b', onClick: this._toggleSecond }, "b")),
            this.state.isShowingFirst && (React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, isClickableOutsideFocusTrap: false },
                React.createElement(react_bindings_1.FocusZone, { "data-is-visible": true }, "First"))),
            this.state.isShowingSecond && (React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, isClickableOutsideFocusTrap: true },
                React.createElement(react_bindings_1.FocusZone, { "data-is-visible": true }, "First")))));
    };
    return FocusTrapZoneTestComponent;
}(React.Component));
describe('FocusTrapZone', function () {
    // document.activeElement can be used to detect activeElement after component mount, but it does not
    // update based on focus events due to limitations of ReactDOM. Use lastFocusedElement to detect focus
    // change events.
    var lastFocusedElement;
    var ftzClassname = 'ftzTestClassname';
    function _onFocus(ev) {
        lastFocusedElement = ev.target;
    }
    function setupElement(element, _a) {
        var clientRect = _a.clientRect, _b = _a.isVisible, isVisible = _b === void 0 ? true : _b;
        ReactTestUtils.act(function () {
            element.getBoundingClientRect = function () {
                return ({
                    top: clientRect.top,
                    left: clientRect.left,
                    bottom: clientRect.bottom,
                    right: clientRect.right,
                    width: clientRect.right - clientRect.left,
                    height: clientRect.bottom - clientRect.top,
                });
            };
            element.setAttribute('data-is-visible', String(isVisible));
            element.focus = function () { return ReactTestUtils.Simulate.focus(element); };
        });
    }
    /**
     * Helper to get FocusTrapZone bumpers. Requires classname attribute of
     * 'ftzClassname' on FTZ.
     */
    function getFtzBumpers(element) {
        var ftz = element.querySelector("." + ftzClassname);
        var ftzNodes = ftz.children;
        var firstBumper = ftzNodes[0];
        var lastBumper = ftzNodes[ftzNodes.length - 1];
        return { firstBumper: firstBumper, lastBumper: lastBumper };
    }
    beforeEach(function () {
        lastFocusedElement = undefined;
    });
    afterAll(function () {
        window.addEventListener = addEventListener;
    });
    describe('Tab and shift-tab wrap at extreme ends of the FTZ', function () {
        it('can tab across FocusZones with different button structures', function () { return __awaiter(void 0, void 0, void 0, function () {
            var topLevelDiv, buttonA, buttonB, buttonC, buttonD, buttonE, buttonF, _a, firstBumper, lastBumper;
            return __generator(this, function (_b) {
                expect.assertions(3);
                topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                    React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, className: ftzClassname },
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("button", { className: "a" }, "a")),
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("button", { className: "b" }, "b")),
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("button", { className: "c" }, "c"))),
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("div", { "data-is-visible": true },
                                    React.createElement("button", { className: "d" }, "d"),
                                    React.createElement("button", { className: "e" }, "e"),
                                    React.createElement("button", { className: "f" }, "f")))))));
                buttonA = topLevelDiv.querySelector('.a');
                buttonB = topLevelDiv.querySelector('.b');
                buttonC = topLevelDiv.querySelector('.c');
                buttonD = topLevelDiv.querySelector('.d');
                buttonE = topLevelDiv.querySelector('.e');
                buttonF = topLevelDiv.querySelector('.f');
                // Assign bounding locations to buttons.
                setupElement(buttonA, { clientRect: { top: 0, bottom: 30, left: 0, right: 30 } });
                setupElement(buttonB, { clientRect: { top: 0, bottom: 30, left: 30, right: 60 } });
                setupElement(buttonC, { clientRect: { top: 0, bottom: 30, left: 60, right: 90 } });
                setupElement(buttonD, { clientRect: { top: 30, bottom: 60, left: 0, right: 30 } });
                setupElement(buttonE, { clientRect: { top: 30, bottom: 60, left: 30, right: 60 } });
                setupElement(buttonF, { clientRect: { top: 30, bottom: 60, left: 60, right: 90 } });
                _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
                ReactTestUtils.Simulate.focus(buttonA);
                expect(lastFocusedElement).toBe(buttonA);
                // Simulate shift+tab event which would focus first bumper
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonD);
                // Simulate tab event which would focus last bumper
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
        it('can tab across a FocusZone with different button structures', function () { return __awaiter(void 0, void 0, void 0, function () {
            var topLevelDiv, buttonX, buttonA, buttonB, buttonC, buttonD, _a, firstBumper, lastBumper;
            return __generator(this, function (_b) {
                expect.assertions(3);
                topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                    React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, className: ftzClassname },
                        React.createElement("div", { "data-is-visible": true },
                            React.createElement("button", { className: "x" }, "x")),
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("button", { className: "a" }, "a")),
                            React.createElement("div", { "data-is-visible": true },
                                React.createElement("div", { "data-is-visible": true },
                                    React.createElement("button", { className: "b" }, "b"),
                                    React.createElement("button", { className: "c" }, "c"),
                                    React.createElement("button", { className: "d" }, "d")))))));
                buttonX = topLevelDiv.querySelector('.x');
                buttonA = topLevelDiv.querySelector('.a');
                buttonB = topLevelDiv.querySelector('.b');
                buttonC = topLevelDiv.querySelector('.c');
                buttonD = topLevelDiv.querySelector('.d');
                _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
                // Assign bounding locations to buttons.
                setupElement(buttonX, { clientRect: { top: 0, bottom: 30, left: 0, right: 30 } });
                setupElement(buttonA, { clientRect: { top: 0, bottom: 30, left: 0, right: 30 } });
                setupElement(buttonB, { clientRect: { top: 0, bottom: 30, left: 30, right: 60 } });
                setupElement(buttonC, { clientRect: { top: 0, bottom: 30, left: 60, right: 90 } });
                setupElement(buttonD, { clientRect: { top: 30, bottom: 60, left: 0, right: 30 } });
                ReactTestUtils.Simulate.focus(buttonX);
                expect(lastFocusedElement).toBe(buttonX);
                // Simulate shift+tab event which would focus first bumper
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonA);
                // Simulate tab event which would focus last bumper
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonX);
                return [2 /*return*/];
            });
        }); });
        it('can trap focus when FTZ bookmark elements are FocusZones, and those elements have inner elements focused that are not the first inner element', function () { return __awaiter(void 0, void 0, void 0, function () {
            var topLevelDiv, buttonZ1, buttonA, buttonB, buttonC, buttonD, buttonE, buttonF, buttonG, buttonZ2, _a, firstBumper, lastBumper;
            return __generator(this, function (_b) {
                expect.assertions(4);
                topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                    React.createElement("button", { className: 'z1' }, "z1"),
                    React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, className: ftzClassname },
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("button", { className: 'a' }, "a"),
                            React.createElement("button", { className: 'b' }, "b"),
                            React.createElement("button", { className: 'c' }, "c")),
                        React.createElement("button", { className: 'd' }, "d"),
                        React.createElement(react_bindings_1.FocusZone, { direction: accessibility_1.FocusZoneDirection.horizontal, "data-is-visible": true },
                            React.createElement("button", { className: 'e' }, "e"),
                            React.createElement("button", { className: 'f' }, "f"),
                            React.createElement("button", { className: 'g' }, "g"))),
                    React.createElement("button", { className: 'z2' }, "z2")));
                buttonZ1 = topLevelDiv.querySelector('.z1');
                buttonA = topLevelDiv.querySelector('.a');
                buttonB = topLevelDiv.querySelector('.b');
                buttonC = topLevelDiv.querySelector('.c');
                buttonD = topLevelDiv.querySelector('.d');
                buttonE = topLevelDiv.querySelector('.e');
                buttonF = topLevelDiv.querySelector('.f');
                buttonG = topLevelDiv.querySelector('.g');
                buttonZ2 = topLevelDiv.querySelector('.z2');
                _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
                // Assign bounding locations to buttons.
                setupElement(buttonZ1, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
                setupElement(buttonA, { clientRect: { top: 10, bottom: 30, left: 0, right: 10 } });
                setupElement(buttonB, { clientRect: { top: 10, bottom: 30, left: 10, right: 20 } });
                setupElement(buttonC, { clientRect: { top: 10, bottom: 30, left: 20, right: 30 } });
                setupElement(buttonD, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
                setupElement(buttonE, { clientRect: { top: 40, bottom: 60, left: 0, right: 10 } });
                setupElement(buttonF, { clientRect: { top: 40, bottom: 60, left: 10, right: 20 } });
                setupElement(buttonG, { clientRect: { top: 40, bottom: 60, left: 20, right: 30 } });
                setupElement(buttonZ2, { clientRect: { top: 60, bottom: 70, left: 0, right: 10 } });
                // Focus the middle button in the first FZ.
                ReactTestUtils.Simulate.focus(buttonA);
                ReactTestUtils.Simulate.keyDown(buttonA, { which: accessibility_1.keyboardKey.ArrowRight });
                expect(lastFocusedElement).toBe(buttonB);
                // Focus the middle button in the second FZ.
                ReactTestUtils.Simulate.focus(buttonE);
                ReactTestUtils.Simulate.keyDown(buttonE, { which: accessibility_1.keyboardKey.ArrowRight });
                expect(lastFocusedElement).toBe(buttonF);
                // Simulate tab event which would focus last bumper
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonB);
                // Simulate shift+tab event which would focus first bumper
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonF);
                return [2 /*return*/];
            });
        }); });
    });
    describe('Tab and shift-tab do nothing (keep focus where it is) when the FTZ contains 0 tabbable items', function () {
        function setupTest(props) {
            var topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                React.createElement("button", { className: 'z1' }, "z1"),
                React.createElement(react_bindings_1.FocusTrapZone, __assign({ className: ftzClassname, forceFocusInsideTrapOnOutsideFocus: true }, props),
                    React.createElement("button", { className: 'a', tabIndex: -1 }, "a"),
                    React.createElement("button", { className: 'b', tabIndex: -1 }, "b"),
                    React.createElement("button", { className: 'c', tabIndex: -1 }, "c")),
                React.createElement("button", { className: 'z2' }, "z2")));
            var buttonZ1 = topLevelDiv.querySelector('.z1');
            var buttonA = topLevelDiv.querySelector('.a');
            var buttonB = topLevelDiv.querySelector('.b');
            var buttonC = topLevelDiv.querySelector('.c');
            var buttonZ2 = topLevelDiv.querySelector('.z2');
            var _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
            // Have to set bumpers as "visible" for focus utilities to find them.
            // This is needed for 0 tabbable element tests to make sure that next tabbable element
            // from one bumper is the other bumper.
            firstBumper.setAttribute('data-is-visible', String(true));
            lastBumper.setAttribute('data-is-visible', String(true));
            // Assign bounding locations to buttons.
            setupElement(buttonZ1, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
            setupElement(buttonA, { clientRect: { top: 10, bottom: 20, left: 0, right: 10 } });
            setupElement(buttonB, { clientRect: { top: 20, bottom: 30, left: 0, right: 10 } });
            setupElement(buttonC, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
            setupElement(buttonZ2, { clientRect: { top: 40, bottom: 50, left: 0, right: 10 } });
            return { buttonZ1: buttonZ1, buttonA: buttonA, buttonB: buttonB, buttonC: buttonC, buttonZ2: buttonZ2, firstBumper: firstBumper, lastBumper: lastBumper };
        }
        it('focuses first focusable element when focusing first bumper', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, buttonB, buttonA, firstBumper;
            return __generator(this, function (_b) {
                expect.assertions(2);
                _a = setupTest({}), buttonB = _a.buttonB, buttonA = _a.buttonA, firstBumper = _a.firstBumper;
                ReactTestUtils.Simulate.focus(buttonB);
                expect(lastFocusedElement).toBe(buttonB);
                // Simulate shift+tab event which would focus first bumper
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
        it('focuses first focusable element when focusing last bumper', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, buttonA, buttonB, lastBumper;
            return __generator(this, function (_b) {
                expect.assertions(2);
                _a = setupTest({}), buttonA = _a.buttonA, buttonB = _a.buttonB, lastBumper = _a.lastBumper;
                ReactTestUtils.Simulate.focus(buttonB);
                expect(lastFocusedElement).toBe(buttonB);
                // Simulate tab event which would focus last bumper
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
    });
    describe('Focus behavior based on default and explicit prop values', function () {
        function setupTest(props) {
            // data-is-visible is embedded in buttons here for testing focus behavior on initial render.
            // Components have to be marked visible before setupElement has a chance to apply the data-is-visible attribute.
            // const topLevelDiv = ReactTestUtils.renderIntoDocument<{}>(
            var _a = test_utils_1.createTestContainer(), testContainer = _a.testContainer, removeTestContainer = _a.removeTestContainer;
            ReactTestUtils.act(function () {
                ReactDOM.render(React.createElement("div", null,
                    React.createElement("div", { onFocusCapture: _onFocus },
                        React.createElement("button", { className: 'z1' }, "z1"),
                        React.createElement(react_bindings_1.FocusTrapZone, __assign({ "data-is-visible": true }, props, { className: ftzClassname }),
                            React.createElement("button", { className: 'a', "data-is-visible": true }, "a"),
                            React.createElement("button", { className: 'b', "data-is-visible": true }, "b"),
                            React.createElement("button", { className: 'c', "data-is-visible": true }, "c")),
                        React.createElement("button", { className: 'z2' }, "z2"))), testContainer);
            });
            // const topLevelDiv = ReactTestUtils.renderIntoDocument<{}>(
            //   <div>
            //     <div onFocusCapture={_onFocus}>
            //       <button className={'z1'}>z1</button>
            //       <FocusTrapZone data-is-visible={true} {...props} className={ftzClassname}>
            //         <button className={'a'} data-is-visible={true}>
            //           a
            //         </button>
            //         <button className={'b'} data-is-visible={true}>
            //           b
            //         </button>
            //         <button className={'c'} data-is-visible={true}>
            //           c
            //         </button>
            //       </FocusTrapZone>
            //       <button className={'z2'}>z2</button>
            //     </div>
            //   </div>,
            // ) as HTMLElement;
            var buttonZ1 = testContainer.querySelector('.z1');
            var buttonA = testContainer.querySelector('.a');
            var buttonB = testContainer.querySelector('.b');
            var buttonC = testContainer.querySelector('.c');
            var buttonZ2 = testContainer.querySelector('.z2');
            var _b = getFtzBumpers(testContainer), firstBumper = _b.firstBumper, lastBumper = _b.lastBumper;
            // Assign bounding locations to buttons.
            setupElement(buttonZ1, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
            setupElement(buttonA, { clientRect: { top: 10, bottom: 20, left: 0, right: 10 } });
            setupElement(buttonB, { clientRect: { top: 20, bottom: 30, left: 0, right: 10 } });
            setupElement(buttonC, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
            setupElement(buttonZ2, { clientRect: { top: 40, bottom: 50, left: 0, right: 10 } });
            return { buttonZ1: buttonZ1, buttonA: buttonA, buttonB: buttonB, buttonC: buttonC, buttonZ2: buttonZ2, firstBumper: firstBumper, lastBumper: lastBumper, removeTestContainer: removeTestContainer };
        }
        function setupTestOld(props) {
            var topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", null,
                React.createElement("div", { onFocusCapture: _onFocus },
                    React.createElement("button", { className: 'z1' }, "z1"),
                    React.createElement(react_bindings_1.FocusTrapZone, __assign({ "data-is-visible": true }, props, { className: ftzClassname }),
                        React.createElement("button", { className: 'a', "data-is-visible": true }, "a"),
                        React.createElement("button", { className: 'b', "data-is-visible": true }, "b"),
                        React.createElement("button", { className: 'c', "data-is-visible": true }, "c")),
                    React.createElement("button", { className: 'z2' }, "z2"))));
            var buttonZ1 = topLevelDiv.querySelector('.z1');
            var buttonA = topLevelDiv.querySelector('.a');
            var buttonB = topLevelDiv.querySelector('.b');
            var buttonC = topLevelDiv.querySelector('.c');
            var buttonZ2 = topLevelDiv.querySelector('.z2');
            var _a = getFtzBumpers(topLevelDiv), firstBumper = _a.firstBumper, lastBumper = _a.lastBumper;
            // Assign bounding locations to buttons.
            setupElement(buttonZ1, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
            setupElement(buttonA, { clientRect: { top: 10, bottom: 20, left: 0, right: 10 } });
            setupElement(buttonB, { clientRect: { top: 20, bottom: 30, left: 0, right: 10 } });
            setupElement(buttonC, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
            setupElement(buttonZ2, { clientRect: { top: 40, bottom: 50, left: 0, right: 10 } });
            return { buttonZ1: buttonZ1, buttonA: buttonA, buttonB: buttonB, buttonC: buttonC, buttonZ2: buttonZ2, firstBumper: firstBumper, lastBumper: lastBumper };
        }
        it('Focuses first element when FTZ does not have focus and first bumper receives focus', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, buttonA, buttonZ1, firstBumper;
            return __generator(this, function (_b) {
                expect.assertions(2);
                _a = setupTestOld({ isClickableOutsideFocusTrap: true }), buttonA = _a.buttonA, buttonZ1 = _a.buttonZ1, firstBumper = _a.firstBumper;
                ReactTestUtils.Simulate.focus(buttonZ1);
                expect(lastFocusedElement).toBe(buttonZ1);
                ReactTestUtils.Simulate.focus(firstBumper);
                expect(lastFocusedElement).toBe(buttonA);
                return [2 /*return*/];
            });
        }); });
        it('Focuses last element when FTZ does not have focus and last bumper receives focus', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, buttonC, buttonZ2, lastBumper;
            return __generator(this, function (_b) {
                expect.assertions(2);
                _a = setupTestOld({ isClickableOutsideFocusTrap: true }), buttonC = _a.buttonC, buttonZ2 = _a.buttonZ2, lastBumper = _a.lastBumper;
                ReactTestUtils.Simulate.focus(buttonZ2);
                expect(lastFocusedElement).toBe(buttonZ2);
                ReactTestUtils.Simulate.focus(lastBumper);
                expect(lastFocusedElement).toBe(buttonC);
                return [2 /*return*/];
            });
        }); });
        it('Focuses first on mount', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, removeTestContainer, buttonA;
            return __generator(this, function (_b) {
                expect.assertions(1);
                _a = setupTest({}), removeTestContainer = _a.removeTestContainer, buttonA = _a.buttonA;
                expect(document.activeElement).toBe(buttonA);
                removeTestContainer();
                return [2 /*return*/];
            });
        }); });
        it('Does not focus first on mount with disableFirstFocus', function () { return __awaiter(void 0, void 0, void 0, function () {
            var activeElement, removeTestContainer;
            return __generator(this, function (_a) {
                expect.assertions(1);
                activeElement = document.activeElement;
                removeTestContainer = setupTest({ disableFirstFocus: true }).removeTestContainer;
                // document.activeElement can be used to detect activeElement after component mount, but it does not
                // update based on focus events due to limitations of ReactDOM.
                // Make sure activeElement didn't change.
                expect(document.activeElement).toBe(activeElement);
                removeTestContainer();
                return [2 /*return*/];
            });
        }); });
        it('Does not focus first on mount while disabled', function () { return __awaiter(void 0, void 0, void 0, function () {
            var activeElement, removeTestContainer;
            return __generator(this, function (_a) {
                expect.assertions(1);
                activeElement = document.activeElement;
                removeTestContainer = setupTest({ disabled: true }).removeTestContainer;
                // document.activeElement can be used to detect activeElement after component mount, but it does not
                // update based on focus events due to limitations of ReactDOM.
                // Make sure activeElement didn't change.
                expect(document.activeElement).toBe(activeElement);
                removeTestContainer();
                return [2 /*return*/];
            });
        }); });
        it('Focuses on firstFocusableSelector on mount', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, removeTestContainer, buttonC;
            return __generator(this, function (_b) {
                expect.assertions(1);
                _a = setupTest({ firstFocusableSelector: '.c' }), removeTestContainer = _a.removeTestContainer, buttonC = _a.buttonC;
                expect(document.activeElement).toBe(buttonC);
                removeTestContainer();
                return [2 /*return*/];
            });
        }); });
        it('Does not focus on firstFocusableSelector on mount while disabled', function () { return __awaiter(void 0, void 0, void 0, function () {
            var activeElement, removeTestContainer;
            return __generator(this, function (_a) {
                expect.assertions(1);
                activeElement = document.activeElement;
                removeTestContainer = setupTest({ firstFocusableSelector: '.c', disabled: true }).removeTestContainer;
                expect(document.activeElement).toBe(activeElement);
                removeTestContainer();
                return [2 /*return*/];
            });
        }); });
        it('Falls back to first focusable element with invalid firstFocusableSelector', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, buttonA, removeTestContainer;
            return __generator(this, function (_b) {
                _a = setupTest({ firstFocusableSelector: '.invalidSelector' }), buttonA = _a.buttonA, removeTestContainer = _a.removeTestContainer;
                expect(document.activeElement).toBe(buttonA);
                removeTestContainer();
                return [2 /*return*/];
            });
        }); });
    });
    describe('Focusing the FTZ', function () {
        function setupTest(focusPreviouslyFocusedInnerElement) {
            var focusTrapZoneRef = null;
            var topLevelDiv = ReactTestUtils.renderIntoDocument(React.createElement("div", { onFocusCapture: _onFocus },
                React.createElement(react_bindings_1.FocusTrapZone, { forceFocusInsideTrapOnOutsideFocus: false, focusPreviouslyFocusedInnerElement: focusPreviouslyFocusedInnerElement, "data-is-focusable": true, ref: function (ftz) {
                        focusTrapZoneRef = ftz;
                    } },
                    React.createElement("button", { className: 'f' }, "f"),
                    React.createElement(react_bindings_1.FocusZone, null,
                        React.createElement("button", { className: 'a' }, "a"),
                        React.createElement("button", { className: 'b' }, "b"))),
                React.createElement("button", { className: 'z' }, "z")));
            var buttonF = topLevelDiv.querySelector('.f');
            var buttonA = topLevelDiv.querySelector('.a');
            var buttonB = topLevelDiv.querySelector('.b');
            var buttonZ = topLevelDiv.querySelector('.z');
            // Assign bounding locations to buttons.
            setupElement(buttonF, { clientRect: { top: 0, bottom: 10, left: 0, right: 10 } });
            setupElement(buttonA, { clientRect: { top: 10, bottom: 20, left: 0, right: 10 } });
            setupElement(buttonB, { clientRect: { top: 20, bottom: 30, left: 0, right: 10 } });
            setupElement(buttonZ, { clientRect: { top: 30, bottom: 40, left: 0, right: 10 } });
            return { focusTrapZone: focusTrapZoneRef, buttonF: buttonF, buttonA: buttonA, buttonB: buttonB, buttonZ: buttonZ };
        }
        it('goes to previously focused element when focusing the FTZ', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, focusTrapZone, buttonF, buttonB, buttonZ;
            return __generator(this, function (_b) {
                expect.assertions(4);
                _a = setupTest(true /* focusPreviouslyFocusedInnerElement */), focusTrapZone = _a.focusTrapZone, buttonF = _a.buttonF, buttonB = _a.buttonB, buttonZ = _a.buttonZ;
                // By calling `componentDidMount`, FTZ will behave as just initialized and focus needed element
                // @ts-ignore
                focusTrapZone.componentDidMount();
                expect(lastFocusedElement).toBe(buttonF);
                // Focus inside the trap zone, not the first element.
                ReactTestUtils.Simulate.focus(buttonB);
                expect(lastFocusedElement).toBe(buttonB);
                // Focus outside the trap zone
                ReactTestUtils.Simulate.focus(buttonZ);
                expect(lastFocusedElement).toBe(buttonZ);
                // By calling `componentDidMount`, FTZ will behave as just initialized and focus needed element
                // FTZ should return to originally focused inner element.
                // @ts-ignore
                focusTrapZone.componentDidMount();
                expect(lastFocusedElement).toBe(buttonB);
                return [2 /*return*/];
            });
        }); });
        it('goes to first focusable element when focusing the FTZ', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, focusTrapZone, buttonF, buttonB, buttonZ;
            return __generator(this, function (_b) {
                expect.assertions(4);
                _a = setupTest(false /* focusPreviouslyFocusedInnerElement */), focusTrapZone = _a.focusTrapZone, buttonF = _a.buttonF, buttonB = _a.buttonB, buttonZ = _a.buttonZ;
                // By calling `componentDidMount`, FTZ will behave as just initialized and focus needed element
                // Focus within should go to 1st focusable inner element.
                // @ts-ignore
                focusTrapZone.componentDidMount();
                expect(lastFocusedElement).toBe(buttonF);
                // Focus inside the trap zone, not the first element.
                ReactTestUtils.Simulate.focus(buttonB);
                expect(lastFocusedElement).toBe(buttonB);
                // Focus outside the trap zone
                ReactTestUtils.Simulate.focus(buttonZ);
                expect(lastFocusedElement).toBe(buttonZ);
                // By calling `componentDidMount`, FTZ will behave as just initialized and focus needed element
                // Focus should go to the first focusable element
                // @ts-ignore
                focusTrapZone.componentDidMount();
                expect(lastFocusedElement).toBe(buttonF);
                return [2 /*return*/];
            });
        }); });
    });
    describe('Nested FocusTrapZones Stack Behavior', function () {
        var getFocusStack = function () { return react_bindings_1.FocusTrapZone._focusStack; };
        // beforeAll(() => (getFocusStack().length = 0));
        beforeAll(function () {
            react_bindings_1.FocusTrapZone._focusStack = [];
        });
        it.skip('FocusTrapZone maintains a proper stack of FocusTrapZones as more are mounted/unmounted.', function () { return __awaiter(void 0, void 0, void 0, function () {
            var _a, removeTestContainer, testContainer, topLevelDiv, buttonA, buttonB, baseFocusTrapZone, firstFocusTrapZone, secondFocusTrapZone;
            return __generator(this, function (_b) {
                _a = test_utils_1.createTestContainer(), removeTestContainer = _a.removeTestContainer, testContainer = _a.testContainer;
                // let focusTrapZoneFocusStack: FocusTrapZone[] = getFocusStack();
                // const topLevelDiv = ReactTestUtils.renderIntoDocument<{}>(
                ReactTestUtils.act(function () {
                    ReactDOM.render(React.createElement("div", null,
                        React.createElement(FocusTrapZoneTestComponent, null)), testContainer) /*  as HTMLElement */;
                });
                topLevelDiv = testContainer;
                buttonA = topLevelDiv.querySelector('.a');
                buttonB = topLevelDiv.querySelector('.b');
                expect(react_bindings_1.FocusTrapZone._focusStack.length).toBe(2);
                baseFocusTrapZone = react_bindings_1.FocusTrapZone._focusStack[0];
                expect(baseFocusTrapZone.props.forceFocusInsideTrapOnOutsideFocus).toBe(true);
                expect(baseFocusTrapZone.props.isClickableOutsideFocusTrap).toBe(false);
                firstFocusTrapZone = react_bindings_1.FocusTrapZone._focusStack[1];
                expect(firstFocusTrapZone.props.forceFocusInsideTrapOnOutsideFocus).toBe(false);
                expect(firstFocusTrapZone.props.isClickableOutsideFocusTrap).toBe(false);
                // There should be now 3 focus trap zones (base/first/second)
                ReactTestUtils.Simulate.click(buttonB);
                expect(react_bindings_1.FocusTrapZone._focusStack.length).toBe(3);
                expect(react_bindings_1.FocusTrapZone._focusStack[0]).toBe(baseFocusTrapZone);
                expect(react_bindings_1.FocusTrapZone._focusStack[1]).toBe(firstFocusTrapZone);
                secondFocusTrapZone = react_bindings_1.FocusTrapZone._focusStack[2];
                expect(secondFocusTrapZone.props.forceFocusInsideTrapOnOutsideFocus).toBe(false);
                expect(secondFocusTrapZone.props.isClickableOutsideFocusTrap).toBe(true);
                // we remove the middle one
                // unmounting a focus trap zone should remove it from the focus stack.
                // but we also check that it removes the right focustrapzone (the middle one)
                ReactTestUtils.Simulate.click(buttonA);
                react_bindings_1.FocusTrapZone._focusStack = getFocusStack();
                expect(react_bindings_1.FocusTrapZone._focusStack.length).toBe(2);
                expect(react_bindings_1.FocusTrapZone._focusStack[0]).toBe(baseFocusTrapZone);
                expect(react_bindings_1.FocusTrapZone._focusStack[1]).toBe(secondFocusTrapZone);
                ReactTestUtils.act(function () {
                    // finally remove the last focus trap zone.
                    ReactTestUtils.Simulate.click(buttonB);
                    react_bindings_1.FocusTrapZone._focusStack = getFocusStack();
                    expect(react_bindings_1.FocusTrapZone._focusStack.length).toBe(1);
                    expect(react_bindings_1.FocusTrapZone._focusStack[0]).toBe(baseFocusTrapZone);
                });
                removeTestContainer();
                return [2 /*return*/];
            });
        }); });
    });
});
