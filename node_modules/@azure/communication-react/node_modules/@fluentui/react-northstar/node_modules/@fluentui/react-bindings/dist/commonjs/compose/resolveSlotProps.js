"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.NullRender = void 0;
exports.resolveSlotProps = resolveSlotProps;

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var React = _interopRequireWildcard(require("react"));

var _consts = require("./consts");

var _mergeSlotProp = require("./mergeSlotProp");

var _excluded = ["children"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var NullRender = function NullRender() {
  return null;
};
/**
 * Helper utility which resolves the slots and slot props derived from user input.
 */


exports.NullRender = NullRender;

function resolveSlotProps(result, options) {
  var state = result.state,
      slots = result.slots,
      slotProps = result.slotProps; // Derive the default slot props from the config, if provided.

  options.slotProps.forEach(function (definition) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var nextSlotProps = definition(state);
    Object.keys(nextSlotProps).forEach(function (key) {
      slotProps[key] = Object.assign({}, slotProps[key], nextSlotProps[key]);
    });
  }); //  Mix unrecognized props onto root, appropriate, excluding the handled props.

  assignToMapObject(slotProps, 'root', getUnhandledProps(state, options)); // Iterate through slots and resolve shorthand values.

  Object.keys(slots).forEach(function (slotName) {
    var slot = slots[slotName]; // eslint-disable-next-line @typescript-eslint/no-explicit-any

    var slotProp = state[slotName];

    if (slot && slotProp !== undefined && slotProp !== null) {
      var mergedSlotProp = (0, _mergeSlotProp.mergeSlotProp)(slotProp, slotProps[slotName], slot && slot.shorthandConfig && slot.shorthandConfig.mappedProp || _consts.defaultMappedProps[slot]);

      if (typeof mergedSlotProp.children === 'function') {
        var children = slotProp.children,
            restProps = (0, _objectWithoutPropertiesLoose2.default)(slotProp, _excluded); // If the children is a function, replace the slot.

        slots[slotName] = React.Fragment;
        slotProps[slotName] = {
          children: slotProp.children(slot, Object.assign({}, slotProps[slotName], restProps))
        };
      } else {
        slotProps[slotName] = mergedSlotProp;
      }
    } // Ensure no slots are falsey


    if (!slots[slotName] || slotProp === null) {
      slots[slotName] = NullRender;
    }
  });
  return result;
}

function assignToMapObject(map, key, value) {
  if (value) {
    if (!map[key]) {
      map[key] = {};
    }

    map[key] = Object.assign({}, map[key], value);
  }
}

function getUnhandledProps(props, options) {
  var unhandledProps = {};
  var slots = Object.keys(options.slots);

  for (var _i = 0, _Object$keys = Object.keys(props); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (key !== 'className' && key !== 'as' && options.handledProps.indexOf(key) === -1 && slots.indexOf(key) === -1) {
      unhandledProps[key] = props[key];
    }
  }

  return unhandledProps;
}
//# sourceMappingURL=resolveSlotProps.js.map
