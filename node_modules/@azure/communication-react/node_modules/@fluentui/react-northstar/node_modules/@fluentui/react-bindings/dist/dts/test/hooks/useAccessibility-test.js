"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var enzyme_1 = require("enzyme");
var React = require("react");
var testBehavior = function (props) { return ({
    attributes: {
        root: {
            'aria-disabled': props.disabled,
            tabIndex: 1,
        },
        img: {
            'aria-label': 'Pixel',
            role: 'presentation',
        },
    },
    keyActions: {
        root: {
            click: {
                keyCombinations: [{ keyCode: accessibility_1.keyboardKey.ArrowDown }],
            },
        },
    },
}); };
var conditionalBehavior = function (props) { return ({
    attributes: {
        root: {
            'aria-label': 'Noop behavior',
        },
    },
    keyActions: {
        root: __assign({}, (!props.disabled && {
            click: {
                keyCombinations: [{ keyCode: accessibility_1.keyboardKey.ArrowDown }],
            },
        })),
        img: {
            click: {
                keyCombinations: [props.disabled ? { keyCode: accessibility_1.keyboardKey.ArrowDown } : { keyCode: accessibility_1.keyboardKey.ArrowUp }],
            },
        },
    },
}); };
var focusZoneBehavior = function () { return ({
    focusZone: {
        props: {
            disabled: true,
            shouldFocusOnMount: true,
        },
    },
}); };
var childOverriddenBehavior = function (props) { return ({
    attributes: {
        root: {
            'aria-pressed': props.pressed,
            'aria-label': 'overridden',
        },
    },
}); };
var childBehavior = function (props) { return ({
    attributes: {
        root: {
            'aria-pressed': props.pressed,
        },
    },
}); };
var overriddenChildBehavior = function (props) { return ({
    attributes: {
        root: {
            'aria-disabled': props.disabled,
            tabIndex: 1,
        },
        img: {
            'aria-label': 'Pixel',
            role: 'presentation',
        },
    },
    keyActions: {
        root: {
            click: {
                keyCombinations: [{ keyCode: accessibility_1.keyboardKey.ArrowDown }],
            },
        },
    },
    childBehaviors: {
        child: childOverriddenBehavior,
    },
}); };
var TestComponent = function (props) {
    var _a = props.accessibility, accessibility = _a === void 0 ? testBehavior : _a, disabled = props.disabled, onClick = props.onClick, onKeyDown = props.onKeyDown, rest = __rest(props, ["accessibility", "disabled", "onClick", "onKeyDown"]);
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        mapPropsToBehavior: function () { return ({
            disabled: disabled,
        }); },
        actionHandlers: {
            click: function (e) {
                if (onClick)
                    onClick(e, 'root');
            },
        },
    });
    return getA11Props.unstable_wrapWithFocusZone(React.createElement("div", __assign({}, getA11Props('root', __assign({ onKeyDown: onKeyDown }, rest))),
        React.createElement("img", __assign({}, getA11Props('img', {
            src: 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==',
        }))),
        React.createElement(ChildComponent, __assign({}, getA11Props('child', {})))));
};
var ChildComponent = function (props) {
    var _a = props.accessibility, accessibility = _a === void 0 ? childBehavior : _a, pressed = props.pressed, onKeyDown = props.onKeyDown, rest = __rest(props, ["accessibility", "pressed", "onKeyDown"]);
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        mapPropsToBehavior: function () { return ({
            pressed: pressed,
        }); },
    });
    return React.createElement("button", __assign({}, getA11Props('root', __assign({ onKeyDown: onKeyDown }, rest))));
};
var FocusZoneComponent = function (props) {
    var _a = props.as, ElementType = _a === void 0 ? 'div' : _a, children = props.children, _b = props.rtl, rtl = _b === void 0 ? false : _b;
    var getA11Props = react_bindings_1.useAccessibility(focusZoneBehavior, { rtl: rtl });
    return getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, __assign({}, getA11Props('root', {})), children));
};
var UnstableBehaviorDefinitionComponent = function (props) {
    var _a = props.accessibility, accessibility = _a === void 0 ? testBehavior : _a;
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        mapPropsToBehavior: function () { return ({
            disabled: false,
        }); },
    });
    return React.createElement("div", __assign({}, getA11Props.unstable_behaviorDefinition().attributes.root));
};
describe('useAccessibility', function () {
    it('sets attributes', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, null));
        expect(wrapper.find('div').prop('tabIndex')).toBe(1);
        expect(wrapper.find('img').prop('role')).toBe('presentation');
        expect(wrapper.find('ChildComponent').prop('accessibility')).toBe(undefined);
    });
    it('attributes can be conditional', function () {
        expect(enzyme_1.shallow(React.createElement(TestComponent, { disabled: true }))
            .find('div')
            .prop('aria-disabled')).toBe(true);
        expect(enzyme_1.shallow(React.createElement(TestComponent, { disabled: false }))
            .find('div')
            .prop('aria-disabled')).toBe(false);
    });
    it('attributes can be overridden', function () {
        expect(enzyme_1.shallow(React.createElement(TestComponent, { tabIndex: -1 }))
            .find('div')
            .prop('tabIndex')).toBe(-1);
    });
    it('child behaviors can be overridden', function () {
        expect(enzyme_1.shallow(React.createElement(TestComponent, { accessibility: overriddenChildBehavior }))
            .find('ChildComponent')
            .prop('accessibility')).toBe(childOverriddenBehavior);
    });
    it('it shoult return current definition from unstable_behaviorDefinition', function () {
        expect(enzyme_1.shallow(React.createElement(UnstableBehaviorDefinitionComponent, null))
            .find('div')
            .prop('aria-disabled')).toBe(false);
        expect(enzyme_1.shallow(React.createElement(UnstableBehaviorDefinitionComponent, null))
            .find('div')
            .prop('tabIndex')).toBe(1);
    });
    it('adds event handlers', function () {
        var onKeyDown = jest.fn();
        var onClick = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(TestComponent, { onClick: onClick, onKeyDown: onKeyDown }));
        wrapper.find('div').simulate('click').simulate('keydown', {
            keyCode: accessibility_1.keyboardKey.ArrowDown,
        });
        expect(onKeyDown).toBeCalledTimes(1);
        expect(onKeyDown).toBeCalledWith(expect.objectContaining({
            keyCode: accessibility_1.keyboardKey.ArrowDown,
        }));
        expect(onClick).toBeCalledTimes(1);
        expect(onClick).toBeCalledWith(expect.objectContaining({
            keyCode: accessibility_1.keyboardKey.ArrowDown,
        }), 'root');
    });
    it("adds user's keydown handler", function () {
        var onKeyDown = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(TestComponent, { accessibility: conditionalBehavior, onKeyDown: onKeyDown }));
        wrapper.find('div').simulate('keydown');
        expect(onKeyDown).toBeCalledTimes(1);
    });
    it('do not add any handlers by default', function () {
        var wrapper = enzyme_1.mount(React.createElement(TestComponent, { accessibility: conditionalBehavior, disabled: true }));
        expect(wrapper.find('div').prop('onKeyDown')).toBeUndefined();
    });
    it('handles conditional adding of handlers', function () {
        var wrapper = enzyme_1.mount(React.createElement(TestComponent, { accessibility: conditionalBehavior, disabled: true }));
        expect(wrapper.find('div').prop('onKeyDown')).toBeUndefined();
        wrapper.setProps({ disabled: false });
        expect(wrapper.find('div').prop('onKeyDown')).toBeDefined();
        wrapper.setProps({ disabled: true });
        expect(wrapper.find('div').prop('onKeyDown')).toBeUndefined();
    });
    it('handles conditional key combinations', function () {
        var onClick = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(TestComponent, { accessibility: conditionalBehavior, onClick: onClick }));
        wrapper.find('img').simulate('keydown', {
            keyCode: accessibility_1.keyboardKey.ArrowUp,
        });
        wrapper.setProps({ disabled: true });
        wrapper.find('img').simulate('keydown', {
            keyCode: accessibility_1.keyboardKey.ArrowUp, // Noop, will not call handler
        });
        wrapper.find('img').simulate('keydown', {
            keyCode: accessibility_1.keyboardKey.ArrowDown,
        });
        expect(onClick).toBeCalledTimes(2);
    });
    it('handlers are referentially stable', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, null));
        var handler = wrapper.find('div').prop('onKeyDown');
        wrapper.setProps({});
        expect(Object.is(handler, wrapper.find('div').prop('onKeyDown'))).toBe(true);
    });
    it('callbacks are referentially stable', function () {
        var prevOnKeyDown = jest.fn();
        var nextOnKeyDown = jest.fn();
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, { onKeyDown: prevOnKeyDown }));
        wrapper.find('div').simulate('keydown');
        wrapper.setProps({ onKeyDown: nextOnKeyDown });
        wrapper.find('div').simulate('keydown');
        wrapper.setProps({ onKeyDown: undefined });
        wrapper.find('div').simulate('keydown');
        expect(prevOnKeyDown).toBeCalledTimes(1);
        expect(nextOnKeyDown).toBeCalledTimes(1);
    });
    describe('FocusZone', function () {
        it('do not render FocusZone without the definition in a behavior', function () {
            expect(enzyme_1.shallow(React.createElement(TestComponent, null)).find('FocusZone')).toHaveLength(0);
        });
        it('renders FocusZone with the definition in a behavior', function () {
            expect(enzyme_1.shallow(React.createElement(FocusZoneComponent, null)).find('FocusZone')).toHaveLength(1);
        });
        it('applies props from the behavior to a FocusZone component', function () {
            expect(enzyme_1.shallow(React.createElement(FocusZoneComponent, null))
                .find('FocusZone')
                .props()).toEqual(expect.objectContaining({
                disabled: true,
                shouldFocusOnMount: true,
            }));
        });
        it('applies default props for FocusZone', function () {
            expect(enzyme_1.shallow(React.createElement(FocusZoneComponent, null))
                .find('FocusZone')
                .props()).toEqual(expect.objectContaining({
                preventFocusRestoration: true,
                shouldRaiseClicks: false,
            }));
        });
        it('passes "rtl" value', function () {
            expect(enzyme_1.shallow(React.createElement(FocusZoneComponent, null))
                .find('FocusZone')
                .prop('isRtl')).toBe(false);
            expect(enzyme_1.shallow(React.createElement(FocusZoneComponent, { rtl: true }))
                .find('FocusZone')
                .prop('isRtl')).toBe(true);
        });
    });
});
