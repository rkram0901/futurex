"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tooltip = exports.tooltipClassName = void 0;
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var positioner_1 = require("../../utils/positioner");
var PortalInner_1 = require("../Portal/PortalInner");
var TooltipContent_1 = require("./TooltipContent");
exports.tooltipClassName = 'ui-tooltip';
/**
 * A Tooltip displays additional non-modal information on top of its target element.
 * Tooltip doesn't receive focus and cannot contain focusable elements.
 *
 * @accessibility
 * Implements [ARIA Tooltip](https://www.w3.org/TR/wai-aria-practices-1.1/#tooltip) design pattern.
 */
var Tooltip = function (props) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.Tooltip.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var accessibility = props.accessibility, align = props.align, content = props.content, flipBoundary = props.flipBoundary, mountNode = props.mountNode, mouseLeaveDelay = props.mouseLeaveDelay, offset = props.offset, overflowBoundary = props.overflowBoundary, pointing = props.pointing, popperRef = props.popperRef, position = props.position, positionFixed = props.positionFixed, target = props.target, trigger = props.trigger, unstable_disableTether = props.unstable_disableTether, unstable_pinned = props.unstable_pinned, autoSize = props.autoSize, subtle = props.subtle, dismissOnContentMouseEnter = props.dismissOnContentMouseEnter, mouseEnterDelay = props.mouseEnterDelay;
    var _b = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultOpen,
        value: props.open,
        initialValue: false,
    }), open = _b[0], setOpen = _b[1];
    var triggerElement = react_bindings_1.useTriggerElement(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.Tooltip.handledProps, props);
    react_bindings_1.useOnIFrameFocus(open, context.target, function (e) {
        setOpen(function (__) {
            _.invoke(props, 'onOpenChange', e, __assign(__assign({}, props), { open: false }));
            return false;
        });
    });
    var contentRef = React.useRef();
    var pointerTargetRef = React.useRef();
    var triggerRef = React.useRef();
    var closeTimeoutId = React.useRef();
    var openTimeoutId = React.useRef();
    // TODO: Consider `getOrGenerateIdFromShorthand()` as hook and make it SSR safe
    var contentId = React.useRef();
    contentId.current = utils_1.getOrGenerateIdFromShorthand('tooltip-content-', content, contentId.current);
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        actionHandlers: {
            close: function (e) {
                setTooltipOpen(false, e);
                e.stopPropagation();
                e.preventDefault();
            },
        },
        mapPropsToBehavior: function () { return ({
            'aria-describedby': props['aria-describedby'],
            'aria-label': props['aria-label'],
            'aria-labelledby': props['aria-labelledby'],
            contentId: contentId.current,
            triggerAriaLabel: trigger && trigger.props['aria-label'],
            open: open,
        }); },
    });
    var getContentOverrideProps = function (predefinedProps) { return ({
        onMouseEnter: function (e) {
            if (!dismissOnContentMouseEnter) {
                setTooltipOpen(true, e);
            }
            _.invoke(predefinedProps, 'onMouseEnter', e);
        },
        onMouseLeave: function (e) {
            setTooltipOpen(false, e);
            _.invoke(predefinedProps, 'onMouseLeave', e);
        },
    }); };
    var renderPopperChildren = function (popperProps) {
        var tooltipContent = TooltipContent_1.TooltipContent.create(content, {
            defaultProps: function () {
                return getA11Props('tooltip', {
                    open: open,
                    placement: popperProps.placement,
                    pointing: pointing,
                    pointerRef: pointerTargetRef,
                    subtle: subtle,
                });
            },
            generateKey: false,
            overrideProps: getContentOverrideProps,
        });
        return tooltipContent ? React.createElement(react_component_ref_1.Ref, { innerRef: contentRef }, tooltipContent) : null;
    };
    var shouldStayOpen = function (e) {
        return _.invoke(e, 'currentTarget.contains', e.relatedTarget) || _.invoke(contentRef.current, 'contains', e.relatedTarget);
    };
    var trySetOpen = function (newValue, e) {
        setOpen(newValue);
        _.invoke(props, 'onOpenChange', e, __assign(__assign({}, props), { open: newValue }));
    };
    var setTooltipOpen = function (newOpen, e) {
        context.target.defaultView.clearTimeout(closeTimeoutId.current);
        context.target.defaultView.clearTimeout(openTimeoutId.current);
        if (newOpen) {
            if (mouseEnterDelay !== 0) {
                openTimeoutId.current = context.target.defaultView.setTimeout(function () {
                    trySetOpen(true, e);
                }, mouseEnterDelay);
            }
            else {
                trySetOpen(true, e);
            }
        }
        else {
            closeTimeoutId.current = context.target.defaultView.setTimeout(function () {
                trySetOpen(false, e);
            }, mouseLeaveDelay);
        }
    };
    var triggerProps = {
        onFocus: function (e) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (utils_1.isFromKeyboard()) {
                trySetOpen(true, e);
            }
            _.invoke.apply(_, __spreadArray([triggerElement, 'props.onFocus', e], args));
        },
        onBlur: function (e) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!shouldStayOpen(e)) {
                trySetOpen(false, e);
            }
            _.invoke.apply(_, __spreadArray([triggerElement, 'props.onBlur', e], args));
        },
        onMouseEnter: function (e) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            setTooltipOpen(true, e);
            utils_1.setWhatInputSource(context.target, 'mouse');
            _.invoke.apply(_, __spreadArray([triggerElement, 'props.onMouseEnter', e], args));
        },
        onMouseLeave: function (e) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            setTooltipOpen(false, e);
            _.invoke.apply(_, __spreadArray([triggerElement, 'props.onMouseLeave', e], args));
        },
    };
    var element = (React.createElement(React.Fragment, null,
        triggerElement && (React.createElement(react_component_ref_1.Ref, { innerRef: triggerRef }, React.cloneElement(triggerElement, getA11Props('trigger', __assign(__assign(__assign({}, unhandledProps), triggerElement.props), triggerProps))))),
        React.createElement(PortalInner_1.PortalInner, { mountNode: mountNode },
            React.createElement(positioner_1.Popper, { align: align, flipBoundary: flipBoundary, offset: offset, overflowBoundary: overflowBoundary, pointerTargetRef: pointerTargetRef, popperRef: popperRef, position: position, positionFixed: positionFixed, enabled: open, rtl: context.rtl, targetRef: target || triggerRef, children: renderPopperChildren, unstable_disableTether: unstable_disableTether, autoSize: autoSize, unstable_pinned: unstable_pinned }))));
    setEnd();
    return element;
};
exports.Tooltip = Tooltip;
exports.Tooltip.displayName = 'Tooltip';
exports.Tooltip.defaultProps = {
    align: 'center',
    position: 'above',
    mouseLeaveDelay: 10,
    mouseEnterDelay: 0,
    subtle: true,
    accessibility: accessibility_1.tooltipAsLabelBehavior,
    offset: [4, 4],
};
exports.Tooltip.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    as: false,
    content: false,
})), { dismissOnContentMouseEnter: PropTypes.bool, mouseEnterDelay: PropTypes.number, align: PropTypes.oneOf(positioner_1.ALIGNMENTS), subtle: PropTypes.bool, children: PropTypes.element, defaultOpen: PropTypes.bool, mountNode: customPropTypes.domNode, mouseLeaveDelay: PropTypes.number, offset: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.arrayOf(PropTypes.number),
    ]), open: PropTypes.bool, onOpenChange: PropTypes.func, pointing: PropTypes.bool, position: PropTypes.oneOf(positioner_1.POSITIONS), positionFixed: PropTypes.bool, target: customPropTypes.domNode, trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.element]), content: customPropTypes.shorthandAllowingChildren, unstable_disableTether: PropTypes.oneOf([true, false, 'all']), unstable_pinned: PropTypes.bool, autoSize: PropTypes.oneOf(positioner_1.AUTOSIZES), popperRef: customPropTypes.ref, flipBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), overflowBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]) });
exports.Tooltip.handledProps = Object.keys(exports.Tooltip.propTypes);
exports.Tooltip.Content = TooltipContent_1.TooltipContent;
exports.Tooltip.create = utils_1.createShorthandFactory({ Component: exports.Tooltip, mappedProp: 'content' });
