"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Accordion = exports.accordionSlotClassNames = exports.accordionClassName = void 0;
var accessibility_1 = require("@fluentui/accessibility");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var AccordionTitle_1 = require("./AccordionTitle");
var AccordionContent_1 = require("./AccordionContent");
var FocusContainer_1 = require("../../utils/accessibility/FocusHandling/FocusContainer");
var react_bindings_1 = require("@fluentui/react-bindings");
exports.accordionClassName = 'ui-accordion';
exports.accordionSlotClassNames = {
    content: exports.accordionClassName + "__content",
    title: exports.accordionClassName + "__title",
};
/**
 * An Accordion represents stacked set of content sections, with action elements to toggle the display of these sections.
 *
 * @accessibility
 * Implements [ARIA Accordion](https://www.w3.org/TR/wai-aria-practices-1.1/#accordion) design pattern (keyboard navigation not yet supported).
 */
exports.Accordion = React.forwardRef(function (props, ref) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.Accordion.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var expanded = props.expanded, exclusive = props.exclusive, accessibility = props.accessibility, children = props.children, className = props.className, design = props.design, styles = props.styles, variables = props.variables, panels = props.panels, renderPanelContent = props.renderPanelContent, renderPanelTitle = props.renderPanelTitle;
    var alwaysActiveIndex = expanded ? 0 : -1;
    var _b = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultActiveIndex,
        value: props.activeIndex,
        initialValue: exclusive ? alwaysActiveIndex : [alwaysActiveIndex],
    }), activeIndex = _b[0], setActiveIndex = _b[1];
    var actionHandlers = {
        moveNext: function (e) {
            e.preventDefault();
            focusHandler.moveNext();
        },
        movePrevious: function (e) {
            e.preventDefault();
            focusHandler.movePrevious();
        },
        moveFirst: function (e) {
            e.preventDefault();
            focusHandler.moveFirst();
        },
        moveLast: function (e) {
            e.preventDefault();
            focusHandler.moveLast();
        },
    };
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: exports.Accordion.displayName,
        actionHandlers: actionHandlers,
        rtl: context.rtl,
    });
    var classes = react_bindings_1.useStyles(exports.Accordion.displayName, {
        className: exports.accordionClassName,
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }).classes;
    var _c = React.useState(), focusedIndex = _c[0], setfocusedIndex = _c[1];
    var handleNavigationFocus = function (index) {
        setfocusedIndex(index);
    };
    var getNavigationItemsSize = function () { return props.panels.length; };
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.Accordion.handledProps, props);
    var ElementType = react_bindings_1.getElementType(props);
    var focusHandler = new FocusContainer_1.ContainerFocusHandler(getNavigationItemsSize, handleNavigationFocus, true);
    var itemRefs = React.useMemo(function () { return Array.from({ length: panels === null || panels === void 0 ? void 0 : panels.length }, function () { return React.createRef(); }); }, 
    // As we are using "panels.length" it's fine to have dependency on them
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [panels === null || panels === void 0 ? void 0 : panels.length]);
    React.useEffect(function () {
        var targetComponent = itemRefs[focusedIndex] && itemRefs[focusedIndex].current;
        targetComponent && targetComponent.focus();
    }, [itemRefs, focusedIndex]);
    var defaultAccordionTitleId = React.useMemo(function () { return _.uniqueId('accordion-title-'); }, []);
    var defaultAccordionContentId = React.useMemo(function () { return _.uniqueId('accordion-content-'); }, []);
    var computeNewIndex = function (index) {
        if (!isIndexActionable(index)) {
            return activeIndex;
        }
        if (exclusive)
            return index === activeIndex ? -1 : index;
        // check to see if index is in array, and remove it, if not then add it
        return _.includes(activeIndex, index)
            ? _.without(activeIndex, index)
            : __spreadArray(__spreadArray([], activeIndex), [index]);
    };
    var handleTitleOverrides = function (predefinedProps) { return ({
        onClick: function (e, titleProps) {
            var index = titleProps.index;
            var activeIndex = computeNewIndex(index);
            setActiveIndex(activeIndex);
            setfocusedIndex(index);
            _.invoke(props, 'onActiveIndexChange', e, __assign(__assign({}, props), { activeIndex: activeIndex }));
            _.invoke(predefinedProps, 'onClick', e, titleProps);
            _.invoke(props, 'onTitleClick', e, titleProps);
        },
        onFocus: function (e, titleProps) {
            _.invoke(predefinedProps, 'onFocus', e, titleProps);
            setfocusedIndex(predefinedProps.index);
        },
    }); };
    var isIndexActive = function (index) {
        return exclusive ? activeIndex === index : _.includes(activeIndex, index);
    };
    /**
     * Checks if panel at index can be actioned upon. Used in the case of expanded accordion,
     * when at least a panel needs to stay active. Will return false if expanded prop is true,
     * index is active and either it's an exclusive accordion or if there are no other active
     * panels open besides this one.
     *
     * @param index - The index of the panel.
     * @returns If the panel can be set active/inactive.
     */
    var isIndexActionable = function (index) {
        if (!isIndexActive(index)) {
            return true;
        }
        return !expanded || (!exclusive && activeIndex.length > 1);
    };
    var renderPanels = function () {
        var children = [];
        focusHandler.syncFocusedIndex(focusedIndex);
        _.each(panels, function (panel, index) {
            var content = panel.content, title = panel.title;
            var active = isIndexActive(+index);
            var canBeCollapsed = isIndexActionable(+index);
            var titleId = title['id'] || "" + defaultAccordionTitleId + index;
            var contentId = content['id'] || "" + defaultAccordionContentId + index;
            var contentRef = itemRefs[index];
            children.push(utils_1.createShorthand(AccordionTitle_1.AccordionTitle, title, {
                defaultProps: function () { return ({
                    className: exports.accordionSlotClassNames.title,
                    active: active,
                    index: +index,
                    contentRef: contentRef,
                    canBeCollapsed: canBeCollapsed,
                    id: titleId,
                    accordionContentId: contentId,
                }); },
                overrideProps: handleTitleOverrides,
                render: renderPanelTitle,
            }));
            if (active) {
                children.push(utils_1.createShorthand(AccordionContent_1.AccordionContent, content, {
                    defaultProps: function () { return ({
                        className: exports.accordionSlotClassNames.content,
                        active: active,
                        id: contentId,
                        accordionTitleId: titleId,
                    }); },
                    render: renderPanelContent,
                }));
            }
        });
        return children;
    };
    var element = (React.createElement(ElementType, __assign({}, getA11yProps('root', __assign(__assign({ className: classes.root }, unhandledProps), { ref: ref })), utils_1.rtlTextContainer.getAttributes({ forElements: [children] })), utils_1.childrenExist(children) ? children : renderPanels()));
    setEnd();
    return element;
});
exports.Accordion.displayName = 'Accordion';
exports.Accordion.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    content: false,
})), { activeIndex: customPropTypes.every([
        customPropTypes.disallow(['children']),
        PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.number]),
    ]), defaultActiveIndex: customPropTypes.every([
        customPropTypes.disallow(['children']),
        PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.number]),
    ]), exclusive: PropTypes.bool, expanded: PropTypes.bool, onTitleClick: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.func]), onActiveIndexChange: PropTypes.func, panels: customPropTypes.every([
        customPropTypes.disallow(['children']),
        PropTypes.arrayOf(PropTypes.shape({
            content: customPropTypes.itemShorthand,
            title: customPropTypes.itemShorthand,
        })),
    ]), renderPanelTitle: PropTypes.func, renderPanelContent: PropTypes.func });
exports.Accordion.defaultProps = {
    accessibility: accessibility_1.accordionBehavior,
    as: 'dl',
};
exports.Accordion.handledProps = Object.keys(exports.Accordion.propTypes);
exports.Accordion.Title = AccordionTitle_1.AccordionTitle;
exports.Accordion.Content = AccordionContent_1.AccordionContent;
exports.Accordion.create = utils_1.createShorthandFactory({
    Component: exports.Accordion,
});
