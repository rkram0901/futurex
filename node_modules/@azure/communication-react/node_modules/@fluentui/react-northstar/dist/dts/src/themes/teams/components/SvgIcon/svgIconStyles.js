"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.svgIconStyles = void 0;
var styles_1 = require("@fluentui/styles");
var utils_1 = require("../../../../utils");
var getPaddedStyle = function () { return ({
    padding: utils_1.pxToRem(4),
}); };
var getBorderedStyles = function (boxShadowColor) {
    return __assign(__assign({}, getPaddedStyle()), { boxShadow: "0 0 0 .05rem " + boxShadowColor + " inset" });
};
var getIconSize = function (size, v) {
    var modifiedSizes = {
        large: {
            x: 24,
            xx: 28,
        },
    };
    return v.sizeModifier && modifiedSizes[size] && modifiedSizes[size][v.sizeModifier]
        ? utils_1.pxToRem(modifiedSizes[size][v.sizeModifier])
        : v[size + "Size"];
};
var getXSpacingStyles = function (xSpacing, horizontalSpace) {
    switch (xSpacing) {
        case 'none':
            return { marginLeft: 0, marginRight: 0 };
        case 'before':
            return { marginLeft: horizontalSpace, marginRight: 0 };
        case 'after':
            return { marginLeft: 0, marginRight: horizontalSpace };
        case 'both':
            return { marginLeft: horizontalSpace, marginRight: horizontalSpace };
    }
};
exports.svgIconStyles = {
    root: function (_a) {
        var p = _a.props, v = _a.variables;
        return (__assign(__assign(__assign(__assign(__assign(__assign({ speak: 'none', verticalAlign: 'middle' }, getXSpacingStyles(p.xSpacing, v.horizontalSpace)), (p.circular && __assign(__assign({}, getPaddedStyle()), { borderRadius: '50%' }))), (p.disabled && {
            color: v.disabledColor,
        })), { display: 'inline-block' }), ((p.bordered || v.borderColor) && getBorderedStyles(v.borderColor || v.color || 'currentColor'))), { backgroundColor: v.backgroundColor }));
    },
    outlinePart: function (_a) {
        var p = _a.props;
        return __assign({ display: 'none' }, (p.outline && {
            display: 'block',
        }));
    },
    filledPart: function (_a) {
        var p = _a.props;
        return __assign({}, (p.outline && {
            display: 'none',
        }));
    },
    svg: function (_a) {
        var _b = _a.props, size = _b.size, disabled = _b.disabled, rotate = _b.rotate, v = _a.variables, rtl = _a.rtl;
        var iconSizeInRems = getIconSize(size, v);
        return __assign(__assign(__assign({ display: 'block', width: iconSizeInRems, height: iconSizeInRems, fill: v.color || 'currentColor' }, (disabled && {
            fill: v.disabledColor,
        })), { 
            // Manual flipping to make it compatible with Emotion and Fela in the same time
            transform: "rotate(" + rotate + "deg) /* @noflip */" }), (rtl && {
            transform: "rotate(" + -1 * rotate + "deg) /* @noflip */",
        }));
    },
    svgFlippingInRtl: function (config) {
        var props = config.props, rtl = config.rtl;
        return __assign(__assign({}, styles_1.callable(exports.svgIconStyles.svg)(config)), (rtl && {
            transform: "scaleX(-1) rotate(" + props.rotate + "deg) /* @noflip */",
        }));
    },
    redPath: function (_a) {
        var v = _a.variables;
        return ({
            fill: v.redColor,
        });
    },
};
