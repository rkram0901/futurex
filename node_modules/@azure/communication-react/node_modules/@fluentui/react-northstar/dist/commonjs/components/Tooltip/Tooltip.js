"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.tooltipClassName = exports.Tooltip = void 0;

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _accessibility = require("@fluentui/accessibility");

var _reactBindings = require("@fluentui/react-bindings");

var _reactComponentRef = require("@fluentui/react-component-ref");

var customPropTypes = _interopRequireWildcard(require("@fluentui/react-proptypes"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var React = _interopRequireWildcard(require("react"));

var _utils = require("../../utils");

var _positioner = require("../../utils/positioner");

var _PortalInner = require("../Portal/PortalInner");

var _TooltipContent = require("./TooltipContent");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var tooltipClassName = 'ui-tooltip';
/**
 * A Tooltip displays additional non-modal information on top of its target element.
 * Tooltip doesn't receive focus and cannot contain focusable elements.
 *
 * @accessibility
 * Implements [ARIA Tooltip](https://www.w3.org/TR/wai-aria-practices-1.1/#tooltip) design pattern.
 */

exports.tooltipClassName = tooltipClassName;

var Tooltip = function Tooltip(props) {
  var context = (0, _reactBindings.useFluentContext)();

  var _useTelemetry = (0, _reactBindings.useTelemetry)(Tooltip.displayName, context.telemetry),
      setStart = _useTelemetry.setStart,
      setEnd = _useTelemetry.setEnd;

  setStart();
  var accessibility = props.accessibility,
      align = props.align,
      content = props.content,
      flipBoundary = props.flipBoundary,
      mountNode = props.mountNode,
      mouseLeaveDelay = props.mouseLeaveDelay,
      offset = props.offset,
      overflowBoundary = props.overflowBoundary,
      pointing = props.pointing,
      popperRef = props.popperRef,
      position = props.position,
      positionFixed = props.positionFixed,
      target = props.target,
      trigger = props.trigger,
      unstable_disableTether = props.unstable_disableTether,
      unstable_pinned = props.unstable_pinned,
      autoSize = props.autoSize,
      subtle = props.subtle,
      dismissOnContentMouseEnter = props.dismissOnContentMouseEnter,
      mouseEnterDelay = props.mouseEnterDelay;

  var _useAutoControlled = (0, _reactBindings.useAutoControlled)({
    defaultValue: props.defaultOpen,
    value: props.open,
    initialValue: false
  }),
      open = _useAutoControlled[0],
      setOpen = _useAutoControlled[1];

  var triggerElement = (0, _reactBindings.useTriggerElement)(props);
  var unhandledProps = (0, _reactBindings.useUnhandledProps)(Tooltip.handledProps, props);
  (0, _reactBindings.useOnIFrameFocus)(open, context.target, function (e) {
    setOpen(function (__) {
      (0, _invoke2.default)(props, 'onOpenChange', e, Object.assign({}, props, {
        open: false
      }));
      return false;
    });
  });
  var contentRef = React.useRef();
  var pointerTargetRef = React.useRef();
  var triggerRef = React.useRef();
  var closeTimeoutId = React.useRef();
  var openTimeoutId = React.useRef(); // TODO: Consider `getOrGenerateIdFromShorthand()` as hook and make it SSR safe

  var contentId = React.useRef();
  contentId.current = (0, _utils.getOrGenerateIdFromShorthand)('tooltip-content-', content, contentId.current);
  var getA11Props = (0, _reactBindings.useAccessibility)(accessibility, {
    actionHandlers: {
      close: function close(e) {
        setTooltipOpen(false, e);
        e.stopPropagation();
        e.preventDefault();
      }
    },
    mapPropsToBehavior: function mapPropsToBehavior() {
      return {
        'aria-describedby': props['aria-describedby'],
        'aria-label': props['aria-label'],
        'aria-labelledby': props['aria-labelledby'],
        contentId: contentId.current,
        triggerAriaLabel: trigger && trigger.props['aria-label'],
        open: open
      };
    }
  });

  var getContentOverrideProps = function getContentOverrideProps(predefinedProps) {
    return {
      onMouseEnter: function onMouseEnter(e) {
        if (!dismissOnContentMouseEnter) {
          setTooltipOpen(true, e);
        }

        (0, _invoke2.default)(predefinedProps, 'onMouseEnter', e);
      },
      onMouseLeave: function onMouseLeave(e) {
        setTooltipOpen(false, e);
        (0, _invoke2.default)(predefinedProps, 'onMouseLeave', e);
      }
    };
  };

  var renderPopperChildren = function renderPopperChildren(popperProps) {
    var tooltipContent = _TooltipContent.TooltipContent.create(content, {
      defaultProps: function defaultProps() {
        return getA11Props('tooltip', {
          open: open,
          placement: popperProps.placement,
          pointing: pointing,
          pointerRef: pointerTargetRef,
          subtle: subtle
        });
      },
      generateKey: false,
      overrideProps: getContentOverrideProps
    });

    return tooltipContent ? /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
      innerRef: contentRef
    }, tooltipContent) : null;
  };

  var shouldStayOpen = function shouldStayOpen(e) {
    return (0, _invoke2.default)(e, 'currentTarget.contains', e.relatedTarget) || (0, _invoke2.default)(contentRef.current, 'contains', e.relatedTarget);
  };

  var trySetOpen = function trySetOpen(newValue, e) {
    setOpen(newValue);
    (0, _invoke2.default)(props, 'onOpenChange', e, Object.assign({}, props, {
      open: newValue
    }));
  };

  var setTooltipOpen = function setTooltipOpen(newOpen, e) {
    context.target.defaultView.clearTimeout(closeTimeoutId.current);
    context.target.defaultView.clearTimeout(openTimeoutId.current);

    if (newOpen) {
      if (mouseEnterDelay !== 0) {
        openTimeoutId.current = context.target.defaultView.setTimeout(function () {
          trySetOpen(true, e);
        }, mouseEnterDelay);
      } else {
        trySetOpen(true, e);
      }
    } else {
      closeTimeoutId.current = context.target.defaultView.setTimeout(function () {
        trySetOpen(false, e);
      }, mouseLeaveDelay);
    }
  };

  var triggerProps = {
    onFocus: function onFocus(e) {
      if ((0, _utils.isFromKeyboard)()) {
        trySetOpen(true, e);
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      _invoke2.default.apply(void 0, [triggerElement, 'props.onFocus', e].concat(args));
    },
    onBlur: function onBlur(e) {
      if (!shouldStayOpen(e)) {
        trySetOpen(false, e);
      }

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      _invoke2.default.apply(void 0, [triggerElement, 'props.onBlur', e].concat(args));
    },
    onMouseEnter: function onMouseEnter(e) {
      setTooltipOpen(true, e);
      (0, _utils.setWhatInputSource)(context.target, 'mouse');

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      _invoke2.default.apply(void 0, [triggerElement, 'props.onMouseEnter', e].concat(args));
    },
    onMouseLeave: function onMouseLeave(e) {
      setTooltipOpen(false, e);

      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      _invoke2.default.apply(void 0, [triggerElement, 'props.onMouseLeave', e].concat(args));
    }
  };
  var element = /*#__PURE__*/React.createElement(React.Fragment, null, triggerElement && /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
    innerRef: triggerRef
  }, /*#__PURE__*/React.cloneElement(triggerElement, getA11Props('trigger', Object.assign({}, unhandledProps, triggerElement.props, triggerProps)))), /*#__PURE__*/React.createElement(_PortalInner.PortalInner, {
    mountNode: mountNode
  }, /*#__PURE__*/React.createElement(_positioner.Popper, {
    align: align,
    flipBoundary: flipBoundary,
    offset: offset,
    overflowBoundary: overflowBoundary,
    pointerTargetRef: pointerTargetRef,
    popperRef: popperRef,
    position: position,
    positionFixed: positionFixed,
    enabled: open,
    rtl: context.rtl,
    targetRef: target || triggerRef,
    children: renderPopperChildren,
    unstable_disableTether: unstable_disableTether,
    autoSize: autoSize,
    unstable_pinned: unstable_pinned
  })));
  setEnd();
  return element;
};

exports.Tooltip = Tooltip;
Tooltip.displayName = 'Tooltip';
Tooltip.defaultProps = {
  align: 'center',
  position: 'above',
  mouseLeaveDelay: 10,
  mouseEnterDelay: 0,
  subtle: true,
  accessibility: _accessibility.tooltipAsLabelBehavior,
  offset: [4, 4]
};
Tooltip.propTypes = Object.assign({}, _utils.commonPropTypes.createCommon({
  as: false,
  content: false
}), {
  dismissOnContentMouseEnter: PropTypes.bool,
  mouseEnterDelay: PropTypes.number,
  align: PropTypes.oneOf(_positioner.ALIGNMENTS),
  subtle: PropTypes.bool,
  children: PropTypes.element,
  defaultOpen: PropTypes.bool,
  mountNode: customPropTypes.domNode,
  mouseLeaveDelay: PropTypes.number,
  offset: PropTypes.oneOfType([PropTypes.func, PropTypes.arrayOf(PropTypes.number)]),
  open: PropTypes.bool,
  onOpenChange: PropTypes.func,
  pointing: PropTypes.bool,
  position: PropTypes.oneOf(_positioner.POSITIONS),
  positionFixed: PropTypes.bool,
  target: customPropTypes.domNode,
  trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.element]),
  content: customPropTypes.shorthandAllowingChildren,
  unstable_disableTether: PropTypes.oneOf([true, false, 'all']),
  unstable_pinned: PropTypes.bool,
  autoSize: PropTypes.oneOf(_positioner.AUTOSIZES),
  popperRef: customPropTypes.ref,
  flipBoundary: PropTypes.oneOfType([PropTypes.object, PropTypes.arrayOf(PropTypes.object), PropTypes.oneOf(['clippingParents', 'window', 'scrollParent'])]),
  overflowBoundary: PropTypes.oneOfType([PropTypes.object, PropTypes.arrayOf(PropTypes.object), PropTypes.oneOf(['clippingParents', 'window', 'scrollParent'])])
});
Tooltip.handledProps = Object.keys(Tooltip.propTypes);
Tooltip.Content = _TooltipContent.TooltipContent;
Tooltip.create = (0, _utils.createShorthandFactory)({
  Component: Tooltip,
  mappedProp: 'content'
});
//# sourceMappingURL=Tooltip.js.map
