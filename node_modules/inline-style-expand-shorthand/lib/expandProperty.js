"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = preExpand;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var LENGTH_UNIT = /(em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|q|in|pt|pc|px|dpi|dpcm|dppx|%|auto)$/i;
var CALC = /^(calc\()/i;
var VAR = /^(var\()/i;
var BORDER_STYLE = /^(dashed|dotted|double|groove|hidden|inset|none|outset|ridge|solid)$/i;
var BORDER_WIDTH = /^(thick|medium|think)$/i;
var PURE_NUMBER = /^\d+$/;

function splitShorthand(value) {
  var values = [''];
  var openParensCount = 0;
  var trimmedValue = value.trim();

  for (var index = 0; index < trimmedValue.length; index += 1) {
    if (trimmedValue.charAt(index) === ' ' && openParensCount === 0) {
      // Add new value
      values.push('');
    } else {
      // Add the current character to the current value
      values[values.length - 1] = values[values.length - 1] + trimmedValue.charAt(index);
    } // Keep track of the number of parentheses that are yet to be closed.
    // This is done to avoid splitting at whitespaces within CSS functions.
    // E.g.: `calc(1px + 1em)`


    if (trimmedValue.charAt(index) === '(') {
      openParensCount++;
    } else if (trimmedValue.charAt(index) === ')') {
      openParensCount--;
    }
  }

  return values;
}

function parseBorder(value, resolve) {
  var values = splitShorthand(value);
  var longhands = {};
  values.forEach(function (val) {
    if (val.match(BORDER_STYLE) !== null) {
      longhands[resolve('Style')] = val;
    } else if (val.match(BORDER_WIDTH) !== null || val.match(LENGTH_UNIT) !== null || val.match(CALC) !== null || val === '0') {
      longhands[resolve('Width')] = val;
    } else {
      longhands[resolve('Color')] = val;
    }
  });
  return longhands;
}

function parseCircular(value, resolve) {
  var _ref;

  var _splitShorthand = splitShorthand(value),
      _splitShorthand2 = _slicedToArray(_splitShorthand, 4),
      Top = _splitShorthand2[0],
      _splitShorthand2$ = _splitShorthand2[1],
      Right = _splitShorthand2$ === void 0 ? Top : _splitShorthand2$,
      _splitShorthand2$2 = _splitShorthand2[2],
      Bottom = _splitShorthand2$2 === void 0 ? Top : _splitShorthand2$2,
      _splitShorthand2$3 = _splitShorthand2[3],
      Left = _splitShorthand2$3 === void 0 ? Right : _splitShorthand2$3;

  return _ref = {}, _defineProperty(_ref, resolve('Top'), Top), _defineProperty(_ref, resolve('Right'), Right), _defineProperty(_ref, resolve('Bottom'), Bottom), _defineProperty(_ref, resolve('Left'), Left), _ref;
}

function groupBy(values, divider) {
  var groups = [[]];
  values.forEach(function (val) {
    if (val === divider) {
      groups.push([]);
    } else {
      groups[groups.length - 1].push(val);
    }
  });
  return groups;
}

function parseBorderRadius(value) {
  var _groupBy = groupBy(splitShorthand(value), '/'),
      _groupBy2 = _slicedToArray(_groupBy, 2),
      _groupBy2$ = _groupBy2[0],
      first = _groupBy2$ === void 0 ? [] : _groupBy2$,
      _groupBy2$2 = _groupBy2[1],
      second = _groupBy2$2 === void 0 ? [] : _groupBy2$2;

  var _first = _slicedToArray(first, 4),
      Top = _first[0],
      _first$ = _first[1],
      Right = _first$ === void 0 ? Top : _first$,
      _first$2 = _first[2],
      Bottom = _first$2 === void 0 ? Top : _first$2,
      _first$3 = _first[3],
      Left = _first$3 === void 0 ? Right : _first$3;

  var _second = _slicedToArray(second, 4),
      Top2 = _second[0],
      _second$ = _second[1],
      Right2 = _second$ === void 0 ? Top2 : _second$,
      _second$2 = _second[2],
      Bottom2 = _second$2 === void 0 ? Top2 : _second$2,
      _second$3 = _second[3],
      Left2 = _second$3 === void 0 ? Right2 : _second$3;

  return {
    borderTopLeftRadius: [Top, Top2].filter(Boolean).join(' '),
    borderTopRightRadius: [Right, Right2].filter(Boolean).join(' '),
    borderBottomRightRadius: [Bottom, Bottom2].filter(Boolean).join(' '),
    borderBottomLeftRadius: [Left, Left2].filter(Boolean).join(' ')
  };
}

function parseTextDecoration(value) {
  // https://www.w3.org/TR/css-text-decor-3/#text-decoration-property
  var values = splitShorthand(value);

  if (values.length === 1) {
    // A text-decoration declaration that omits both the text-decoration-color and text-decoration-style
    // values is backwards-compatible with CSS Levels 1 and 2.
    if (values[0] === 'initial') {
      return {
        textDecorationLine: 'none'
      };
    }

    return {
      textDecorationLine: values[0]
    };
  } // There is more than 1 value specfied, which indicates it is CSS Level 3.


  var longhands = {};
  longhands.textDecorationLine = values[0];
  longhands.textDecorationStyle = values[1] || 'solid';
  longhands.textDecorationColor = values[2] || 'currentColor';
  return longhands;
}

var circularExpand = {
  borderWidth: function borderWidth(key) {
    return 'border' + key + 'Width';
  },
  borderColor: function borderColor(key) {
    return 'border' + key + 'Color';
  },
  borderStyle: function borderStyle(key) {
    return 'border' + key + 'Style';
  },
  padding: function padding(key) {
    return 'padding' + key;
  },
  margin: function margin(key) {
    return 'margin' + key;
  }
};
var borderExpand = {
  borderLeft: function borderLeft(key) {
    return 'borderLeft' + key;
  },
  borderTop: function borderTop(key) {
    return 'borderTop' + key;
  },
  borderRight: function borderRight(key) {
    return 'borderRight' + key;
  },
  borderBottom: function borderBottom(key) {
    return 'borderBottom' + key;
  },
  outline: function outline(key) {
    return 'outline' + key;
  }
};

function parseFlex(value) {
  var values = ['']; // https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values

  switch (value.trim()) {
    case 'initial':
      // "flex: initial" is equivalent to "flex: 0 1 auto"
      values = splitShorthand('0 1 auto');
      break;

    case 'auto':
      // "flex: auto" is equivalent to "flex: 1 1 auto"
      values = splitShorthand('1 1 auto');
      break;

    case 'none':
      // "flex: none" is equivalent to "flex: 0 0 auto"
      values = splitShorthand('0 0 auto');
      break;

    default:
      values = splitShorthand(value);
      break;
  } // https://developer.mozilla.org/en-US/docs/Web/CSS/flex#syntax
  // https://www.w3.org/TR/css-flexbox-1/
  // Expand one-value syntax to three-value syntax


  if (values.length === 1) {
    // One-value syntax
    var val = values[0];

    if (val.match(PURE_NUMBER) !== null) {
      values = splitShorthand(val + ' 1 0');
    } else {
      // It is a width value
      values = splitShorthand('1 1 ' + val);
    }
  }

  var longhands = {};

  if (values.length === 2) {
    // Two-value syntax
    longhands.flexGrow = values[0];

    if (values[1].match(PURE_NUMBER) !== null) {
      // The second value appears to be a shrink factor
      longhands.flexShrink = values[1];
    } else {
      // The second value appears to be width
      longhands.flexBasis = values[1];
    }
  } else {
    // Three-value syntax
    longhands.flexGrow = values[0];
    longhands.flexShrink = values[1];
    longhands.flexBasis = values[2];
  } // According to the spec: Authors are encouraged to control flexibility using the flex shorthand rather than with its longhand
  // properties directly, as the shorthand correctly resets any unspecified components to accommodate common uses.
  //
  // Thus in order to maintain the correct behavior, we have to reset any unspecified longhand properties to their default values.
  // Add default value, initialized value is "0 1 auto"


  if (typeof longhands.flexGrow === 'undefined') {
    longhands.flexGrow = '0';
  }

  if (typeof longhands.flexShrink === 'undefined') {
    longhands.flexShrink = '1';
  }

  if (typeof longhands.flexBasis === 'undefined') {
    longhands.flexBasis = 'auto';
  }

  return longhands;
}

function parseOverflow(value) {
  // https://www.w3.org/TR/css-overflow-3/#overflow-properties
  var values = splitShorthand(value); // The overflow property is a shorthand property that sets the specified values of overflow-x
  // and overflow-y in that order. If the second value is omitted, it is copied from the first.

  if (values.length === 1) {
    return {
      overflowX: values[0],
      overflowY: values[0]
    };
  }

  return {
    overflowX: values[0],
    overflowY: values[1]
  };
}

function parseGap(value) {
  // https://w3c.github.io/csswg-drafts/css-align/#gap-shorthand
  var _splitShorthand3 = splitShorthand(value),
      _splitShorthand4 = _slicedToArray(_splitShorthand3, 2),
      rowGap = _splitShorthand4[0],
      _splitShorthand4$ = _splitShorthand4[1],
      columnGap = _splitShorthand4$ === void 0 ? rowGap : _splitShorthand4$; // This property is a shorthand that sets row-gap and column-gap in one declaration. If <'column-gap'> is omitted, itâ€™s set to the same value as <'row-gap'>.


  return {
    rowGap: rowGap,
    columnGap: columnGap
  };
}

function expandProperty(property, value) {
  // special expansion for the border property as its 2 levels deep
  if (property === 'border') {
    var longhands = parseBorder(value.toString(), function (key) {
      return 'border' + key;
    });
    var result = {};

    for (var _property in longhands) {
      Object.assign(result, expandProperty(_property, longhands[_property]));
    }

    return result;
  }

  if (property === 'flex') {
    return parseFlex(value.toString());
  }

  if (property === 'borderRadius') {
    return parseBorderRadius(value.toString());
  }

  if (property === 'textDecoration') {
    return parseTextDecoration(value.toString());
  }

  if (property === 'overflow') {
    return parseOverflow(value.toString());
  }

  if (property === 'gap') {
    return parseGap(value.toString());
  }

  if (circularExpand[property]) {
    return parseCircular(value.toString(), circularExpand[property]);
  }

  if (borderExpand[property]) {
    return parseBorder(value.toString(), borderExpand[property]);
  }
}

function preExpand(property, value) {
  if (Array.isArray(value)) {
    var result = {};
    value.forEach(function (item) {
      var itemResult = expandProperty(property, item);

      if (itemResult) {
        Object.keys(itemResult).forEach(function (itemProperty) {
          result[itemProperty] = result[itemProperty] || [];
          result[itemProperty].push(itemResult[itemProperty]);
        });
      }
    });

    if (Object.keys(result).length) {
      return result;
    }

    return null;
  }

  return expandProperty(property, value);
}